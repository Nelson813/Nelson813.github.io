{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/debug.log","path":"debug.log","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"303807a605c2b09d19055f8318ede3d9f612c718","modified":1578972949450},{"_id":"source/debug.log","hash":"2748149abd2f166f365d950af008497526e6cbf5","modified":1578972949620},{"_id":"themes/next/.__config.yml","hash":"c62d5745073e369462c4862a504fdd3ba29d94a4","modified":1579146113850},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1578972949620},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1578972949620},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1579078055760},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1579078055760},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1578972949630},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1579078055760},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1578972949630},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1579078055770},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1579078055770},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1579078055770},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1579078055770},{"_id":"themes/next/README.md","hash":"898213e66d34a46c3cf8446bf693bd50db0d3269","modified":1579078055770},{"_id":"themes/next/_config.yml","hash":"9310e18e330785abc6b18f0b57337f9b36873c5c","modified":1579089773440},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1579078055770},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1579078055770},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1579078055800},{"_id":"source/_posts/._Android-Studio创建和导入新项目时，卡在等待进度条.md","hash":"f0bde0ffaf9dd22311a8434e85249445f0e4141f","modified":1578982924640},{"_id":"source/_posts/._Android-Studio那些错误的问题们.md","hash":"6802ad587e159fcc89bc2deb20cd81dba19df263","modified":1578973732950},{"_id":"source/_posts/._Android-native和js简单交互.md","hash":"cf840e76f0a0dcc84676fe434de17c30414e78db","modified":1578973733950},{"_id":"source/_posts/._Android-studio断点调试高级技巧总结.md","hash":"b276a07cc8c7293c812ea2bc741e607de91c271b","modified":1578973734700},{"_id":"source/_posts/._Android-在线源码阅读.md","hash":"2f61363a73af22dac2c5402f2beb58da617c3e41","modified":1579157171770},{"_id":"source/_posts/._Android6-0动态权限处理.md","hash":"9daaddf7341c7a25a38a1815ec22afff8eefb080","modified":1578973736880},{"_id":"source/_posts/._Android图片压缩.md","hash":"50545a8914395d69c23b7d43a01f6df1433c72e6","modified":1578973738010},{"_id":"source/_posts/._Github-Tips之Git.md","hash":"14ad215dd42b0630947a5060f0edd6ecabc588f5","modified":1578973738570},{"_id":"source/_posts/._Mac-外接硬盘安装操作系统的那些事.md","hash":"64bf29acd343cec3c636ed849131c521133457d0","modified":1578973742000},{"_id":"source/_posts/._Glide4-x在Android-8-0手机上加载图片崩溃问题.md","hash":"317d0b3001364b52271088ca30a09d47f71757d2","modified":1578973739970},{"_id":"source/_posts/._Replugin-源码分析1-源码导入阅读.md","hash":"7eab6c3d2cea1fc70d81e0f1c720803c97a3501b","modified":1579159986980},{"_id":"source/_posts/._Retrofit-几个疑问解答.md","hash":"2d5fe90cf0e7f7c9e0f856cf60b31578da862ea8","modified":1578973741340},{"_id":"source/_posts/._如何打败拖延症.md","hash":"cac492158af3fd12a5960407921f4cd9040aa06b","modified":1578973743590},{"_id":"source/_posts/._性能优化之Matrix.md","hash":"90fcece6b1d3964224f644e5730b77f914d49b58","modified":1578982911970},{"_id":"source/_posts/._断点调试-APT-和-Gradle-Plugin.md","hash":"bdf8c50095a365a17ffe7ceb86d63a27be0d77d0","modified":1579159863120},{"_id":"source/_posts/._性能优化之卡顿优化.md","hash":"31ed8ed5ea151fb854e937e95ce656958c6a3898","modified":1578984159250},{"_id":"source/_posts/Android-Studio那些错误的问题们.md","hash":"4abeb2320507d4679ab84450ef08e454add3120e","modified":1578972949450},{"_id":"source/_posts/Android-Studio创建和导入新项目时，卡在等待进度条.md","hash":"4641f12f47c293861bcc108aa858e64e942d683c","modified":1578972949450},{"_id":"source/_posts/Android-native和js简单交互.md","hash":"a0256cf6debea64e787b51bc9198cd3fc10e9f75","modified":1578972949450},{"_id":"source/_posts/Android-studio断点调试高级技巧总结.md","hash":"cc2dbcbc9d1652315243e1ae887fc8b9a6fcc2bb","modified":1578972949450},{"_id":"source/_posts/Android-在线源码阅读.md","hash":"7977c7648d63e6a0a15a130a5a6b7a2376467ebb","modified":1578972949450},{"_id":"source/_posts/Android6-0动态权限处理.md","hash":"f72e7a75cf4924f86f67130deaf953191b2542dd","modified":1578972949450},{"_id":"source/_posts/Android图片压缩.md","hash":"a58a1222d75e7ce8bf19390eac94818063d44556","modified":1578972949450},{"_id":"source/_posts/Github-Tips之Git.md","hash":"d7aa059563e4ca894f6a63faf3ada1fc100425ae","modified":1578972949450},{"_id":"source/_posts/Github-Tips之pull-request-PR.md","hash":"efe4c4bb01e9f4bb6d4b1c56c628e7154427f62d","modified":1578972949450},{"_id":"source/_posts/Github-Tips之快捷键.md","hash":"f471c3fa7b6365764a3f6bdbc49b594fcfc4e232","modified":1578972949450},{"_id":"source/_posts/Glide4-x在Android-8-0手机上加载图片崩溃问题.md","hash":"b6e971f98b9f5d29c48799e0e943a79b213ad9a1","modified":1578972949450},{"_id":"source/_posts/Java代理技术.md","hash":"522dfb3550f85ffcb7ce740a52a07811daf59857","modified":1578972949450},{"_id":"source/_posts/Mac-Terminal-终端代理配置.md","hash":"30c4e8aea9957ea0fc92fe4adc5df2cc3e8feb84","modified":1578972949450},{"_id":"source/_posts/Mac-外接硬盘安装操作系统的那些事.md","hash":"8d4bebb6d768e4c90223f0849d6296717da61a11","modified":1578972949460},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读.md","hash":"21f22f2150aa479618abbe6c442e658dfd655269","modified":1579159986970},{"_id":"source/_posts/Retrofit-几个疑问解答.md","hash":"61ced801bfb95d16fc6d1b4c307ab57b4bcdd366","modified":1578972949480},{"_id":"source/_posts/Tmux-使用教程.md","hash":"902ddcc8852b1a6d4b9dd476054f4d51dfa47f84","modified":1578972949480},{"_id":"source/_posts/Vim-常用命令.md","hash":"d30ac91481e6caed93c4d8cd37a1e22cc4b810a6","modified":1578972949480},{"_id":"source/_posts/一些常见专业词汇的正确写法.md","hash":"dac0cdca29694baa158675a0e839ceecca7c6996","modified":1578972949480},{"_id":"source/_posts/关于自己博客仓库的介绍.md","hash":"0396515faf974e0b986eedf423277ba61d87c230","modified":1578972949480},{"_id":"source/_posts/如何打败拖延症.md","hash":"9e027287b058ac31219f9190d45d571741028483","modified":1578972949490},{"_id":"source/_posts/性能优化之Matrix.md","hash":"6243b39c1d95c702049fd981f1ce09daa483d2a9","modified":1578973880790},{"_id":"source/_posts/性能优化之卡顿优化.md","hash":"e3428786458e4a5d14980f0b5a323200b7875264","modified":1578972949510},{"_id":"source/_posts/我的2017年.md","hash":"b593f8e6d6716486abe6d97b282c10ba94d2a418","modified":1578972949600},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin.md","hash":"2c64b1d6e0231b76740cbf156007f272221f98ff","modified":1578972949600},{"_id":"source/_posts/科学上网的姿势，帮你解决翻墙上网的烦恼.md","hash":"555d2d8dafbb06d7546a6eda696c8704e681263f","modified":1578972949620},{"_id":"source/about/index.md","hash":"842b488b8755c2c1083613289cfac87e870110e7","modified":1579140647730},{"_id":"source/categories/index.md","hash":"3a35019f783599fd853339b22cd6856bae5f4146","modified":1578972949620},{"_id":"source/tags/index.md","hash":"d40490f5009e549743712fc5e2ab5c57a69907ca","modified":1578972949620},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1579078055760},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1579078055760},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1579078055760},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1579078055760},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1579078055770},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1579078055770},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1579078055770},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1579078055770},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1579078055770},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1579078055770},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1579078055770},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1579078055770},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1579078055770},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1579078055770},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1579078055770},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1579078055780},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1579078055780},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1579078055780},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1579078055780},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1579078055780},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1579078055780},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1579078055800},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1579078055800},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1579078055800},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1579078055800},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1579078055800},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1579078055800},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1579078055800},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1579078055800},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1579078055800},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1578972949840},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1578972949850},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1578972949850},{"_id":"source/_posts/debug.log","hash":"2d17fc509580f68ea3f01f776469b5462ff4e155","modified":1578972949480},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578972949750},{"_id":"source/_posts/Mac-外接硬盘安装操作系统的那些事/installation_process.jpg","hash":"ae99b07b0770ec1217675770949423f26b3d4f10","modified":1578972949480},{"_id":"source/_posts/Mac-外接硬盘安装操作系统的那些事/wtg_setup.jpg","hash":"9d190cf46113ba5883c57cc5c945e66e2696748d","modified":1578972949480},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读/._replugin_host_demo.jpg","hash":"3be0c56ea7ed0122782e71ec020261d65805d456","modified":1578984272440},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读/._replugin_plugin_demo.jpg","hash":"c8ff28cd85f91767bf64992af81cca98d593ec61","modified":1578974803570},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读/._replugin_source_dir.jpg","hash":"d09d3c101b294162662a4578db3b056283ba9a8e","modified":1578983086080},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读/._replugin_source_reading.jpg","hash":"a36e749b1397b936d218d81fa0e1d8035ce266e0","modified":1578974422650},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读/replugin_plugin_demo.jpg","hash":"777c9a82da27faf1cbe830df86d1ab59b047edbf","modified":1578974803200},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读/replugin_source_dir.jpg","hash":"5c54437c84437ae4ed34f930f4f12c5d69b02500","modified":1578983085680},{"_id":"source/_posts/性能优化之卡顿优化/vsync_signal.png","hash":"905af8c75457185198010c19a4b1d40143819f0a","modified":1578972949590},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/connected_to_target_vm.jpg","hash":"863bdfaec7f1a871075d0326359b4e8b6cc0a664","modified":1578972949610},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/gradle_task_daemon.jpg","hash":"6efef0b3873d93fc21666a7e2fabf890bf7c82e5","modified":1578972949620},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/toolbar_debug_attach.jpg","hash":"f782af722939deb54a2a11343d99a5077e65fb24","modified":1578972949620},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/toolbar_edit_configurations.jpg","hash":"b048f6fc2dc15c8741c3e98a9507015ca4ad4f97","modified":1578972949620},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1578972949640},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1579078055780},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1579078055780},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1578972949640},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1579078055780},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1579078055780},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1579078055780},{"_id":"themes/next/layout/_partials/comments.swig","hash":"c3fbaf78e08d60d48ff816597bc38b810bbe83cb","modified":1579140647730},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1579078055780},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1579078055780},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1579078055780},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1579078055780},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1578972949660},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1578972949660},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1579078055780},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1578972949660},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1578972949660},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1579078055780},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1579078055790},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1579078055790},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1579078055800},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1579078055800},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1578972949680},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1579078055810},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1579078055810},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1578972949680},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1578972949680},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1579078055800},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1579078055810},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1579078055820},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1579078055820},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1579078055800},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1579078055800},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1579078055820},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1578972949750},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1579078055840},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1579078055840},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1578972949760},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1578972949760},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1578972949760},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1578972949760},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1578972949760},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1578972949760},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1578972949760},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1578972949760},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1579078055840},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1579078055840},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1578972949760},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1579078055840},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1578972949760},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1578972949760},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1578972949760},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1578972949760},{"_id":"themes/next/source/uploads/avatar.jpg","hash":"9180d6a080945d57acd6de866912ff0bba04c332","modified":1578972949840},{"_id":"source/_posts/Mac-Terminal-终端代理配置/shadowsocks_preferences.jpg","hash":"42e8d42443229fcb77f06f11c986440735526b85","modified":1578972949460},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读/replugin_host_demo.jpg","hash":"4ada2142ad98354fa40dbc314803c6967a40f099","modified":1578984272090},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读/replugin_source_reading.jpg","hash":"6ee31395a4f0559ce5bd9ffb5840be164bebda35","modified":1578974422270},{"_id":"source/_posts/性能优化之Matrix/matrix_tracecanary_arch.jpg","hash":"6c82d19d790b37d8e4fde9b91a1b0a9578da5171","modified":1578972949500},{"_id":"source/_posts/性能优化之卡顿优化/cpu_and_gpu.png","hash":"c973e29b43341ae31e19136a4ba2c50183a8ee87","modified":1578972949520},{"_id":"source/_posts/性能优化之卡顿优化/display_jank.png","hash":"38e8c7ae1105505bcf872a34a02a15269b02c529","modified":1578972949540},{"_id":"source/_posts/性能优化之卡顿优化/display_renderthread.png","hash":"7ac01ff08f8ebdb7964b5c0ffca2b32172418530","modified":1578972949540},{"_id":"source/_posts/性能优化之卡顿优化/optimize_recyclerview.png","hash":"23e1087cbe400ca9f5ee0d87887987bff37e5553","modified":1578972949560},{"_id":"source/_posts/性能优化之卡顿优化/pc_cpu_info.jpg","hash":"24c76a8f955bf556be1ad4f940e3532128a52bfb","modified":1578972949560},{"_id":"source/_posts/性能优化之卡顿优化/soft_draw_android3.0.png","hash":"5de87456ece1a43cc3c330c39c8702cba78b69df","modified":1578972949570},{"_id":"source/_posts/性能优化之卡顿优化/soft_draw_android4.0.png","hash":"7ac01ff08f8ebdb7964b5c0ffca2b32172418530","modified":1578972949580},{"_id":"source/_posts/性能优化之卡顿优化/view_displaylist.png","hash":"5d39f76ac3a72379741425db9e2c9fac2958454c","modified":1578972949590},{"_id":"source/_posts/性能优化之卡顿优化/view_reuse.png","hash":"2ab960ce95a5ec524748b36113f2278191b2e68b","modified":1578972949590},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/as_settings_remote.jpg","hash":"b5afd835ef812ecbe97c1981076e1c39b443a74e","modified":1578972949610},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578972949670},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578972949670},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/gradle_execute_remote_code.jpg","hash":"9d86a77ca7011e6eb2544850ebba0e69a4c0099b","modified":1578972949620},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578972949740},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578972949740},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578972949740},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578972949750},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579078055840},{"_id":"themes/next/source/images/alipay.jpg","hash":"29e6741ab301747e00b881a0eb6d86fd93b46111","modified":1578972949760},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"6817b75d2fcd81e8553df9854cba10e5cf068031","modified":1578972949760},{"_id":"source/_posts/性能优化之卡顿优化/flutter_render_engine.png","hash":"a4628f2dcec8859a831f389a9a2b3bdc360e82d0","modified":1578972949550},{"_id":"source/_posts/性能优化之卡顿优化/triple_buffering.png","hash":"885dea4c5ac5a2f566d64dc1316490cca3688f1c","modified":1578972949590},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1578972949660},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1578972949660},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1579078055780},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1578972949660},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1578972949660},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1578972949660},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1578972949660},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1578972949660},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1579078055780},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1578972949670},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1579078055780},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1578972949670},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1579078055790},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1579078055790},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1579078055790},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1579078055790},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1579078055790},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1579078055790},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1579078055790},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1579078055790},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1579078055790},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1579078055790},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1579078055790},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1579078055790},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1579078055790},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1579078055790},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1579078055790},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1579078055790},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"a8bb0731c0f89b51335eb0c4dd494020fb4bb5c8","modified":1579089577250},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1579078055790},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1579078055790},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"3164f2fb7bf5dc0f9c1cd96a818e5ff387ab19f0","modified":1579087323330},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1579078055790},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1579078055790},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1579078055790},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1579078055800},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1579078055800},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1579078055800},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1579078055800},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1578972949740},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1579078055830},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1579078055830},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1579078055830},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1579078055840},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1579078055840},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1579078055840},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1578972949770},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1578972949770},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1579078055840},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1579078055840},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1578972949770},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1579078055850},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1579078055850},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1579078055850},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1579078055850},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1578972949770},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1579078055850},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1578972949770},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1578972949780},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1579078055860},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1578972949810},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1578972949810},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1578972949820},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1578972949810},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1578972949810},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1579078055860},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1578972949820},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1578972949820},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1578972949820},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1578972949830},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1578972949830},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1578972949830},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1578972949830},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1578972949840},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1578972949830},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1578972949840},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1579078055890},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1579078055890},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1579078055890},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1579078055890},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1579078055890},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1579078055890},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1579078055890},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1579078055890},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1579078055890},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1579078055890},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1579078055890},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1579078055890},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1579078055890},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1579078055890},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1579078055900},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1579078055900},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1579078055900},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1579078055900},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1579078055900},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1579078055900},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1578972949840},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1578972949840},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1578972949840},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1578972949840},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1578972949840},{"_id":"source/_posts/性能优化之卡顿优化/android_graphic_system_arch.png","hash":"26992ea7fc3db5ff3d03a4ac4b877242d626304d","modified":1578972949510},{"_id":"source/_posts/性能优化之卡顿优化/litho_thread_model.png","hash":"8e66bca7244f229f9022c4ef1e7adfd57e88af74","modified":1578972949550},{"_id":"source/_posts/性能优化之卡顿优化/screen_adaptation_table.png","hash":"73959ea4c7e60ebe3f0fe20d5530d6251fb4d7fa","modified":1578972949570},{"_id":"source/_posts/性能优化之卡顿优化/ui_display_flow.png","hash":"eb9e58ff13f95bf1fa26722abf4fa454d3773353","modified":1578972949590},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1579078055840},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1578972949830},{"_id":"source/_posts/Mac-Terminal-终端代理配置/terminal_ping.jpg","hash":"d8afa344e34a9c948f467260319bbbd568575001","modified":1578972949460},{"_id":"source/_posts/性能优化之Matrix/matrix_compile_flow.jpg","hash":"2bd59fefa638a4f2e81e8b9281cf1ded54dcd5c3","modified":1578972949490},{"_id":"source/_posts/性能优化之卡顿优化/async_create_view.png","hash":"ec8bf7f6e8d30083bf27bdd16a5a8610e45b3f1f","modified":1578972949520},{"_id":"source/_posts/性能优化之卡顿优化/android_thread_model.png","hash":"13847ea8b464cb100b65a7b4200ed10d6169cf00","modified":1578972949510},{"_id":"source/_posts/性能优化之卡顿优化/systrace_demo_code.jpg","hash":"4f62530bc93f4f729f922bd7b11970f19973c564","modified":1578972949580},{"_id":"source/_posts/性能优化之卡顿优化/xrk_process_cpu.jpg","hash":"19b7a134d63ea66eb117116ccf4b1defa82c77e6","modified":1578972949600},{"_id":"source/_posts/性能优化之卡顿优化/xrk_homepage.png","hash":"deb92c78cb48e136a34094f9ef0c00455ac1dd6c","modified":1578972949600},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1579078055800},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1579078055800},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1578972949690},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1578972949690},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1578972949730},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1578972949740},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1579078055830},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1578972949740},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1579078055830},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1578972949740},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1579078055830},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1578972949740},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1579078055840},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1578972949740},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1578972949740},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1578972949740},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1578972949740},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1579078055840},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1578972949740},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1578972949740},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1578972949750},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1578972949750},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1579078055840},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1578972949750},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1578972949750},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1578972949750},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1579078055840},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1579078055840},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1578972949750},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1579078055840},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1578972949750},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1579078055850},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1579078055850},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1579078055850},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1579078055850},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1578972949780},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1578972949780},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1578972949780},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1578972949780},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1578972949780},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1578972949780},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1578972949810},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1578972949810},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1578972949810},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1578972949810},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1578972949810},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1579078055860},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1578972949820},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1579078055860},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1578972949840},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1578972949840},{"_id":"source/_posts/性能优化之卡顿优化/layout_flat.png","hash":"5af128b76f15e4d7d54255d71f5cc45892c386fc","modified":1578972949550},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1578972949840},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1579078055880},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1579078055890},{"_id":"source/_posts/性能优化之卡顿优化/as_profiler.jpg","hash":"be2e6a691c08ce2e6ba5af6c9b1cdc93fc43bc5f","modified":1578972949520},{"_id":"source/_posts/性能优化之卡顿优化/ddms_traceview_setting.jpg","hash":"b4fea0ef42f53e2c3736d32dc927452ee194321c","modified":1578972949540},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1578972949690},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1578972949690},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1578972949690},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1578972949690},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1578972949690},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1578972949690},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1578972949690},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1578972949690},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1578972949690},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1578972949690},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1578972949700},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1578972949700},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1578972949700},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1578972949700},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1579078055820},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1578972949700},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1578972949700},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1578972949700},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1578972949700},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1578972949730},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1578972949730},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1578972949730},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1578972949730},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1578972949730},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1578972949730},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1578972949740},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1578972949730},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"e6d4bdee6183fba28264d34b976dad9a92d8dfba","modified":1579087423360},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1578972949740},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1579078055830},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"cc1f65c32150f2608ec0a39c99e332df57deb05e","modified":1579087458150},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1579078055840},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1578972949750},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1579078055840},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1579078055850},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1579078055850},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1579078055850},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1579078055850},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1579078055850},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1578972949810},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1578972949810},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1578972949810},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1578972949810},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1578972949810},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1578972949810},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1579078055860},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1579078055860},{"_id":"source/_posts/性能优化之Matrix/xrk_matrix_analyse_result.png","hash":"82bf5f2537553e20eaa8439837a01392419b643e","modified":1578972949500},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1579078055850},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1579078055880},{"_id":"source/_posts/性能优化之卡顿优化/pc_cpu_usage.jpg","hash":"d713d49e07bcc1f31604a012414f0d8462f925c4","modified":1578972949570},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1578972949770},{"_id":"source/_posts/性能优化之卡顿优化/systrace_result.jpg","hash":"797e44a262bd5db5e4d7903f44080f77ca46c916","modified":1578972949580},{"_id":"source/_posts/性能优化之Matrix/xrk_matrix_fps_result.png","hash":"f07eae087c9172af021c8112535fa621379a450a","modified":1578972949510},{"_id":"source/_posts/性能优化之Matrix/matrix_methodmapping.jpg","hash":"f33e51f92efc2a4daf4c771a12b6a3798d5215ef","modified":1578972949490},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1579078055900},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1579078055880},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/debug_coding_sense.jpg","hash":"fa75e9bd54742b2c99a083e7e55de7ee35b8f3ff","modified":1578972949610},{"_id":"source/_posts/性能优化之卡顿优化/overdraw_tools.png","hash":"fc43431e55c2688c562675cbb77a4efd56aa0fe2","modified":1578972949560},{"_id":"source/_posts/性能优化之卡顿优化/ddms_traceview_result.jpg","hash":"a8fb44713a5e432b162da7485f18c26c4584b740","modified":1578972949530},{"_id":"public/about/index.html","hash":"9c8fd373fc1f249d3c84c4e5b9be81880ce05d1b","modified":1579160077239},{"_id":"public/categories/index.html","hash":"028222d806a1ec46689bfae3053cde09ed40ce8d","modified":1579160077240},{"_id":"public/tags/index.html","hash":"f5ac0d9f8e78e86d8516ca1947a2270abe8e28b5","modified":1579160077240},{"_id":"public/archives/page/3/index.html","hash":"c443948d56ecd97825d8e448cea1f50292cbc146","modified":1579160077240},{"_id":"public/archives/2017/index.html","hash":"4a2b7991e4cda3c27b91df2c3a5a4a7a95627409","modified":1579160077240},{"_id":"public/archives/2017/02/index.html","hash":"1c8f8ea1455ba9436dd84f4cb1bf82c6ab275ca4","modified":1579160077240},{"_id":"public/archives/2017/03/index.html","hash":"1465d6476d2ab3bc66d4635dcb0a560717d964a5","modified":1579160077240},{"_id":"public/archives/2017/04/index.html","hash":"eb9976872360ed7a909cf7e18a02163f4dcc79c2","modified":1579160077241},{"_id":"public/archives/2017/05/index.html","hash":"231a6ce1401b27bff993a028ced431eacd2c37f6","modified":1579160077241},{"_id":"public/archives/2018/page/2/index.html","hash":"1cb0a79a178b592912d1c9fafdb5866d8f1775e8","modified":1579160077241},{"_id":"public/archives/2018/01/index.html","hash":"adea71ecd07e23d7dc9b0d90ad9b9e6858c8e11a","modified":1579160077241},{"_id":"public/archives/2018/03/index.html","hash":"1f103468b3640dff4ae19815c6e6068cd8ada9f3","modified":1579160077241},{"_id":"public/archives/2018/07/index.html","hash":"6f9d0b11cb4430b7a44049c641f48cc241061b71","modified":1579160077241},{"_id":"public/archives/2018/08/index.html","hash":"edb9b19b1c27079f2d85ef549c66624c5682c58b","modified":1579160077241},{"_id":"public/archives/2018/10/index.html","hash":"f623b74950fea0a58664692f23a8576ec6d639d4","modified":1579160077241},{"_id":"public/archives/2018/12/index.html","hash":"e8f97c8e89f27f5ceb6b1c973bf5c0d3c30899ad","modified":1579160077242},{"_id":"public/archives/2019/07/index.html","hash":"599ab40e28a32157f507de19688b9217d0a66db1","modified":1579160077243},{"_id":"public/archives/2019/09/index.html","hash":"f29e79dde7c6d12a30867186de980ae7a49828de","modified":1579160077243},{"_id":"public/archives/2019/10/index.html","hash":"f5c08bd14eb7dfd6648de81f20a8cddb74d00df4","modified":1579160077243},{"_id":"public/archives/2019/11/index.html","hash":"3931fd949332ffb27164a1fc59c4c59a32e54630","modified":1579160077243},{"_id":"public/archives/2019/12/index.html","hash":"f31232c36ff2e588fb810d1b416faa668dad0a0c","modified":1579160077243},{"_id":"public/archives/2020/index.html","hash":"82a06c766f2116d425e537648b0fc050566ebfdf","modified":1579160077243},{"_id":"public/archives/2020/01/index.html","hash":"f85d76d43948130f4e1e21b916f7a6b8e5eae9e2","modified":1579160077243},{"_id":"public/categories/Android-Studio/index.html","hash":"26fe42d38b2793ff49ec1b0badd5958bf998eef4","modified":1579160077243},{"_id":"public/categories/Android/page/2/index.html","hash":"2be0776a69010a8a7431f1a3a4e4294edca3eed7","modified":1579160077243},{"_id":"public/categories/Github/index.html","hash":"d1b923781d51f402165d694a699a29dcd5832ec6","modified":1579160077243},{"_id":"public/categories/Java/index.html","hash":"e8110870c52f91ec4793572482ee5b3e8465cb6d","modified":1579160077243},{"_id":"public/categories/Mac/index.html","hash":"a5d39dcf3ede8a3b05454539b968ba88ef0b8ed0","modified":1579160077243},{"_id":"public/categories/工具/index.html","hash":"354cd140dc90deb9aead16c6ac30060385cb4b30","modified":1579160077243},{"_id":"public/categories/Vim/index.html","hash":"a33b3fa8ed9a893a0caa1a93718aa9a6029bda3f","modified":1579160077243},{"_id":"public/categories/技术规范/index.html","hash":"954fd7532b2a80079cdfd582869e4a2a3b3f173d","modified":1579160077244},{"_id":"public/categories/Hexo/index.html","hash":"e889323ca07892ddb82db772c95c7114558491f8","modified":1579160077244},{"_id":"public/categories/Life/index.html","hash":"f11f01ad402903b49d4aeecf13f0628021d3c862","modified":1579160077244},{"_id":"public/categories/Android/性能优化/index.html","hash":"0431c442f8c7452f9922f832ca7dbf433b178d41","modified":1579160077244},{"_id":"public/categories/Android/调试/index.html","hash":"a2720610430c99c82bdbd593bc12570ea64e5b25","modified":1579160077244},{"_id":"public/categories/翻墙/index.html","hash":"585ae9d3f8b5b8e555d0976ea900b11f26d55d7a","modified":1579160077244},{"_id":"public/tags/Android-Studio/index.html","hash":"603f8fc51cc97b33ae377df724afff187b6eaa71","modified":1579160077244},{"_id":"public/tags/Github/index.html","hash":"399825a0bf4811a585b7ab6f7acced7ec2d43567","modified":1579160077244},{"_id":"public/tags/Java/index.html","hash":"19884d64454b50e70dc97c3e7999954cd8a3507a","modified":1579160077245},{"_id":"public/tags/Mac/index.html","hash":"973455496a6e17dc6fbb1c67cd623b509b631711","modified":1579160077245},{"_id":"public/tags/插件化/index.html","hash":"bb0f580ff5f9b4cda1d97211ddda7769f130bf21","modified":1579160077245},{"_id":"public/tags/工具/index.html","hash":"a5b0df3ae9f23f849d00b0acbdb77d9bea4bc96f","modified":1579160077245},{"_id":"public/tags/Vim/index.html","hash":"12985e08c3f8e662c70f1ac3ad7bfb7d2d6fa447","modified":1579160077245},{"_id":"public/tags/技术规范/index.html","hash":"27388f035b2d82b3ec3ed409fbd0fd76d5f3c3ad","modified":1579160077245},{"_id":"public/tags/Hexo/index.html","hash":"d15afea80ddc5fc1b2d9d56158f87013e3eee4ea","modified":1579160077245},{"_id":"public/tags/Life/index.html","hash":"13cb343684c7e17f9b632109444201b209fb41ce","modified":1579160077245},{"_id":"public/tags/调试/index.html","hash":"45d23162f1cfe30061b26f6897c6172332a9caf1","modified":1579160077245},{"_id":"public/tags/翻墙/index.html","hash":"f53049c57b6bdbca3fbf40227f97db892de63ae9","modified":1579160077245},{"_id":"public/2020/01/14/Replugin-源码分析1-源码导入阅读/index.html","hash":"331340af66422944471c6945184bd0c4a1e76aae","modified":1579160077245},{"_id":"public/2019/12/30/Tmux-使用教程/index.html","hash":"91877a914be6d4a7c16945bcb6cf9360129acfe2","modified":1579160077245},{"_id":"public/2019/12/03/Mac-Terminal-终端代理配置/index.html","hash":"adbdc673e917e013a09cd880f39f9093cfc9465f","modified":1579160077245},{"_id":"public/2019/12/02/断点调试-APT-和-Gradle-Plugin/index.html","hash":"33a1d5e058f4020fb1caec07b7d7fa7ad11f6de6","modified":1579160077245},{"_id":"public/2019/11/25/Mac-外接硬盘安装操作系统的那些事/index.html","hash":"edfbea523ed32586c1fa58bd1a54fa27281d7faa","modified":1579160077246},{"_id":"public/2019/11/25/Retrofit-几个疑问解答/index.html","hash":"4bd133e0ba567e517b09906fda345f88afd116ee","modified":1579160077246},{"_id":"public/2019/10/14/性能优化之Matrix/index.html","hash":"d7bed03610d500e263e3b29712a1f0d4df7c3548","modified":1579160077246},{"_id":"public/2019/10/07/Vim-常用命令/index.html","hash":"8ebfafb83ae75d0e0a634cf250f021b7b2858d4b","modified":1579160077246},{"_id":"public/2019/09/19/性能优化之卡顿优化/index.html","hash":"f7f706a75656ab51c7becc2895822fac471a5fec","modified":1579160077246},{"_id":"public/2019/07/06/Android-在线源码阅读/index.html","hash":"8df04be3c3324e2addbdeaee70abf3c8d3e938f7","modified":1579160077246},{"_id":"public/2018/12/08/一些常见专业词汇的正确写法/index.html","hash":"09975f55118211a851edab4e5c2b883e2e478495","modified":1579160077246},{"_id":"public/2018/10/07/关于自己博客仓库的介绍/index.html","hash":"c6ee89908be0121f11e82c82760005b98514b59c","modified":1579160077246},{"_id":"public/2018/08/04/Github-Tips之Git/index.html","hash":"5bf92499b7ebb004bf5f166260c5626797c38b71","modified":1579160077246},{"_id":"public/2018/08/04/Github-Tips之快捷键/index.html","hash":"14f6410f843d230a93c7508b05fd1dfa2fb85a62","modified":1579160077246},{"_id":"public/2018/08/04/Github-Tips之pull-request-PR/index.html","hash":"8666969b4bc4bb6ae854fc5e87987b4ec04e4118","modified":1579160077246},{"_id":"public/2018/08/03/Java代理技术/index.html","hash":"4a8d5d2eb52d040f99a67fdb86daced3cf44418e","modified":1579160077246},{"_id":"public/2018/07/15/Glide4-x在Android-8-0手机上加载图片崩溃问题/index.html","hash":"ab8228b0a4285acd2b85baefb8c135c96a4e1215","modified":1579160077246},{"_id":"public/2018/03/25/科学上网的姿势，帮你解决翻墙上网的烦恼/index.html","hash":"7be309e7dbccc33fdf29d2fe6edc36d8e226a1fd","modified":1579160077246},{"_id":"public/2018/03/24/Android-Studio创建和导入新项目时，卡在等待进度条/index.html","hash":"b7295648bf83b6b705639a6d0e960dbe23433685","modified":1579160077246},{"_id":"public/2018/03/20/Android-Studio那些错误的问题们/index.html","hash":"aa835c1d8da73b564c32d48b303c78a5fe66a247","modified":1579160077246},{"_id":"public/2018/01/02/我的2017年/index.html","hash":"31a9acd53b0cddd942c23172ef7985a36115f4e4","modified":1579160077246},{"_id":"public/2017/05/07/Android6-0动态权限处理/index.html","hash":"a5cbeabbc947b9de67e10ba8fe54df8c5b3d06b1","modified":1579160077246},{"_id":"public/2017/04/02/如何打败拖延症/index.html","hash":"610625d3826c154f7241fb7dfb80bbca81b989b6","modified":1579160077246},{"_id":"public/2017/03/06/Android-studio断点调试高级技巧总结/index.html","hash":"b0ee73c2d68c98ce8104d10bf298c92fbaac76a7","modified":1579160077246},{"_id":"public/2017/02/28/Android-native和js简单交互/index.html","hash":"fa1c0765af70ee123387530775b43b6e4aec1c33","modified":1579160077247},{"_id":"public/2017/02/23/Android图片压缩/index.html","hash":"f112e92cb92b47cc662865a331d5b38bfd1fddd8","modified":1579160077247},{"_id":"public/archives/index.html","hash":"e0ebe3470f548bad34bcd2979cc5f8aed127b457","modified":1579160077247},{"_id":"public/archives/page/2/index.html","hash":"c143e7d08a31364f059862428c21465793f634e5","modified":1579160077247},{"_id":"public/archives/2018/index.html","hash":"bc48b20f0f9d35038c1865a991b3dd411b9d0fb1","modified":1579160077247},{"_id":"public/archives/2019/index.html","hash":"f480af6d73bae132fddb4b8372315ea7c3b4293f","modified":1579160077247},{"_id":"public/categories/Android/index.html","hash":"eadd8e22c3dadfe2abd1a97a991071c88bfe61ef","modified":1579160077247},{"_id":"public/index.html","hash":"0a8190cd4e9eed164b218cad02b175109c2eea05","modified":1579160077247},{"_id":"public/page/2/index.html","hash":"d04658de5163dae6e4a296606e0e86ef72b3129a","modified":1579160077247},{"_id":"public/page/3/index.html","hash":"c1f7a82201d37e625f96e4b60e9f1dbed281b37d","modified":1579160077247},{"_id":"public/tags/Android/index.html","hash":"130446435eb451ac873b9f71374eb23d276be1bc","modified":1579160077247},{"_id":"public/CNAME","hash":"303807a605c2b09d19055f8318ede3d9f612c718","modified":1579160077267},{"_id":"public/debug.log","hash":"2748149abd2f166f365d950af008497526e6cbf5","modified":1579160077267},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1579160077267},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1579160077267},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1579160077267},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1579160077267},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1579160077267},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1579160077267},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1579160077267},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1579160077267},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1579160077267},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1579160077268},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1579160077268},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1579160077268},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1579160077268},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1579160077268},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1579160077268},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1579160077268},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1579160077268},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1579160077268},{"_id":"public/uploads/avatar.jpg","hash":"9180d6a080945d57acd6de866912ff0bba04c332","modified":1579160077268},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1579160077268},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1579160077268},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1579160077268},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1579160077268},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1579160077268},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1579160077268},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1579160077268},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1579160077268},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1579160077268},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1579160077268},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1579160077268},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1579160077268},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1579160077268},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1579160077269},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1579160077269},{"_id":"public/2019/11/25/Mac-外接硬盘安装操作系统的那些事/installation_process.jpg","hash":"ae99b07b0770ec1217675770949423f26b3d4f10","modified":1579160077269},{"_id":"public/2019/11/25/Mac-外接硬盘安装操作系统的那些事/wtg_setup.jpg","hash":"9d190cf46113ba5883c57cc5c945e66e2696748d","modified":1579160077269},{"_id":"public/2020/01/14/Replugin-源码分析1-源码导入阅读/replugin_plugin_demo.jpg","hash":"777c9a82da27faf1cbe830df86d1ab59b047edbf","modified":1579160077269},{"_id":"public/2020/01/14/Replugin-源码分析1-源码导入阅读/replugin_source_dir.jpg","hash":"5c54437c84437ae4ed34f930f4f12c5d69b02500","modified":1579160077269},{"_id":"public/2019/12/02/断点调试-APT-和-Gradle-Plugin/connected_to_target_vm.jpg","hash":"863bdfaec7f1a871075d0326359b4e8b6cc0a664","modified":1579160077269},{"_id":"public/2019/12/02/断点调试-APT-和-Gradle-Plugin/gradle_task_daemon.jpg","hash":"6efef0b3873d93fc21666a7e2fabf890bf7c82e5","modified":1579160077269},{"_id":"public/2019/12/02/断点调试-APT-和-Gradle-Plugin/toolbar_debug_attach.jpg","hash":"f782af722939deb54a2a11343d99a5077e65fb24","modified":1579160077269},{"_id":"public/2019/12/02/断点调试-APT-和-Gradle-Plugin/toolbar_edit_configurations.jpg","hash":"b048f6fc2dc15c8741c3e98a9507015ca4ad4f97","modified":1579160077269},{"_id":"public/2019/09/19/性能优化之卡顿优化/vsync_signal.png","hash":"905af8c75457185198010c19a4b1d40143819f0a","modified":1579160077269},{"_id":"public/images/alipay.jpg","hash":"29e6741ab301747e00b881a0eb6d86fd93b46111","modified":1579160077816},{"_id":"public/images/wechatpay.jpg","hash":"6817b75d2fcd81e8553df9854cba10e5cf068031","modified":1579160077818},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1579160077825},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1579160077826},{"_id":"public/2019/12/03/Mac-Terminal-终端代理配置/shadowsocks_preferences.jpg","hash":"42e8d42443229fcb77f06f11c986440735526b85","modified":1579160077826},{"_id":"public/2020/01/14/Replugin-源码分析1-源码导入阅读/replugin_host_demo.jpg","hash":"4ada2142ad98354fa40dbc314803c6967a40f099","modified":1579160077826},{"_id":"public/2020/01/14/Replugin-源码分析1-源码导入阅读/replugin_source_reading.jpg","hash":"6ee31395a4f0559ce5bd9ffb5840be164bebda35","modified":1579160077826},{"_id":"public/2019/10/14/性能优化之Matrix/matrix_tracecanary_arch.jpg","hash":"6c82d19d790b37d8e4fde9b91a1b0a9578da5171","modified":1579160077826},{"_id":"public/2019/12/02/断点调试-APT-和-Gradle-Plugin/as_settings_remote.jpg","hash":"b5afd835ef812ecbe97c1981076e1c39b443a74e","modified":1579160077826},{"_id":"public/2019/12/02/断点调试-APT-和-Gradle-Plugin/gradle_execute_remote_code.jpg","hash":"9d86a77ca7011e6eb2544850ebba0e69a4c0099b","modified":1579160077826},{"_id":"public/2019/09/19/性能优化之卡顿优化/cpu_and_gpu.png","hash":"c973e29b43341ae31e19136a4ba2c50183a8ee87","modified":1579160077826},{"_id":"public/2019/09/19/性能优化之卡顿优化/display_jank.png","hash":"38e8c7ae1105505bcf872a34a02a15269b02c529","modified":1579160077826},{"_id":"public/2019/09/19/性能优化之卡顿优化/display_renderthread.png","hash":"7ac01ff08f8ebdb7964b5c0ffca2b32172418530","modified":1579160077827},{"_id":"public/2019/09/19/性能优化之卡顿优化/optimize_recyclerview.png","hash":"23e1087cbe400ca9f5ee0d87887987bff37e5553","modified":1579160077827},{"_id":"public/2019/09/19/性能优化之卡顿优化/pc_cpu_info.jpg","hash":"24c76a8f955bf556be1ad4f940e3532128a52bfb","modified":1579160077827},{"_id":"public/2019/09/19/性能优化之卡顿优化/soft_draw_android3.0.png","hash":"5de87456ece1a43cc3c330c39c8702cba78b69df","modified":1579160077827},{"_id":"public/2019/09/19/性能优化之卡顿优化/soft_draw_android4.0.png","hash":"7ac01ff08f8ebdb7964b5c0ffca2b32172418530","modified":1579160077827},{"_id":"public/2019/09/19/性能优化之卡顿优化/view_displaylist.png","hash":"5d39f76ac3a72379741425db9e2c9fac2958454c","modified":1579160077827},{"_id":"public/2019/09/19/性能优化之卡顿优化/view_reuse.png","hash":"2ab960ce95a5ec524748b36113f2278191b2e68b","modified":1579160077827},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1579160077841},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1579160077841},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1579160077841},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1579160077841},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1579160077841},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1579160077841},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1579160077841},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1579160077841},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1579160077841},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1579160077842},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1579160077842},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1579160077842},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1579160077842},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1579160077842},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1579160077842},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1579160077843},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1579160077843},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1579160077843},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1579160077843},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1579160077843},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1579160077843},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1579160077843},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1579160077843},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1579160077843},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1579160077843},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1579160077843},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1579160077843},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1579160077843},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1579160077844},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1579160077844},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1579160077844},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1579160077844},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1579160077844},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1579160077844},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1579160077844},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1579160077844},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1579160077844},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1579160077844},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1579160077844},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1579160077844},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1579160077845},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1579160077845},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1579160077845},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1579160077845},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1579160077845},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1579160077845},{"_id":"public/lib/fastclick/README.html","hash":"287b2e24cae1f7d01877dda79b76c24f81123895","modified":1579160077845},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1579160077845},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bfb6e229fc36e493d45499b4ac30a7c298786ab4","modified":1579160077845},{"_id":"public/css/main.css","hash":"92ed07f56918bce64dfa79e4f1e5791912e1f7fd","modified":1579160077845},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1579160077845},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1579160077846},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1579160077846},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1579160077846},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1579160077849},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1579160077851},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1579160077851},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1579160077851},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1579160077851},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1579160077851},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1579160077851},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1579160077851},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1579160077851},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1579160077851},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1579160077851},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1579160077851},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1579160077851},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1579160077851},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1579160077852},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1579160077852},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1579160077852},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1579160077852},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1579160077853},{"_id":"public/2019/10/14/性能优化之Matrix/matrix_compile_flow.jpg","hash":"2bd59fefa638a4f2e81e8b9281cf1ded54dcd5c3","modified":1579160077853},{"_id":"public/2019/09/19/性能优化之卡顿优化/triple_buffering.png","hash":"885dea4c5ac5a2f566d64dc1316490cca3688f1c","modified":1579160077853},{"_id":"public/2019/09/19/性能优化之卡顿优化/android_graphic_system_arch.png","hash":"26992ea7fc3db5ff3d03a4ac4b877242d626304d","modified":1579160077868},{"_id":"public/2019/09/19/性能优化之卡顿优化/screen_adaptation_table.png","hash":"73959ea4c7e60ebe3f0fe20d5530d6251fb4d7fa","modified":1579160077868},{"_id":"public/2019/09/19/性能优化之卡顿优化/android_thread_model.png","hash":"13847ea8b464cb100b65a7b4200ed10d6169cf00","modified":1579160077868},{"_id":"public/2019/09/19/性能优化之卡顿优化/systrace_demo_code.jpg","hash":"4f62530bc93f4f729f922bd7b11970f19973c564","modified":1579160077869},{"_id":"public/2019/09/19/性能优化之卡顿优化/xrk_process_cpu.jpg","hash":"19b7a134d63ea66eb117116ccf4b1defa82c77e6","modified":1579160077869},{"_id":"public/2019/09/19/性能优化之卡顿优化/ui_display_flow.png","hash":"eb9e58ff13f95bf1fa26722abf4fa454d3773353","modified":1579160077874},{"_id":"public/2019/12/03/Mac-Terminal-终端代理配置/terminal_ping.jpg","hash":"d8afa344e34a9c948f467260319bbbd568575001","modified":1579160077874},{"_id":"public/2019/09/19/性能优化之卡顿优化/async_create_view.png","hash":"ec8bf7f6e8d30083bf27bdd16a5a8610e45b3f1f","modified":1579160077874},{"_id":"public/2019/09/19/性能优化之卡顿优化/xrk_homepage.png","hash":"deb92c78cb48e136a34094f9ef0c00455ac1dd6c","modified":1579160077874},{"_id":"public/2019/09/19/性能优化之卡顿优化/layout_flat.png","hash":"5af128b76f15e4d7d54255d71f5cc45892c386fc","modified":1579160077875},{"_id":"public/2019/09/19/性能优化之卡顿优化/flutter_render_engine.png","hash":"a4628f2dcec8859a831f389a9a2b3bdc360e82d0","modified":1579160077875},{"_id":"public/2019/09/19/性能优化之卡顿优化/litho_thread_model.png","hash":"8e66bca7244f229f9022c4ef1e7adfd57e88af74","modified":1579160077890},{"_id":"public/2019/09/19/性能优化之卡顿优化/ddms_traceview_setting.jpg","hash":"b4fea0ef42f53e2c3736d32dc927452ee194321c","modified":1579160077890},{"_id":"public/2019/09/19/性能优化之卡顿优化/as_profiler.jpg","hash":"be2e6a691c08ce2e6ba5af6c9b1cdc93fc43bc5f","modified":1579160078002},{"_id":"public/2019/10/14/性能优化之Matrix/xrk_matrix_fps_result.png","hash":"f07eae087c9172af021c8112535fa621379a450a","modified":1579160078031},{"_id":"public/2019/09/19/性能优化之卡顿优化/pc_cpu_usage.jpg","hash":"d713d49e07bcc1f31604a012414f0d8462f925c4","modified":1579160078031},{"_id":"public/2019/09/19/性能优化之卡顿优化/systrace_result.jpg","hash":"797e44a262bd5db5e4d7903f44080f77ca46c916","modified":1579160078033},{"_id":"public/2019/10/14/性能优化之Matrix/xrk_matrix_analyse_result.png","hash":"82bf5f2537553e20eaa8439837a01392419b643e","modified":1579160078161},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1579160078161},{"_id":"public/2019/10/14/性能优化之Matrix/matrix_methodmapping.jpg","hash":"f33e51f92efc2a4daf4c771a12b6a3798d5215ef","modified":1579160078227},{"_id":"public/2019/12/02/断点调试-APT-和-Gradle-Plugin/debug_coding_sense.jpg","hash":"fa75e9bd54742b2c99a083e7e55de7ee35b8f3ff","modified":1579160078231},{"_id":"public/2019/09/19/性能优化之卡顿优化/overdraw_tools.png","hash":"fc43431e55c2688c562675cbb77a4efd56aa0fe2","modified":1579160078231},{"_id":"public/2019/09/19/性能优化之卡顿优化/ddms_traceview_result.jpg","hash":"a8fb44713a5e432b162da7485f18c26c4584b740","modified":1579160078246}],"Category":[{"name":"Android Studio","_id":"ck5gf4veg0004n2cbrecfbsj6"},{"name":"Android","_id":"ck5gf4vev000fn2cbqaru8h1i"},{"name":"Github","_id":"ck5gf4vfa001bn2cbqicq4t4l"},{"name":"Java","_id":"ck5gf4vfn001wn2cb4rpkebjj"},{"name":"Mac","_id":"ck5gf4vfu0025n2cbuhctysgo"},{"name":"工具","_id":"ck5gf4vfz002dn2cbibqjqhof"},{"name":"Vim","_id":"ck5gf4vg0002in2cb4sutv3o6"},{"name":"技术规范","_id":"ck5gf4vg2002nn2cbkic7ef8d"},{"name":"Hexo","_id":"ck5gf4vg3002rn2cbk5d7x4h4"},{"name":"Life","_id":"ck5gf4vg4002vn2cbpny7r9ry"},{"name":"性能优化","parent":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vg6002zn2cbtuloqe53"},{"name":"调试","parent":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vga003bn2cbvan07c8e"},{"name":"翻墙","_id":"ck5gf4vgc003hn2cbetu9snkr"}],"Data":[],"Page":[{"title":"About Me","date":"2017-02-22T15:54:34.000Z","_content":"\n## 关于我\nI'm Nelson，一名典型的 90后程序猿\n现就职于二手车公司，负责 App 端开发\n\n骨灰级 Google 热爱粉，Android 开发，喜欢倒腾电子产品\n曾入坑过 J2EE、C、C++、Python、逆向安全...\n现主攻 Android 和逆向开发，业余 Python\n\n## 关于博客\n2014 年之前在网易博客和 CSDN 写过博客，现在基于[Hexo Next主题](https://github.com/iissnan/hexo-theme-next)搭建了自己的博客，用 Markdown 书写，七牛云做资源存储，Google drawing、processOn 作图等。\n内容包括如下：\n* Android 开发中的核心技术\n* 其他提升开发效率的工具和框架\n* 软件架构设计\n\n## 未来想法\n> Less is more.\n\n热爱生活，热爱技术。\n追求高质量代码，分享实用高效技能。\n简简单单！\n\n## 联系我\n\ngithub: [Nelson](https://github.com/jolly336)\nemail: haoxunwang525@gmail.com\nWeChat: alias-莫高窟同学\n\n","source":"about/index.md","raw":"---\ntitle: About Me\ndate: 2017-02-22 23:54:34\n---\n\n## 关于我\nI'm Nelson，一名典型的 90后程序猿\n现就职于二手车公司，负责 App 端开发\n\n骨灰级 Google 热爱粉，Android 开发，喜欢倒腾电子产品\n曾入坑过 J2EE、C、C++、Python、逆向安全...\n现主攻 Android 和逆向开发，业余 Python\n\n## 关于博客\n2014 年之前在网易博客和 CSDN 写过博客，现在基于[Hexo Next主题](https://github.com/iissnan/hexo-theme-next)搭建了自己的博客，用 Markdown 书写，七牛云做资源存储，Google drawing、processOn 作图等。\n内容包括如下：\n* Android 开发中的核心技术\n* 其他提升开发效率的工具和框架\n* 软件架构设计\n\n## 未来想法\n> Less is more.\n\n热爱生活，热爱技术。\n追求高质量代码，分享实用高效技能。\n简简单单！\n\n## 联系我\n\ngithub: [Nelson](https://github.com/jolly336)\nemail: haoxunwang525@gmail.com\nWeChat: alias-莫高窟同学\n\n","updated":"2020-01-16T02:10:47.730Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck5gf4vea0001n2cbkfjc3sll","content":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>I’m Nelson，一名典型的 90后程序猿<br>现就职于二手车公司，负责 App 端开发</p>\n<p>骨灰级 Google 热爱粉，Android 开发，喜欢倒腾电子产品<br>曾入坑过 J2EE、C、C++、Python、逆向安全…<br>现主攻 Android 和逆向开发，业余 Python</p>\n<h2 id=\"关于博客\"><a href=\"#关于博客\" class=\"headerlink\" title=\"关于博客\"></a>关于博客</h2><p>2014 年之前在网易博客和 CSDN 写过博客，现在基于<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">Hexo Next主题</a>搭建了自己的博客，用 Markdown 书写，七牛云做资源存储，Google drawing、processOn 作图等。<br>内容包括如下：</p>\n<ul>\n<li>Android 开发中的核心技术</li>\n<li>其他提升开发效率的工具和框架</li>\n<li>软件架构设计</li>\n</ul>\n<h2 id=\"未来想法\"><a href=\"#未来想法\" class=\"headerlink\" title=\"未来想法\"></a>未来想法</h2><blockquote>\n<p>Less is more.</p>\n</blockquote>\n<p>热爱生活，热爱技术。<br>追求高质量代码，分享实用高效技能。<br>简简单单！</p>\n<h2 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h2><p>github: <a href=\"https://github.com/jolly336\" target=\"_blank\" rel=\"noopener\">Nelson</a><br>email: <a href=\"mailto:haoxunwang525@gmail.com\" target=\"_blank\" rel=\"noopener\">haoxunwang525@gmail.com</a><br>WeChat: alias-莫高窟同学</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>I’m Nelson，一名典型的 90后程序猿<br>现就职于二手车公司，负责 App 端开发</p>\n<p>骨灰级 Google 热爱粉，Android 开发，喜欢倒腾电子产品<br>曾入坑过 J2EE、C、C++、Python、逆向安全…<br>现主攻 Android 和逆向开发，业余 Python</p>\n<h2 id=\"关于博客\"><a href=\"#关于博客\" class=\"headerlink\" title=\"关于博客\"></a>关于博客</h2><p>2014 年之前在网易博客和 CSDN 写过博客，现在基于<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">Hexo Next主题</a>搭建了自己的博客，用 Markdown 书写，七牛云做资源存储，Google drawing、processOn 作图等。<br>内容包括如下：</p>\n<ul>\n<li>Android 开发中的核心技术</li>\n<li>其他提升开发效率的工具和框架</li>\n<li>软件架构设计</li>\n</ul>\n<h2 id=\"未来想法\"><a href=\"#未来想法\" class=\"headerlink\" title=\"未来想法\"></a>未来想法</h2><blockquote>\n<p>Less is more.</p>\n</blockquote>\n<p>热爱生活，热爱技术。<br>追求高质量代码，分享实用高效技能。<br>简简单单！</p>\n<h2 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h2><p>github: <a href=\"https://github.com/jolly336\" target=\"_blank\" rel=\"noopener\">Nelson</a><br>email: <a href=\"mailto:haoxunwang525@gmail.com\" target=\"_blank\" rel=\"noopener\">haoxunwang525@gmail.com</a><br>WeChat: alias-莫高窟同学</p>\n"},{"title":"categories","date":"2017-02-22T15:54:23.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-02-22 23:54:23\ntype: \"categories\"\n---\n","updated":"2020-01-14T03:35:49.620Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck5gf4ved0003n2cbn51hrpeu","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-02-22T15:53:26.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-02-22 23:53:26\ntype: \"tags\"\n---\n","updated":"2020-01-14T03:35:49.620Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck5gf4vej0007n2cbj4bdpxl9","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Android Studio那些错误的问题们","date":"2018-03-20T14:10:16.000Z","_content":"\n本片博客会记录关于Android开发工具Android Studio出错的那些问题，包括导入项目编译失败、时间过长，莫名其妙的歇菜等等。。。\n\n<img src=\"http://opkjcw4sd.bkt.clouddn.com/AndroidStudioTool.jpg\" width=\"60%\" height=\"30%\">\n\n<!-- more -->\n\n## 问题\n1. 3facets cannot be loaded.You can mark them as ignored to suppress this error notification.\n![as_error_1](http://opkjcw4sd.bkt.clouddn.com/as_error_1.png)\n**解决：**\n![as_error_1_a](http://opkjcw4sd.bkt.clouddn.com/as_error_1_a.png)\n[Stack Overflow参考链接](https://stackoverflow.com/questions/20560746/in-android-studio-cannot-load-2-facets-unknown-facet-typeandroid-and-android-gr)\n\n2. Unable to access Android SDK add-on list\n![as_error_2](http://opkjcw4sd.bkt.clouddn.com/as_error_2.png)\n**解决：**\n![as_error_2_a](http://opkjcw4sd.bkt.clouddn.com/as_error_2_a.png)\n[Stack Overflow参考链接](http://discussions.youdaxue.com/t/androidstudio-unable-to-access-android-sdk-add-on-list/14417)\n> mac: application->Android Studio->Contents->bin->idea.properties\n\n3. Error:Please select Android SDK\n![as_error_3](http://opkjcw4sd.bkt.clouddn.com/as_error_3.png)\n**解决：**\n![as_error_3_a](http://opkjcw4sd.bkt.clouddn.com/as_error_3_a.png)\n[Stack Overflow参考链接](https://stackoverflow.com/questions/34353220/android-studio-please-select-android-sdk)\n> 这个问题很莫名其妙，明明project是有SDK的本地路径的，但是一直运行不了，最后在build.gradle文件里随便敲了一个空格或换行，在sync(同步)下工程就可以了。\n\n## 总结\n一直以来Android是大家公认的最糟糕的开发环境，不但体现在它繁多的API上，还有支持的IDE，比如之前的eclipse，到现在的Android Studio(基于IntelliJ IDEA)，时长会出现一些开发者抓耳挠腮的问题，所以遇到问题我们可以记录和总结一些常见的错误，方便以后快速处理，节约开发时间，不要想着就卸载，重启电脑，虽然有时候很有效，哈哈~相比别的工具，它们都有着非常丰富的第三方插件，很方便我们集成开发测试，确实方便不少，例如编译打包的构建工具Ant、Maven、Gradle（官方支持），有着方便的接口提供开发者配置使用，这点必须给个大大的赞！\n\n\n\n","source":"_posts/Android-Studio那些错误的问题们.md","raw":"---\ntitle: Android Studio那些错误的问题们\ndate: 2018-03-20 22:10:16\ntags: Android Studio\ncategories: Android Studio\n---\n\n本片博客会记录关于Android开发工具Android Studio出错的那些问题，包括导入项目编译失败、时间过长，莫名其妙的歇菜等等。。。\n\n<img src=\"http://opkjcw4sd.bkt.clouddn.com/AndroidStudioTool.jpg\" width=\"60%\" height=\"30%\">\n\n<!-- more -->\n\n## 问题\n1. 3facets cannot be loaded.You can mark them as ignored to suppress this error notification.\n![as_error_1](http://opkjcw4sd.bkt.clouddn.com/as_error_1.png)\n**解决：**\n![as_error_1_a](http://opkjcw4sd.bkt.clouddn.com/as_error_1_a.png)\n[Stack Overflow参考链接](https://stackoverflow.com/questions/20560746/in-android-studio-cannot-load-2-facets-unknown-facet-typeandroid-and-android-gr)\n\n2. Unable to access Android SDK add-on list\n![as_error_2](http://opkjcw4sd.bkt.clouddn.com/as_error_2.png)\n**解决：**\n![as_error_2_a](http://opkjcw4sd.bkt.clouddn.com/as_error_2_a.png)\n[Stack Overflow参考链接](http://discussions.youdaxue.com/t/androidstudio-unable-to-access-android-sdk-add-on-list/14417)\n> mac: application->Android Studio->Contents->bin->idea.properties\n\n3. Error:Please select Android SDK\n![as_error_3](http://opkjcw4sd.bkt.clouddn.com/as_error_3.png)\n**解决：**\n![as_error_3_a](http://opkjcw4sd.bkt.clouddn.com/as_error_3_a.png)\n[Stack Overflow参考链接](https://stackoverflow.com/questions/34353220/android-studio-please-select-android-sdk)\n> 这个问题很莫名其妙，明明project是有SDK的本地路径的，但是一直运行不了，最后在build.gradle文件里随便敲了一个空格或换行，在sync(同步)下工程就可以了。\n\n## 总结\n一直以来Android是大家公认的最糟糕的开发环境，不但体现在它繁多的API上，还有支持的IDE，比如之前的eclipse，到现在的Android Studio(基于IntelliJ IDEA)，时长会出现一些开发者抓耳挠腮的问题，所以遇到问题我们可以记录和总结一些常见的错误，方便以后快速处理，节约开发时间，不要想着就卸载，重启电脑，虽然有时候很有效，哈哈~相比别的工具，它们都有着非常丰富的第三方插件，很方便我们集成开发测试，确实方便不少，例如编译打包的构建工具Ant、Maven、Gradle（官方支持），有着方便的接口提供开发者配置使用，这点必须给个大大的赞！\n\n\n\n","slug":"Android-Studio那些错误的问题们","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4ve40000n2cbojuhj192","content":"<p>本片博客会记录关于Android开发工具Android Studio出错的那些问题，包括导入项目编译失败、时间过长，莫名其妙的歇菜等等。。。</p>\n<p><img src=\"http://opkjcw4sd.bkt.clouddn.com/AndroidStudioTool.jpg\" width=\"60%\" height=\"30%\"></p>\n<a id=\"more\"></a>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li><p>3facets cannot be loaded.You can mark them as ignored to suppress this error notification.<br><img src=\"http://opkjcw4sd.bkt.clouddn.com/as_error_1.png\" alt=\"as_error_1\"><br><strong>解决：</strong><br><img src=\"http://opkjcw4sd.bkt.clouddn.com/as_error_1_a.png\" alt=\"as_error_1_a\"><br><a href=\"https://stackoverflow.com/questions/20560746/in-android-studio-cannot-load-2-facets-unknown-facet-typeandroid-and-android-gr\" target=\"_blank\" rel=\"noopener\">Stack Overflow参考链接</a></p>\n</li>\n<li><p>Unable to access Android SDK add-on list<br><img src=\"http://opkjcw4sd.bkt.clouddn.com/as_error_2.png\" alt=\"as_error_2\"><br><strong>解决：</strong><br><img src=\"http://opkjcw4sd.bkt.clouddn.com/as_error_2_a.png\" alt=\"as_error_2_a\"><br><a href=\"http://discussions.youdaxue.com/t/androidstudio-unable-to-access-android-sdk-add-on-list/14417\" target=\"_blank\" rel=\"noopener\">Stack Overflow参考链接</a></p>\n<blockquote>\n<p>mac: application-&gt;Android Studio-&gt;Contents-&gt;bin-&gt;idea.properties</p>\n</blockquote>\n</li>\n<li><p>Error:Please select Android SDK<br><img src=\"http://opkjcw4sd.bkt.clouddn.com/as_error_3.png\" alt=\"as_error_3\"><br><strong>解决：</strong><br><img src=\"http://opkjcw4sd.bkt.clouddn.com/as_error_3_a.png\" alt=\"as_error_3_a\"><br><a href=\"https://stackoverflow.com/questions/34353220/android-studio-please-select-android-sdk\" target=\"_blank\" rel=\"noopener\">Stack Overflow参考链接</a></p>\n<blockquote>\n<p>这个问题很莫名其妙，明明project是有SDK的本地路径的，但是一直运行不了，最后在build.gradle文件里随便敲了一个空格或换行，在sync(同步)下工程就可以了。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一直以来Android是大家公认的最糟糕的开发环境，不但体现在它繁多的API上，还有支持的IDE，比如之前的eclipse，到现在的Android Studio(基于IntelliJ IDEA)，时长会出现一些开发者抓耳挠腮的问题，所以遇到问题我们可以记录和总结一些常见的错误，方便以后快速处理，节约开发时间，不要想着就卸载，重启电脑，虽然有时候很有效，哈哈~相比别的工具，它们都有着非常丰富的第三方插件，很方便我们集成开发测试，确实方便不少，例如编译打包的构建工具Ant、Maven、Gradle（官方支持），有着方便的接口提供开发者配置使用，这点必须给个大大的赞！</p>\n","site":{"data":{}},"excerpt":"<p>本片博客会记录关于Android开发工具Android Studio出错的那些问题，包括导入项目编译失败、时间过长，莫名其妙的歇菜等等。。。</p>\n<p><img src=\"http://opkjcw4sd.bkt.clouddn.com/AndroidStudioTool.jpg\" width=\"60%\" height=\"30%\"></p>","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li><p>3facets cannot be loaded.You can mark them as ignored to suppress this error notification.<br><img src=\"http://opkjcw4sd.bkt.clouddn.com/as_error_1.png\" alt=\"as_error_1\"><br><strong>解决：</strong><br><img src=\"http://opkjcw4sd.bkt.clouddn.com/as_error_1_a.png\" alt=\"as_error_1_a\"><br><a href=\"https://stackoverflow.com/questions/20560746/in-android-studio-cannot-load-2-facets-unknown-facet-typeandroid-and-android-gr\" target=\"_blank\" rel=\"noopener\">Stack Overflow参考链接</a></p>\n</li>\n<li><p>Unable to access Android SDK add-on list<br><img src=\"http://opkjcw4sd.bkt.clouddn.com/as_error_2.png\" alt=\"as_error_2\"><br><strong>解决：</strong><br><img src=\"http://opkjcw4sd.bkt.clouddn.com/as_error_2_a.png\" alt=\"as_error_2_a\"><br><a href=\"http://discussions.youdaxue.com/t/androidstudio-unable-to-access-android-sdk-add-on-list/14417\" target=\"_blank\" rel=\"noopener\">Stack Overflow参考链接</a></p>\n<blockquote>\n<p>mac: application-&gt;Android Studio-&gt;Contents-&gt;bin-&gt;idea.properties</p>\n</blockquote>\n</li>\n<li><p>Error:Please select Android SDK<br><img src=\"http://opkjcw4sd.bkt.clouddn.com/as_error_3.png\" alt=\"as_error_3\"><br><strong>解决：</strong><br><img src=\"http://opkjcw4sd.bkt.clouddn.com/as_error_3_a.png\" alt=\"as_error_3_a\"><br><a href=\"https://stackoverflow.com/questions/34353220/android-studio-please-select-android-sdk\" target=\"_blank\" rel=\"noopener\">Stack Overflow参考链接</a></p>\n<blockquote>\n<p>这个问题很莫名其妙，明明project是有SDK的本地路径的，但是一直运行不了，最后在build.gradle文件里随便敲了一个空格或换行，在sync(同步)下工程就可以了。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一直以来Android是大家公认的最糟糕的开发环境，不但体现在它繁多的API上，还有支持的IDE，比如之前的eclipse，到现在的Android Studio(基于IntelliJ IDEA)，时长会出现一些开发者抓耳挠腮的问题，所以遇到问题我们可以记录和总结一些常见的错误，方便以后快速处理，节约开发时间，不要想着就卸载，重启电脑，虽然有时候很有效，哈哈~相比别的工具，它们都有着非常丰富的第三方插件，很方便我们集成开发测试，确实方便不少，例如编译打包的构建工具Ant、Maven、Gradle（官方支持），有着方便的接口提供开发者配置使用，这点必须给个大大的赞！</p>"},{"title":"Android Studio创建和导入新项目时，卡在等待进度条..","date":"2018-03-24T06:38:08.000Z","_content":"\n本文将讲解使用Android Studio新建或导入外部基于gradle构建的Android项目时，卡在进度条的问题。\n\n<img src=\"http://wanghaoxun.com/androidstudio_loading.png\" width=\"60%\" height=\"30%\">\n\n<!-- more -->\n\n当我们使用AS工具新建或者导入外部基于gradle构建的安卓项目时，会一直卡在进度条那里，因为没有详细的log信息，不知道as在干了些神马。其实，as工具是在检测和下载项目要使用的对应gradle版本，一般要下载大于100M左右的zip文件，如果没有翻墙，那将很浪费我们时间。所以我们可以手动去下载对应gradle工具包，来跳过此次漫长的等待，毕竟我们的时间很有限的。\n\n##  一、结束正在等待的AS进程\n\n* Mac打开monitor活动管理器，找到Android studio，强制退出即可\n* window打开资源管理器，关闭AS进程\n\n## 二、查看项目要使用gradle工具的版本号\n\n找到我们的项目，进入`gradle->wrapper`目录，找到`gradle-wrapper.properties`，打开查看最后一行distrubutionUrl代表的版本号，例如`distributionUrl=https\\://services.gradle.org/distributions/gradle-3.3-all.zip`，就说明是gradle-3.3-all.zip\n\n## 三、去gradle官网下载刚才查看的gradle版本包\n\n[gradle工具包下载地址](https://services.gradle.org/distributions/)\n下载刚才gradle3.3的包，如图\n\n![gradle3.3](http://wanghaoxun.com/gradle3.3%E4%B8%8B%E8%BD%BD.png)\n\n## 四、替换gradle\n\n* 进入` ~/.gradle/wrapper/dists/gradle-3.3-all`目录，看到一个很长随机名字的目录像ac27o8rbd0ic8ih41or9l32mv，里面有两个文件`gradle-4.0-all.zip.lck`和`gradle-4.0-all.zip.part`\n* 修改`gradle-4.0-all.zip.part`文件后缀名为`gradle-4.0-all.zip.ok`，来欺骗Android studio已经下载好了\n* 把刚才下载的gradle-3.3-all.zip包解压到这个目录里，保留压缩包文件\n\n![gradle directory](http://omdtn071e.bkt.clouddn.com/gradle3.3%E7%9B%AE%E5%BD%95.png)\n\n## 五、重新导入项目\n\n最后重新导入项目，就可以跳过进度条，很快编译起来\n\n## 总结\n> 原理\n\nAS工具创建项目时，回去检查~/.gradle/wrapper/dists/gradle-x.x-all目录是否有临时文件夹，如果没有，就会去gradle官网下载gradle-x.x-all.zip到临时文件夹。所以上面的步骤就是跳过此次检查和下载。\n\n\n\n\n\n","source":"_posts/Android-Studio创建和导入新项目时，卡在等待进度条.md","raw":"---\ntitle: Android Studio创建和导入新项目时，卡在等待进度条..\ndate: 2018-03-24 14:38:08\ntags: Android Studio\ncategories: Android Studio\n---\n\n本文将讲解使用Android Studio新建或导入外部基于gradle构建的Android项目时，卡在进度条的问题。\n\n<img src=\"http://wanghaoxun.com/androidstudio_loading.png\" width=\"60%\" height=\"30%\">\n\n<!-- more -->\n\n当我们使用AS工具新建或者导入外部基于gradle构建的安卓项目时，会一直卡在进度条那里，因为没有详细的log信息，不知道as在干了些神马。其实，as工具是在检测和下载项目要使用的对应gradle版本，一般要下载大于100M左右的zip文件，如果没有翻墙，那将很浪费我们时间。所以我们可以手动去下载对应gradle工具包，来跳过此次漫长的等待，毕竟我们的时间很有限的。\n\n##  一、结束正在等待的AS进程\n\n* Mac打开monitor活动管理器，找到Android studio，强制退出即可\n* window打开资源管理器，关闭AS进程\n\n## 二、查看项目要使用gradle工具的版本号\n\n找到我们的项目，进入`gradle->wrapper`目录，找到`gradle-wrapper.properties`，打开查看最后一行distrubutionUrl代表的版本号，例如`distributionUrl=https\\://services.gradle.org/distributions/gradle-3.3-all.zip`，就说明是gradle-3.3-all.zip\n\n## 三、去gradle官网下载刚才查看的gradle版本包\n\n[gradle工具包下载地址](https://services.gradle.org/distributions/)\n下载刚才gradle3.3的包，如图\n\n![gradle3.3](http://wanghaoxun.com/gradle3.3%E4%B8%8B%E8%BD%BD.png)\n\n## 四、替换gradle\n\n* 进入` ~/.gradle/wrapper/dists/gradle-3.3-all`目录，看到一个很长随机名字的目录像ac27o8rbd0ic8ih41or9l32mv，里面有两个文件`gradle-4.0-all.zip.lck`和`gradle-4.0-all.zip.part`\n* 修改`gradle-4.0-all.zip.part`文件后缀名为`gradle-4.0-all.zip.ok`，来欺骗Android studio已经下载好了\n* 把刚才下载的gradle-3.3-all.zip包解压到这个目录里，保留压缩包文件\n\n![gradle directory](http://omdtn071e.bkt.clouddn.com/gradle3.3%E7%9B%AE%E5%BD%95.png)\n\n## 五、重新导入项目\n\n最后重新导入项目，就可以跳过进度条，很快编译起来\n\n## 总结\n> 原理\n\nAS工具创建项目时，回去检查~/.gradle/wrapper/dists/gradle-x.x-all目录是否有临时文件夹，如果没有，就会去gradle官网下载gradle-x.x-all.zip到临时文件夹。所以上面的步骤就是跳过此次检查和下载。\n\n\n\n\n\n","slug":"Android-Studio创建和导入新项目时，卡在等待进度条","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4veb0002n2cbhten54qh","content":"<p>本文将讲解使用Android Studio新建或导入外部基于gradle构建的Android项目时，卡在进度条的问题。</p>\n<p><img src=\"http://wanghaoxun.com/androidstudio_loading.png\" width=\"60%\" height=\"30%\"></p>\n<a id=\"more\"></a>\n<p>当我们使用AS工具新建或者导入外部基于gradle构建的安卓项目时，会一直卡在进度条那里，因为没有详细的log信息，不知道as在干了些神马。其实，as工具是在检测和下载项目要使用的对应gradle版本，一般要下载大于100M左右的zip文件，如果没有翻墙，那将很浪费我们时间。所以我们可以手动去下载对应gradle工具包，来跳过此次漫长的等待，毕竟我们的时间很有限的。</p>\n<h2 id=\"一、结束正在等待的AS进程\"><a href=\"#一、结束正在等待的AS进程\" class=\"headerlink\" title=\"一、结束正在等待的AS进程\"></a>一、结束正在等待的AS进程</h2><ul>\n<li>Mac打开monitor活动管理器，找到Android studio，强制退出即可</li>\n<li>window打开资源管理器，关闭AS进程</li>\n</ul>\n<h2 id=\"二、查看项目要使用gradle工具的版本号\"><a href=\"#二、查看项目要使用gradle工具的版本号\" class=\"headerlink\" title=\"二、查看项目要使用gradle工具的版本号\"></a>二、查看项目要使用gradle工具的版本号</h2><p>找到我们的项目，进入<code>gradle-&gt;wrapper</code>目录，找到<code>gradle-wrapper.properties</code>，打开查看最后一行distrubutionUrl代表的版本号，例如<code>distributionUrl=https\\://services.gradle.org/distributions/gradle-3.3-all.zip</code>，就说明是gradle-3.3-all.zip</p>\n<h2 id=\"三、去gradle官网下载刚才查看的gradle版本包\"><a href=\"#三、去gradle官网下载刚才查看的gradle版本包\" class=\"headerlink\" title=\"三、去gradle官网下载刚才查看的gradle版本包\"></a>三、去gradle官网下载刚才查看的gradle版本包</h2><p><a href=\"https://services.gradle.org/distributions/\" target=\"_blank\" rel=\"noopener\">gradle工具包下载地址</a><br>下载刚才gradle3.3的包，如图</p>\n<p><img src=\"http://wanghaoxun.com/gradle3.3%E4%B8%8B%E8%BD%BD.png\" alt=\"gradle3.3\"></p>\n<h2 id=\"四、替换gradle\"><a href=\"#四、替换gradle\" class=\"headerlink\" title=\"四、替换gradle\"></a>四、替换gradle</h2><ul>\n<li>进入<code>~/.gradle/wrapper/dists/gradle-3.3-all</code>目录，看到一个很长随机名字的目录像ac27o8rbd0ic8ih41or9l32mv，里面有两个文件<code>gradle-4.0-all.zip.lck</code>和<code>gradle-4.0-all.zip.part</code></li>\n<li>修改<code>gradle-4.0-all.zip.part</code>文件后缀名为<code>gradle-4.0-all.zip.ok</code>，来欺骗Android studio已经下载好了</li>\n<li>把刚才下载的gradle-3.3-all.zip包解压到这个目录里，保留压缩包文件</li>\n</ul>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/gradle3.3%E7%9B%AE%E5%BD%95.png\" alt=\"gradle directory\"></p>\n<h2 id=\"五、重新导入项目\"><a href=\"#五、重新导入项目\" class=\"headerlink\" title=\"五、重新导入项目\"></a>五、重新导入项目</h2><p>最后重新导入项目，就可以跳过进度条，很快编译起来</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p>原理</p>\n</blockquote>\n<p>AS工具创建项目时，回去检查~/.gradle/wrapper/dists/gradle-x.x-all目录是否有临时文件夹，如果没有，就会去gradle官网下载gradle-x.x-all.zip到临时文件夹。所以上面的步骤就是跳过此次检查和下载。</p>\n","site":{"data":{}},"excerpt":"<p>本文将讲解使用Android Studio新建或导入外部基于gradle构建的Android项目时，卡在进度条的问题。</p>\n<p><img src=\"http://wanghaoxun.com/androidstudio_loading.png\" width=\"60%\" height=\"30%\"></p>","more":"<p>当我们使用AS工具新建或者导入外部基于gradle构建的安卓项目时，会一直卡在进度条那里，因为没有详细的log信息，不知道as在干了些神马。其实，as工具是在检测和下载项目要使用的对应gradle版本，一般要下载大于100M左右的zip文件，如果没有翻墙，那将很浪费我们时间。所以我们可以手动去下载对应gradle工具包，来跳过此次漫长的等待，毕竟我们的时间很有限的。</p>\n<h2 id=\"一、结束正在等待的AS进程\"><a href=\"#一、结束正在等待的AS进程\" class=\"headerlink\" title=\"一、结束正在等待的AS进程\"></a>一、结束正在等待的AS进程</h2><ul>\n<li>Mac打开monitor活动管理器，找到Android studio，强制退出即可</li>\n<li>window打开资源管理器，关闭AS进程</li>\n</ul>\n<h2 id=\"二、查看项目要使用gradle工具的版本号\"><a href=\"#二、查看项目要使用gradle工具的版本号\" class=\"headerlink\" title=\"二、查看项目要使用gradle工具的版本号\"></a>二、查看项目要使用gradle工具的版本号</h2><p>找到我们的项目，进入<code>gradle-&gt;wrapper</code>目录，找到<code>gradle-wrapper.properties</code>，打开查看最后一行distrubutionUrl代表的版本号，例如<code>distributionUrl=https\\://services.gradle.org/distributions/gradle-3.3-all.zip</code>，就说明是gradle-3.3-all.zip</p>\n<h2 id=\"三、去gradle官网下载刚才查看的gradle版本包\"><a href=\"#三、去gradle官网下载刚才查看的gradle版本包\" class=\"headerlink\" title=\"三、去gradle官网下载刚才查看的gradle版本包\"></a>三、去gradle官网下载刚才查看的gradle版本包</h2><p><a href=\"https://services.gradle.org/distributions/\" target=\"_blank\" rel=\"noopener\">gradle工具包下载地址</a><br>下载刚才gradle3.3的包，如图</p>\n<p><img src=\"http://wanghaoxun.com/gradle3.3%E4%B8%8B%E8%BD%BD.png\" alt=\"gradle3.3\"></p>\n<h2 id=\"四、替换gradle\"><a href=\"#四、替换gradle\" class=\"headerlink\" title=\"四、替换gradle\"></a>四、替换gradle</h2><ul>\n<li>进入<code>~/.gradle/wrapper/dists/gradle-3.3-all</code>目录，看到一个很长随机名字的目录像ac27o8rbd0ic8ih41or9l32mv，里面有两个文件<code>gradle-4.0-all.zip.lck</code>和<code>gradle-4.0-all.zip.part</code></li>\n<li>修改<code>gradle-4.0-all.zip.part</code>文件后缀名为<code>gradle-4.0-all.zip.ok</code>，来欺骗Android studio已经下载好了</li>\n<li>把刚才下载的gradle-3.3-all.zip包解压到这个目录里，保留压缩包文件</li>\n</ul>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/gradle3.3%E7%9B%AE%E5%BD%95.png\" alt=\"gradle directory\"></p>\n<h2 id=\"五、重新导入项目\"><a href=\"#五、重新导入项目\" class=\"headerlink\" title=\"五、重新导入项目\"></a>五、重新导入项目</h2><p>最后重新导入项目，就可以跳过进度条，很快编译起来</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p>原理</p>\n</blockquote>\n<p>AS工具创建项目时，回去检查~/.gradle/wrapper/dists/gradle-x.x-all目录是否有临时文件夹，如果没有，就会去gradle官网下载gradle-x.x-all.zip到临时文件夹。所以上面的步骤就是跳过此次检查和下载。</p>"},{"title":"Android native和js简单交互","date":"2017-02-28T15:04:18.000Z","_content":"\n> 使用Android自身js注解来实现native和js的交互，WebView提供了一个接口**[addJavascriptInterface(Object object, String name)](https://developer.android.google.cn/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29)**，可以让我们注入Java对象到js页面中，这样页面中的JavaScript就能直接访问Java对象函数，从而实现Java和Js的简单交互；而Android调用js时，只需loadUrl即可。\n\n<!-- more -->\n\n## 测试js代码\n\n```html\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\">\n    <script type=\"text/javascript\">\n    // java代码调用js方法\n    function javaCallJs() {\n        document.getElementById(\"content\").innerHTML +=\n         \"<br\\>java调用了js函数\";\n    }\n\n    </script>\n</head>\n<body>\nthis is my html <br/>\n//js调用java方法,所有js全局对象、函数以及变量均自动成为window对象的成员\n<a onClick=\"window.java2Js.JsCallJava()\">点击调用java代码</a><br/>\n<br/>\n<div id=\"content\">内容显示</div>\n</body>\n</html>\n```\n\n## Android本地代码\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    private WebView webView;\n\n    @SuppressLint(\"SetJavaScriptEnabled\")\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        webView = (WebView) findViewById(R.id.webView);\n        // 启用webView中的JavaScript支持\n        webView.getSettings().setJavaScriptEnabled(true);\n        // 加载assets目录下的test.html\n        webView.loadUrl(\"file:///android_asset/test.html\");\n        // 注入java对象到webView中\n        webView.addJavascriptInterface(this, \"java2Js\");\n\n        findViewById(R.id.btn_javaCallJs).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                // --native button,java call js--\n                webView.loadUrl(\"javascript:javaCallJs()\");\n            }\n        });\n\n    }\n\n    /**\n     * 注意：JELLY_BEAN_MR1 4.4后，只有public且添加了@JavascriptInterface注解的方法才能被调用。这也是为了安全考虑。\n     * 毕竟页面可以直接操作Native App，有点不安全！没加注解，导致反射失败，js会调用不起来native函数。\n     */\n    @JavascriptInterface\n    public void JsCallJava() {\n        Toast.makeText(MainActivity.this, \"js call java\", Toast.LENGTH_LONG).show();\n    }\n}\n```\n\n\n","source":"_posts/Android-native和js简单交互.md","raw":"---\ntitle: Android native和js简单交互\ndate: 2017-02-28 23:04:18\ntags: Android\ncategories: Android\n---\n\n> 使用Android自身js注解来实现native和js的交互，WebView提供了一个接口**[addJavascriptInterface(Object object, String name)](https://developer.android.google.cn/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29)**，可以让我们注入Java对象到js页面中，这样页面中的JavaScript就能直接访问Java对象函数，从而实现Java和Js的简单交互；而Android调用js时，只需loadUrl即可。\n\n<!-- more -->\n\n## 测试js代码\n\n```html\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\">\n    <script type=\"text/javascript\">\n    // java代码调用js方法\n    function javaCallJs() {\n        document.getElementById(\"content\").innerHTML +=\n         \"<br\\>java调用了js函数\";\n    }\n\n    </script>\n</head>\n<body>\nthis is my html <br/>\n//js调用java方法,所有js全局对象、函数以及变量均自动成为window对象的成员\n<a onClick=\"window.java2Js.JsCallJava()\">点击调用java代码</a><br/>\n<br/>\n<div id=\"content\">内容显示</div>\n</body>\n</html>\n```\n\n## Android本地代码\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    private WebView webView;\n\n    @SuppressLint(\"SetJavaScriptEnabled\")\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        webView = (WebView) findViewById(R.id.webView);\n        // 启用webView中的JavaScript支持\n        webView.getSettings().setJavaScriptEnabled(true);\n        // 加载assets目录下的test.html\n        webView.loadUrl(\"file:///android_asset/test.html\");\n        // 注入java对象到webView中\n        webView.addJavascriptInterface(this, \"java2Js\");\n\n        findViewById(R.id.btn_javaCallJs).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                // --native button,java call js--\n                webView.loadUrl(\"javascript:javaCallJs()\");\n            }\n        });\n\n    }\n\n    /**\n     * 注意：JELLY_BEAN_MR1 4.4后，只有public且添加了@JavascriptInterface注解的方法才能被调用。这也是为了安全考虑。\n     * 毕竟页面可以直接操作Native App，有点不安全！没加注解，导致反射失败，js会调用不起来native函数。\n     */\n    @JavascriptInterface\n    public void JsCallJava() {\n        Toast.makeText(MainActivity.this, \"js call java\", Toast.LENGTH_LONG).show();\n    }\n}\n```\n\n\n","slug":"Android-native和js简单交互","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vei0006n2cb47vyscj0","content":"<blockquote>\n<p>使用Android自身js注解来实现native和js的交互，WebView提供了一个接口<strong><a href=\"https://developer.android.google.cn/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29\" target=\"_blank\" rel=\"noopener\">addJavascriptInterface(Object object, String name)</a></strong>，可以让我们注入Java对象到js页面中，这样页面中的JavaScript就能直接访问Java对象函数，从而实现Java和Js的简单交互；而Android调用js时，只需loadUrl即可。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"测试js代码\"><a href=\"#测试js代码\" class=\"headerlink\" title=\"测试js代码\"></a>测试js代码</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html;charset=gb2312\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\">    // java代码调用js方法</span><br><span class=\"line\">    function javaCallJs() &#123;</span><br><span class=\"line\">        document.getElementById(\"content\").innerHTML +=</span><br><span class=\"line\"><span class=\"xml\">         \"<span class=\"tag\">&lt;<span class=\"name\">br\\</span>&gt;</span>java调用了js函数\";</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">this is my html <span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\">//js调用java方法,所有js全局对象、函数以及变量均自动成为window对象的成员</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">onClick</span>=<span class=\"string\">\"window.java2Js.JsCallJava()\"</span>&gt;</span>点击调用java代码<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content\"</span>&gt;</span>内容显示<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Android本地代码\"><a href=\"#Android本地代码\" class=\"headerlink\" title=\"Android本地代码\"></a>Android本地代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> WebView webView;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressLint</span>(<span class=\"string\">\"SetJavaScriptEnabled\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        webView = (WebView) findViewById(R.id.webView);</span><br><span class=\"line\">        <span class=\"comment\">// 启用webView中的JavaScript支持</span></span><br><span class=\"line\">        webView.getSettings().setJavaScriptEnabled(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 加载assets目录下的test.html</span></span><br><span class=\"line\">        webView.loadUrl(<span class=\"string\">\"file:///android_asset/test.html\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 注入java对象到webView中</span></span><br><span class=\"line\">        webView.addJavascriptInterface(<span class=\"keyword\">this</span>, <span class=\"string\">\"java2Js\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        findViewById(R.id.btn_javaCallJs).setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// --native button,java call js--</span></span><br><span class=\"line\">                webView.loadUrl(<span class=\"string\">\"javascript:javaCallJs()\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 注意：JELLY_BEAN_MR1 4.4后，只有public且添加了<span class=\"doctag\">@JavascriptInterface</span>注解的方法才能被调用。这也是为了安全考虑。</span></span><br><span class=\"line\"><span class=\"comment\">     * 毕竟页面可以直接操作Native App，有点不安全！没加注解，导致反射失败，js会调用不起来native函数。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@JavascriptInterface</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">JsCallJava</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(MainActivity.<span class=\"keyword\">this</span>, <span class=\"string\">\"js call java\"</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>使用Android自身js注解来实现native和js的交互，WebView提供了一个接口<strong><a href=\"https://developer.android.google.cn/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29\" target=\"_blank\" rel=\"noopener\">addJavascriptInterface(Object object, String name)</a></strong>，可以让我们注入Java对象到js页面中，这样页面中的JavaScript就能直接访问Java对象函数，从而实现Java和Js的简单交互；而Android调用js时，只需loadUrl即可。</p>\n</blockquote>","more":"<h2 id=\"测试js代码\"><a href=\"#测试js代码\" class=\"headerlink\" title=\"测试js代码\"></a>测试js代码</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html;charset=gb2312\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\">    // java代码调用js方法</span><br><span class=\"line\">    function javaCallJs() &#123;</span><br><span class=\"line\">        document.getElementById(\"content\").innerHTML +=</span><br><span class=\"line\"><span class=\"xml\">         \"<span class=\"tag\">&lt;<span class=\"name\">br\\</span>&gt;</span>java调用了js函数\";</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">this is my html <span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\">//js调用java方法,所有js全局对象、函数以及变量均自动成为window对象的成员</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">onClick</span>=<span class=\"string\">\"window.java2Js.JsCallJava()\"</span>&gt;</span>点击调用java代码<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content\"</span>&gt;</span>内容显示<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Android本地代码\"><a href=\"#Android本地代码\" class=\"headerlink\" title=\"Android本地代码\"></a>Android本地代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> WebView webView;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressLint</span>(<span class=\"string\">\"SetJavaScriptEnabled\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        webView = (WebView) findViewById(R.id.webView);</span><br><span class=\"line\">        <span class=\"comment\">// 启用webView中的JavaScript支持</span></span><br><span class=\"line\">        webView.getSettings().setJavaScriptEnabled(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 加载assets目录下的test.html</span></span><br><span class=\"line\">        webView.loadUrl(<span class=\"string\">\"file:///android_asset/test.html\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 注入java对象到webView中</span></span><br><span class=\"line\">        webView.addJavascriptInterface(<span class=\"keyword\">this</span>, <span class=\"string\">\"java2Js\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        findViewById(R.id.btn_javaCallJs).setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// --native button,java call js--</span></span><br><span class=\"line\">                webView.loadUrl(<span class=\"string\">\"javascript:javaCallJs()\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 注意：JELLY_BEAN_MR1 4.4后，只有public且添加了<span class=\"doctag\">@JavascriptInterface</span>注解的方法才能被调用。这也是为了安全考虑。</span></span><br><span class=\"line\"><span class=\"comment\">     * 毕竟页面可以直接操作Native App，有点不安全！没加注解，导致反射失败，js会调用不起来native函数。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@JavascriptInterface</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">JsCallJava</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(MainActivity.<span class=\"keyword\">this</span>, <span class=\"string\">\"js call java\"</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Android studio断点调试高级技巧总结","date":"2017-03-06T02:47:59.000Z","_content":"\n> 本博客来自[Android studio断点调试高级技巧总结](http://www.jianshu.com/p/984e101fd73e)一文。\n\n本文将总结几种在开发中比较重要的断点调试方法：**条件断点**、**异常断点**、**和日志断点**。\n\n<!-- more -->\n\n## 条件断点\n假设我们有一个循环体，但是我们只想调试i==10的情况，此时可以采用条件断点来完成。\n\n```java\nint j = 0;\nfor (int i = 0; i < 1000; i++) {\n    j++;\n}\n```\n如果我们想观察i==500时，程序的执行情况，可以这样操作。首先在j++所在行设置一个断点\n\n![条件断点_1](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_1.jpg)\n此时 在断点上单击右键，输入i==500\n\n![条件断点_2](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_2.jpg)\n\n设置完毕啦，启动断点调试后，你就会发现，第一次进入端点时，i==500了。\n\n![条件断点_3](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_3.jpg)\n\n## 异常断点\n\n这个功能个人感觉还是挺有用处的。先说适用场景，假设我们的App出现崩溃，但是因为一些原因log日志不好查看或者查看不到，我们知道可能是NullPointerException异常了，但是定位不到异常在哪里，此时我们可能会将自己怀疑可能出现空指针异常的地方都打上断点，这样做是非常低效的，有了异常断点功能，一步就可以搞定。\n为了说明问题，我在37行人为的引入了空指针异常。\n\n![异常断点_1](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_4.jpg)\n\n打开Run->View BreakPoints或者直接ctrl+shift+F8,打开异常设置面板。\n\n![异常断点_2](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_5.jpg)\n\n![异常断点_3](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_6.jpg)\n\n按上图操作成功的加入了空指针异常断点监控，此时直接Debug模式调试。\n\n![异常断点_4](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_7.jpg)\n\n程序直接在37行停下了，而且会打印出空指针的日志。注意37行我们并没有提前设置断点。是不是很神奇，直接定位到了bug。\n\n## 日志断点\n如果我们想要在断点调试的时候添加log日志，我们最常用的方式是直接加入一行log，重新编译，观察结果后，在去掉log，在重新编译，此时我们可以使用日志断点的功能。\n\n![日志断点_1](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_8.jpg)\n\n设置方法，首先设置普通断点，在断点上单击右键，将suspand属性设为false，在出现的对话框中勾选上Log evaluated expression，下面我们在第一个断点上想观察一下i的值，在第二个断点上打印下当前线程的名字。设置如下\n\n![日志断点_2](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_9.jpg)\n\n![日志断点_3](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_9.jpg)\n\n![日志断点_4](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_10.jpg)\n\n运行一把，看看效果：\n\n![日志断点_5](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_11.jpg)\n\nandroid的断点调试功能就介绍到这里。\n\n","source":"_posts/Android-studio断点调试高级技巧总结.md","raw":"---\ntitle: Android studio断点调试高级技巧总结\ndate: 2017-03-06 10:47:59\ntags: Android\ncategories: Android\n---\n\n> 本博客来自[Android studio断点调试高级技巧总结](http://www.jianshu.com/p/984e101fd73e)一文。\n\n本文将总结几种在开发中比较重要的断点调试方法：**条件断点**、**异常断点**、**和日志断点**。\n\n<!-- more -->\n\n## 条件断点\n假设我们有一个循环体，但是我们只想调试i==10的情况，此时可以采用条件断点来完成。\n\n```java\nint j = 0;\nfor (int i = 0; i < 1000; i++) {\n    j++;\n}\n```\n如果我们想观察i==500时，程序的执行情况，可以这样操作。首先在j++所在行设置一个断点\n\n![条件断点_1](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_1.jpg)\n此时 在断点上单击右键，输入i==500\n\n![条件断点_2](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_2.jpg)\n\n设置完毕啦，启动断点调试后，你就会发现，第一次进入端点时，i==500了。\n\n![条件断点_3](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_3.jpg)\n\n## 异常断点\n\n这个功能个人感觉还是挺有用处的。先说适用场景，假设我们的App出现崩溃，但是因为一些原因log日志不好查看或者查看不到，我们知道可能是NullPointerException异常了，但是定位不到异常在哪里，此时我们可能会将自己怀疑可能出现空指针异常的地方都打上断点，这样做是非常低效的，有了异常断点功能，一步就可以搞定。\n为了说明问题，我在37行人为的引入了空指针异常。\n\n![异常断点_1](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_4.jpg)\n\n打开Run->View BreakPoints或者直接ctrl+shift+F8,打开异常设置面板。\n\n![异常断点_2](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_5.jpg)\n\n![异常断点_3](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_6.jpg)\n\n按上图操作成功的加入了空指针异常断点监控，此时直接Debug模式调试。\n\n![异常断点_4](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_7.jpg)\n\n程序直接在37行停下了，而且会打印出空指针的日志。注意37行我们并没有提前设置断点。是不是很神奇，直接定位到了bug。\n\n## 日志断点\n如果我们想要在断点调试的时候添加log日志，我们最常用的方式是直接加入一行log，重新编译，观察结果后，在去掉log，在重新编译，此时我们可以使用日志断点的功能。\n\n![日志断点_1](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_8.jpg)\n\n设置方法，首先设置普通断点，在断点上单击右键，将suspand属性设为false，在出现的对话框中勾选上Log evaluated expression，下面我们在第一个断点上想观察一下i的值，在第二个断点上打印下当前线程的名字。设置如下\n\n![日志断点_2](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_9.jpg)\n\n![日志断点_3](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_9.jpg)\n\n![日志断点_4](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_10.jpg)\n\n运行一把，看看效果：\n\n![日志断点_5](http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_11.jpg)\n\nandroid的断点调试功能就介绍到这里。\n\n","slug":"Android-studio断点调试高级技巧总结","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vel0008n2cbyyr0ci4n","content":"<blockquote>\n<p>本博客来自<a href=\"http://www.jianshu.com/p/984e101fd73e\" target=\"_blank\" rel=\"noopener\">Android studio断点调试高级技巧总结</a>一文。</p>\n</blockquote>\n<p>本文将总结几种在开发中比较重要的断点调试方法：<strong>条件断点</strong>、<strong>异常断点</strong>、<strong>和日志断点</strong>。</p>\n<a id=\"more\"></a>\n<h2 id=\"条件断点\"><a href=\"#条件断点\" class=\"headerlink\" title=\"条件断点\"></a>条件断点</h2><p>假设我们有一个循环体，但是我们只想调试i==10的情况，此时可以采用条件断点来完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    j++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想观察i==500时，程序的执行情况，可以这样操作。首先在j++所在行设置一个断点</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_1.jpg\" alt=\"条件断点_1\"><br>此时 在断点上单击右键，输入i==500</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_2.jpg\" alt=\"条件断点_2\"></p>\n<p>设置完毕啦，启动断点调试后，你就会发现，第一次进入端点时，i==500了。</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_3.jpg\" alt=\"条件断点_3\"></p>\n<h2 id=\"异常断点\"><a href=\"#异常断点\" class=\"headerlink\" title=\"异常断点\"></a>异常断点</h2><p>这个功能个人感觉还是挺有用处的。先说适用场景，假设我们的App出现崩溃，但是因为一些原因log日志不好查看或者查看不到，我们知道可能是NullPointerException异常了，但是定位不到异常在哪里，此时我们可能会将自己怀疑可能出现空指针异常的地方都打上断点，这样做是非常低效的，有了异常断点功能，一步就可以搞定。<br>为了说明问题，我在37行人为的引入了空指针异常。</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_4.jpg\" alt=\"异常断点_1\"></p>\n<p>打开Run-&gt;View BreakPoints或者直接ctrl+shift+F8,打开异常设置面板。</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_5.jpg\" alt=\"异常断点_2\"></p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_6.jpg\" alt=\"异常断点_3\"></p>\n<p>按上图操作成功的加入了空指针异常断点监控，此时直接Debug模式调试。</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_7.jpg\" alt=\"异常断点_4\"></p>\n<p>程序直接在37行停下了，而且会打印出空指针的日志。注意37行我们并没有提前设置断点。是不是很神奇，直接定位到了bug。</p>\n<h2 id=\"日志断点\"><a href=\"#日志断点\" class=\"headerlink\" title=\"日志断点\"></a>日志断点</h2><p>如果我们想要在断点调试的时候添加log日志，我们最常用的方式是直接加入一行log，重新编译，观察结果后，在去掉log，在重新编译，此时我们可以使用日志断点的功能。</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_8.jpg\" alt=\"日志断点_1\"></p>\n<p>设置方法，首先设置普通断点，在断点上单击右键，将suspand属性设为false，在出现的对话框中勾选上Log evaluated expression，下面我们在第一个断点上想观察一下i的值，在第二个断点上打印下当前线程的名字。设置如下</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_9.jpg\" alt=\"日志断点_2\"></p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_9.jpg\" alt=\"日志断点_3\"></p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_10.jpg\" alt=\"日志断点_4\"></p>\n<p>运行一把，看看效果：</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_11.jpg\" alt=\"日志断点_5\"></p>\n<p>android的断点调试功能就介绍到这里。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本博客来自<a href=\"http://www.jianshu.com/p/984e101fd73e\" target=\"_blank\" rel=\"noopener\">Android studio断点调试高级技巧总结</a>一文。</p>\n</blockquote>\n<p>本文将总结几种在开发中比较重要的断点调试方法：<strong>条件断点</strong>、<strong>异常断点</strong>、<strong>和日志断点</strong>。</p>","more":"<h2 id=\"条件断点\"><a href=\"#条件断点\" class=\"headerlink\" title=\"条件断点\"></a>条件断点</h2><p>假设我们有一个循环体，但是我们只想调试i==10的情况，此时可以采用条件断点来完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    j++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想观察i==500时，程序的执行情况，可以这样操作。首先在j++所在行设置一个断点</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_1.jpg\" alt=\"条件断点_1\"><br>此时 在断点上单击右键，输入i==500</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_2.jpg\" alt=\"条件断点_2\"></p>\n<p>设置完毕啦，启动断点调试后，你就会发现，第一次进入端点时，i==500了。</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_3.jpg\" alt=\"条件断点_3\"></p>\n<h2 id=\"异常断点\"><a href=\"#异常断点\" class=\"headerlink\" title=\"异常断点\"></a>异常断点</h2><p>这个功能个人感觉还是挺有用处的。先说适用场景，假设我们的App出现崩溃，但是因为一些原因log日志不好查看或者查看不到，我们知道可能是NullPointerException异常了，但是定位不到异常在哪里，此时我们可能会将自己怀疑可能出现空指针异常的地方都打上断点，这样做是非常低效的，有了异常断点功能，一步就可以搞定。<br>为了说明问题，我在37行人为的引入了空指针异常。</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_4.jpg\" alt=\"异常断点_1\"></p>\n<p>打开Run-&gt;View BreakPoints或者直接ctrl+shift+F8,打开异常设置面板。</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_5.jpg\" alt=\"异常断点_2\"></p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_6.jpg\" alt=\"异常断点_3\"></p>\n<p>按上图操作成功的加入了空指针异常断点监控，此时直接Debug模式调试。</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_7.jpg\" alt=\"异常断点_4\"></p>\n<p>程序直接在37行停下了，而且会打印出空指针的日志。注意37行我们并没有提前设置断点。是不是很神奇，直接定位到了bug。</p>\n<h2 id=\"日志断点\"><a href=\"#日志断点\" class=\"headerlink\" title=\"日志断点\"></a>日志断点</h2><p>如果我们想要在断点调试的时候添加log日志，我们最常用的方式是直接加入一行log，重新编译，观察结果后，在去掉log，在重新编译，此时我们可以使用日志断点的功能。</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_8.jpg\" alt=\"日志断点_1\"></p>\n<p>设置方法，首先设置普通断点，在断点上单击右键，将suspand属性设为false，在出现的对话框中勾选上Log evaluated expression，下面我们在第一个断点上想观察一下i的值，在第二个断点上打印下当前线程的名字。设置如下</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_9.jpg\" alt=\"日志断点_2\"></p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_9.jpg\" alt=\"日志断点_3\"></p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_10.jpg\" alt=\"日志断点_4\"></p>\n<p>运行一把，看看效果：</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/2017-3-6_%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95_11.jpg\" alt=\"日志断点_5\"></p>\n<p>android的断点调试功能就介绍到这里。</p>"},{"title":"Android 在线源码阅读","date":"2019-07-06T02:19:07.000Z","_content":"\n本文讲解如何在线阅读 Android 源码，避免本地下载源码的麻烦。作为一名开发工程师，在日常开发中有必要了解自己开发中使用的某一个模块，某一个设计机制，甚至某一个 API，它的底层是如何实现的。才能做到知其然，知其所以然。还是那句话 *Read the fucking source code*。。。\n\n<!-- more -->\n\n## Android 源码在线阅读网址\n\n1. http://androidxref.com\n2. http://www.grepcode.com/\n3. [Android SDK Search 插件](https://chrome.google.com/webstore/detail/android-sdk-search/hgcbffeicehlpmgmnhnkjbjoldkfhoin?hl=zh-CN)\n\n### Android SDK Search 插件\n\nChrome 浏览器安装插件，再次搜索 Android API 时，后面会多出来 `(view source)`，点击可以查看源码，其实是链接到 Google 的 Android 源码的 Git。\n\n<img src=\"http://wanghaoxun.com/img/Android_SDK_Search.jpg\" width=\"80%\">\n<img src=\"http://wanghaoxun.com/img/Android_View_Source.jpg\" width=\"80%\"/>\n<img src=\"http://wanghaoxun.com/img/Google_Android_Source.jpg\" width=\"80%\"/>\n\n### androidxref.com\n\n首页：\n<img src=\"http://wanghaoxun.com/img/androidxref_home.jpg\" width=\"80%\">\n\n详情页：\n<img src=\"http://wanghaoxun.com/img/androidxref_detail.jpg\" width=\"80%\">\n\n* Full Search: 进行全文搜索，会匹配所有的单词、字符串、标识符以及数字等，例如在frameworks 下通过 Full Search 搜索”mediacodec“，点击”search“，会显示所有包含mediacodec字符(忽略大小写)的结果，即使是注释也会显示出来，如下图，点击对应的链接会打开包含mediacodec所在的文件夹\n* Definition：搜索符号定义相关的代码，例如搜索 ondraw 函数的定义\n* Symbol：搜索符号，例如可以搜索类中的成员变量等，下图显示了通过 Symbol 搜索FEATURE_NO_TITLE的结果\n* File Path：搜索源码文件名中包含给定字符串的文件，例如想要搜索文件名包含mediacodec的源码文件，则可以在 File Path 中填入 mediacodec 进行搜索\n* History：这个几乎没有用，用处肯定也不大\n\n> Definition 和 File path 混合搜索：start、mediacodec.cpp，例如搜索mediacodec.cpp中的start函数\n\n## Refs\n\n* [在线看Android系统源码，那些相见恨晚的几种方案](https://blog.csdn.net/hejjunlin/article/details/53454514)\n\n\n","source":"_posts/Android-在线源码阅读.md","raw":"---\ntitle: Android 在线源码阅读\ndate: 2019-07-06 10:19:07\ntags: Android\ncategories: Android\n---\n\n本文讲解如何在线阅读 Android 源码，避免本地下载源码的麻烦。作为一名开发工程师，在日常开发中有必要了解自己开发中使用的某一个模块，某一个设计机制，甚至某一个 API，它的底层是如何实现的。才能做到知其然，知其所以然。还是那句话 *Read the fucking source code*。。。\n\n<!-- more -->\n\n## Android 源码在线阅读网址\n\n1. http://androidxref.com\n2. http://www.grepcode.com/\n3. [Android SDK Search 插件](https://chrome.google.com/webstore/detail/android-sdk-search/hgcbffeicehlpmgmnhnkjbjoldkfhoin?hl=zh-CN)\n\n### Android SDK Search 插件\n\nChrome 浏览器安装插件，再次搜索 Android API 时，后面会多出来 `(view source)`，点击可以查看源码，其实是链接到 Google 的 Android 源码的 Git。\n\n<img src=\"http://wanghaoxun.com/img/Android_SDK_Search.jpg\" width=\"80%\">\n<img src=\"http://wanghaoxun.com/img/Android_View_Source.jpg\" width=\"80%\"/>\n<img src=\"http://wanghaoxun.com/img/Google_Android_Source.jpg\" width=\"80%\"/>\n\n### androidxref.com\n\n首页：\n<img src=\"http://wanghaoxun.com/img/androidxref_home.jpg\" width=\"80%\">\n\n详情页：\n<img src=\"http://wanghaoxun.com/img/androidxref_detail.jpg\" width=\"80%\">\n\n* Full Search: 进行全文搜索，会匹配所有的单词、字符串、标识符以及数字等，例如在frameworks 下通过 Full Search 搜索”mediacodec“，点击”search“，会显示所有包含mediacodec字符(忽略大小写)的结果，即使是注释也会显示出来，如下图，点击对应的链接会打开包含mediacodec所在的文件夹\n* Definition：搜索符号定义相关的代码，例如搜索 ondraw 函数的定义\n* Symbol：搜索符号，例如可以搜索类中的成员变量等，下图显示了通过 Symbol 搜索FEATURE_NO_TITLE的结果\n* File Path：搜索源码文件名中包含给定字符串的文件，例如想要搜索文件名包含mediacodec的源码文件，则可以在 File Path 中填入 mediacodec 进行搜索\n* History：这个几乎没有用，用处肯定也不大\n\n> Definition 和 File path 混合搜索：start、mediacodec.cpp，例如搜索mediacodec.cpp中的start函数\n\n## Refs\n\n* [在线看Android系统源码，那些相见恨晚的几种方案](https://blog.csdn.net/hejjunlin/article/details/53454514)\n\n\n","slug":"Android-在线源码阅读","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vep0009n2cbtewsn9fy","content":"<p>本文讲解如何在线阅读 Android 源码，避免本地下载源码的麻烦。作为一名开发工程师，在日常开发中有必要了解自己开发中使用的某一个模块，某一个设计机制，甚至某一个 API，它的底层是如何实现的。才能做到知其然，知其所以然。还是那句话 <em>Read the fucking source code</em>。。。</p>\n<a id=\"more\"></a>\n<h2 id=\"Android-源码在线阅读网址\"><a href=\"#Android-源码在线阅读网址\" class=\"headerlink\" title=\"Android 源码在线阅读网址\"></a>Android 源码在线阅读网址</h2><ol>\n<li><a href=\"http://androidxref.com\" target=\"_blank\" rel=\"noopener\">http://androidxref.com</a></li>\n<li><a href=\"http://www.grepcode.com/\" target=\"_blank\" rel=\"noopener\">http://www.grepcode.com/</a></li>\n<li><a href=\"https://chrome.google.com/webstore/detail/android-sdk-search/hgcbffeicehlpmgmnhnkjbjoldkfhoin?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">Android SDK Search 插件</a></li>\n</ol>\n<h3 id=\"Android-SDK-Search-插件\"><a href=\"#Android-SDK-Search-插件\" class=\"headerlink\" title=\"Android SDK Search 插件\"></a>Android SDK Search 插件</h3><p>Chrome 浏览器安装插件，再次搜索 Android API 时，后面会多出来 <code>(view source)</code>，点击可以查看源码，其实是链接到 Google 的 Android 源码的 Git。</p>\n<p><img src=\"http://wanghaoxun.com/img/Android_SDK_Search.jpg\" width=\"80%\"><br><img src=\"http://wanghaoxun.com/img/Android_View_Source.jpg\" width=\"80%\"><br><img src=\"http://wanghaoxun.com/img/Google_Android_Source.jpg\" width=\"80%\"></p>\n<h3 id=\"androidxref-com\"><a href=\"#androidxref-com\" class=\"headerlink\" title=\"androidxref.com\"></a>androidxref.com</h3><p>首页：<br><img src=\"http://wanghaoxun.com/img/androidxref_home.jpg\" width=\"80%\"></p>\n<p>详情页：<br><img src=\"http://wanghaoxun.com/img/androidxref_detail.jpg\" width=\"80%\"></p>\n<ul>\n<li>Full Search: 进行全文搜索，会匹配所有的单词、字符串、标识符以及数字等，例如在frameworks 下通过 Full Search 搜索”mediacodec“，点击”search“，会显示所有包含mediacodec字符(忽略大小写)的结果，即使是注释也会显示出来，如下图，点击对应的链接会打开包含mediacodec所在的文件夹</li>\n<li>Definition：搜索符号定义相关的代码，例如搜索 ondraw 函数的定义</li>\n<li>Symbol：搜索符号，例如可以搜索类中的成员变量等，下图显示了通过 Symbol 搜索FEATURE_NO_TITLE的结果</li>\n<li>File Path：搜索源码文件名中包含给定字符串的文件，例如想要搜索文件名包含mediacodec的源码文件，则可以在 File Path 中填入 mediacodec 进行搜索</li>\n<li>History：这个几乎没有用，用处肯定也不大</li>\n</ul>\n<blockquote>\n<p>Definition 和 File path 混合搜索：start、mediacodec.cpp，例如搜索mediacodec.cpp中的start函数</p>\n</blockquote>\n<h2 id=\"Refs\"><a href=\"#Refs\" class=\"headerlink\" title=\"Refs\"></a>Refs</h2><ul>\n<li><a href=\"https://blog.csdn.net/hejjunlin/article/details/53454514\" target=\"_blank\" rel=\"noopener\">在线看Android系统源码，那些相见恨晚的几种方案</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文讲解如何在线阅读 Android 源码，避免本地下载源码的麻烦。作为一名开发工程师，在日常开发中有必要了解自己开发中使用的某一个模块，某一个设计机制，甚至某一个 API，它的底层是如何实现的。才能做到知其然，知其所以然。还是那句话 <em>Read the fucking source code</em>。。。</p>","more":"<h2 id=\"Android-源码在线阅读网址\"><a href=\"#Android-源码在线阅读网址\" class=\"headerlink\" title=\"Android 源码在线阅读网址\"></a>Android 源码在线阅读网址</h2><ol>\n<li><a href=\"http://androidxref.com\" target=\"_blank\" rel=\"noopener\">http://androidxref.com</a></li>\n<li><a href=\"http://www.grepcode.com/\" target=\"_blank\" rel=\"noopener\">http://www.grepcode.com/</a></li>\n<li><a href=\"https://chrome.google.com/webstore/detail/android-sdk-search/hgcbffeicehlpmgmnhnkjbjoldkfhoin?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">Android SDK Search 插件</a></li>\n</ol>\n<h3 id=\"Android-SDK-Search-插件\"><a href=\"#Android-SDK-Search-插件\" class=\"headerlink\" title=\"Android SDK Search 插件\"></a>Android SDK Search 插件</h3><p>Chrome 浏览器安装插件，再次搜索 Android API 时，后面会多出来 <code>(view source)</code>，点击可以查看源码，其实是链接到 Google 的 Android 源码的 Git。</p>\n<p><img src=\"http://wanghaoxun.com/img/Android_SDK_Search.jpg\" width=\"80%\"><br><img src=\"http://wanghaoxun.com/img/Android_View_Source.jpg\" width=\"80%\"><br><img src=\"http://wanghaoxun.com/img/Google_Android_Source.jpg\" width=\"80%\"></p>\n<h3 id=\"androidxref-com\"><a href=\"#androidxref-com\" class=\"headerlink\" title=\"androidxref.com\"></a>androidxref.com</h3><p>首页：<br><img src=\"http://wanghaoxun.com/img/androidxref_home.jpg\" width=\"80%\"></p>\n<p>详情页：<br><img src=\"http://wanghaoxun.com/img/androidxref_detail.jpg\" width=\"80%\"></p>\n<ul>\n<li>Full Search: 进行全文搜索，会匹配所有的单词、字符串、标识符以及数字等，例如在frameworks 下通过 Full Search 搜索”mediacodec“，点击”search“，会显示所有包含mediacodec字符(忽略大小写)的结果，即使是注释也会显示出来，如下图，点击对应的链接会打开包含mediacodec所在的文件夹</li>\n<li>Definition：搜索符号定义相关的代码，例如搜索 ondraw 函数的定义</li>\n<li>Symbol：搜索符号，例如可以搜索类中的成员变量等，下图显示了通过 Symbol 搜索FEATURE_NO_TITLE的结果</li>\n<li>File Path：搜索源码文件名中包含给定字符串的文件，例如想要搜索文件名包含mediacodec的源码文件，则可以在 File Path 中填入 mediacodec 进行搜索</li>\n<li>History：这个几乎没有用，用处肯定也不大</li>\n</ul>\n<blockquote>\n<p>Definition 和 File path 混合搜索：start、mediacodec.cpp，例如搜索mediacodec.cpp中的start函数</p>\n</blockquote>\n<h2 id=\"Refs\"><a href=\"#Refs\" class=\"headerlink\" title=\"Refs\"></a>Refs</h2><ul>\n<li><a href=\"https://blog.csdn.net/hejjunlin/article/details/53454514\" target=\"_blank\" rel=\"noopener\">在线看Android系统源码，那些相见恨晚的几种方案</a></li>\n</ul>"},{"title":"Android6.0动态权限处理","date":"2017-05-07T06:21:51.000Z","_content":"\n# PermissionsHandle (Android 6.0 运行时权限处理)\n> An easy-to-use library for handling Android M runtime permissions based on the Annotation Processor.\n\n<!-- more -->\n\n## Android权限说明\n\n### 6.0以前权限一刀切\nAndroid6.0以前的系统，所有权限都是一刀切处理方式，只要用户安装了应用，Manifest清单中申请的权限都会被赋予，且安装后撤销不了。当弹出安装对话框后，用户只有两个选择，要么选择安装，默认所有的敏感权限；要么拒绝安装应用。所以，这种一刀切的处理方式，我们是没有办法只允许某些权限或者拒绝某些权限。例如，小米5手机安装应用的情景。\n\n<img src=\"http://opkjcw4sd.bkt.clouddn.com/app_install_before.png\" width=\"250px\"/>&emsp;<img src=\"http://opkjcw4sd.bkt.clouddn.com/app_installing.png\" width=\"250px%\"/>\n\n### 6.0运行时权限\n从Android 6.0M 开始，系统引入了新的运行时权限机制。以某个需要拍照的应用为例，当运行时权限生效时，其Camera权限不是在安装后赋予，而是在应用运行的时候请求权限。比如当用户按下相机拍照按钮后，看到的效果是这样子的，接下来，对于Camera权限的处理权完全交给用户。\n\n请求拍照时<img src=\"http://opkjcw4sd.bkt.clouddn.com/open_camera.png\" width=\"280px\"/>\n\n### 权限的分组\n6.0系统对权限进行了分组，一般包括如下几类：\n* 正常权限（Normal Protection）\n* 危险权限（Dangerous）\n* 特殊权限（Particular）\n* 其他权限（一般很少用到）\n\n正常权限一般不涉及用户隐私，是不需要用户进行授权的，比如访问网络，手机震动等；危险权限一般是涉及用户隐私的，需要用户进行授权，比如读取手机Sdcard,访问通讯录，打开相机等。\n\n**Normal Permissions如下**\n1. ACCESS_NETWORK_STATE\n2. VIBRATE\n3. NFC\n4. BLUETOOTH\n...\n\n**Dangerous Permissions如下**\n1. group:android.permission-group.CONTACTS\n  permission:android.permission.WRITE_CONTACTS\n  permission:android.permission.GET_ACCOUNTS\n  permission:android.permission.READ_CONTACTS\n2. group:android.permission-group.CAMERA\n  permission:android.permission.CAMERA\n...\n\n\n可以通过adb shell pm list permissions -d -g进行查看。\n看到上面的dangerous permission会发现危险权限都是一组一组的，分组对于我们会有什么影响吗？的确是有影响的，如果app运行在Android 6.x的系统上，对于授权机制是这样子的，如果你申请某个危险的权限，假设你的app早已被用户授予了同一组的某个危险权限，那么系统会立即授权，而不需要弹窗提示用户点击授权。对于申请时弹出的dialog上面的文本说明也是对整个权限组的说明，而不是单个权限。（注意：权限dialog是不能进行定制的）。\nps：不过需要注意的是，不要对权限组过多的依赖，尽可能对每个危险权限都进行正常的申请，以为在后面的版本权限组则可能发生变化！\n\n### 必须要支持运行时权限么\n目前应用实际上是可以不需要支持运行时权限的，但是最终肯定还是需要支持的，只是时间问题而已。\n\n想要不支持运行时权限很简单，只需要将targetSdkVersion设置低于23就可以了，意思是告诉系统，我还没有完全在API 23（6.0）上完全搞定，不要给我启动新的特性。\n\n### 不支持运行时权限会崩溃么\n可能会，但不是那种一上来就噼里啪啦崩溃不断的那种。\n\n如果你的应用将targetSdkVersion设置低于23，那么在6.x的系统上不会为这个应用开启运行时权限机制，即按照以前的一刀切方式处理。\n然而，6.x系统提供了一个应用权限管理界面，界面长得是这样子的\n\n6.0应用权限管理界面<img src=\"http://opkjcw4sd.bkt.clouddn.com/runtime_permission_manage.png\" width=\"280px\"/>\n\n既然是可以管理的，用户就能取消权限，当一个不支持运行时权限的应用某项权限被取消时，系统会弹出一个对话框提醒撤销的危害，如果用户执意撤销，会带来如下反应：\n* 如果你的应用程序在运行，则会被杀掉\n* 当你的应用再次运行时，可能出现崩溃\n\n为什么会可能崩溃的，比如下面这段代码\n\n```java\nTelephonyManager telephonyManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);\nString deviceId = telephonyManager.getDeviceId();\nif (deviceId.equals(mLastDeviceId)) {\n  //do something here\n}\n```\n如果用户撤销了获取DeviceId的权限，那么再次运行时，deviceId就是null,如果程序后续处理不当，就会出现崩溃。\n\n## 相关API\n6.0运行时权限，我们最终都是要支持的，通常我们需要使用如下的API\n\n* int checkSelfPermission(String permission) 用来检测应用是否已经具有权限\n* void requestPermissions(String[] permissions, int requestCode) 进行请求单个或多个权限\n* void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) 用户对请求作出响应后的回调\n* shouldShowRequestPermissionRationale 判断接下来的对话框是否包含”不再询问“选择框。\n\n以请求Camera权限为例\n\n```java\nprivate static final int REQUEST_PERMISSION_CAMERA_CODE = 1;\n@Override\npublic void onClick(View v) {\n    if (!(checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED)) {\n        requestCameraPermission();\n    }\n}\n\nprivate void requestCameraPermission() {\n    requestPermissions(new String[]{Manifest.permission.CAMERA}, REQUEST_PERMISSION_CAMERA_CODE);\n}\n\n@Override\npublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n    if (requestCode == REQUEST_PERMISSION_CAMERA_CODE) {\n        int grantResult = grantResults[0];\n        boolean granted = grantResult == PackageManager.PERMISSION_GRANTED;\n        Log.i(TAG, \">>> onRequestPermissionsResult camera granted = \" + granted);\n    }\n}\n```\n\n当用户选择允许，我们就可以在onRequestPermissionsResult方法中进行响应的处理，比如打开摄像头，进行下一步操作。当用户拒绝，你的应用可能就开始危险了，当我们再次尝试申请权限时，弹出的对话框和之前有点不一样了，主要表现为多了一个checkbox复选框。如下图\n\n再次请求拍照时<img src=\"http://opkjcw4sd.bkt.clouddn.com/open_camera_again.jpg\" width=\"280px\"/>\n\n当用户勾选了”不再询问“拒绝后，你的程序基本这个权限就Game Over了。\n不过，你还有一丝希望，那就是再出现上述的对话框之前做一些说明信息，比如你使用这个权限的目的（一定要坦白）。\n\nshouldShowRequestPermissionRationale这个API可以帮我们判断接下来的对话框是否包含”不再询问“选择框。\n\n### 一个标准的申请流程\n\n```java\nif (!(checkSelfPermission(Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED)) {\n  if (shouldShowRequestPermissionRationale(Manifest.permission.READ_CONTACTS)) {\n      Toast.makeText(this, \"Please grant the permission this time\", Toast.LENGTH_LONG).show();\n    }\n    requestReadContactsPermission();\n} else {\n  Log.i(TAG, \"onClick granted\");\n}\n```\n\n### 批量申请\n批量申请权限很简单，只需要字符串数组放置多个权限即可。如请求代码\n\n```java\nprivate static final int REQUEST_CODE = 1;\nprivate void requestMultiplePermissions() {\n    String[] permissions = {Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_PHONE_STATE};\n    requestPermissions(permissions, REQUEST_CODE);\n}\n```\n注意：间隔较短的多个权限申请建议设置成单次多个权限申请形式，避免弹出多个对话框，造成不太好的视觉效果。\n### 注意事项\n由于checkSelfPermission和requestPermissions从API 23才加入，低于23版本，需要在运行时判断 或者使用Support Library v4中提供的方法\n* ContextCompat.checkSelfPermission\n* ActivityCompat.requestPermissions\n* ActivityCompat.shouldShowRequestPermissionRationale\n\n### 多系统问题\n当我们支持了6.0必须也要支持4.4，5.0这些系统，所以需要在很多情况下，需要有两套处理。比如Camera权限\n```java\nif (Util.isOverMarshmallow()) {\n    requestPermission();//6.x申请权限\n} else {\n    openCamera();//低于6.0直接使用Camera\n}\n```\n\n## PermissionHandle库使用（封装）\n虽然权限处理并不复杂，但是需要编写很多重复的代码，PermissionHandle借鉴[PermissionGen](https://github.com/lovedise/PermissionGen)库来封装的，基于Annotation Processor编译时注解的方式来实现运行时权限申请回调。\n\n### 使用\n* 申请权限\n\n```java\n@OnClick(R.id.btn_camera)\n    public void open(View view) {\n        if (view.equals(mBtnOpenCamera)) {\n            PermissionsHandle.requestPermissions(this, REQUEST_CODE_OPEN_CAMERA, Manifest.permission.CAMERA);\n        }\n    }\n```\n* 根据授权情况进行回调\n\n```java\n    // open camera\n    @PermissionGrant(REQUEST_CODE_OPEN_CAMERA)\n    public void requestCameraSucess() {\n        Toast.makeText(mContext, \"Grant app access camera!\", Toast.LENGTH_SHORT).show();\n    }\n\n    @PermissionDenied(REQUEST_CODE_OPEN_CAMERA)\n    public void requestCameraFailed() {\n        Toast.makeText(mContext, \"Deny app access camera!!!\", Toast.LENGTH_SHORT).show();\n    }\n    \n    // request result\n      @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n        PermissionsHandle.onRequestPermissionsResult(this, requestCode, permissions, grantResults);\n    }\n```\n思路：反射实例化注解处理器生成的代理类，根据注解和requestCode找到方法，然后执行即可。详细请看[PermissionsHandle](https://github.com/haoxunwang/PermissionsHandle)\n\n### 框架依赖\n1. sample依赖permission-api，使用apt插件编译permission-compiler；\n2. permission-api依赖permission-annotation\n\n## Thanks\n* [PermissionGen](https://github.com/lovedise/PermissionGen)\n* [MPermissions](https://github.com/hongyangAndroid/MPermissions)\n* [聊一聊Android 6.0的运行时权限](http://droidyue.com/blog/2016/01/17/understanding-marshmallow-runtime-permission/)\n* Java api的方式来生成代码[javapoet](https://github.com/square/javapoet)\n* com.google.auto.service:auto-service:1.0-rc2，auto-service库生成META-INF等信息\n\n# Contacts\n * Email:haoxunwang525@163.com\n\n\n","source":"_posts/Android6-0动态权限处理.md","raw":"---\ntitle: Android6.0动态权限处理\ndate: 2017-05-07 14:21:51\ntags: Android\ncategories: Android\n---\n\n# PermissionsHandle (Android 6.0 运行时权限处理)\n> An easy-to-use library for handling Android M runtime permissions based on the Annotation Processor.\n\n<!-- more -->\n\n## Android权限说明\n\n### 6.0以前权限一刀切\nAndroid6.0以前的系统，所有权限都是一刀切处理方式，只要用户安装了应用，Manifest清单中申请的权限都会被赋予，且安装后撤销不了。当弹出安装对话框后，用户只有两个选择，要么选择安装，默认所有的敏感权限；要么拒绝安装应用。所以，这种一刀切的处理方式，我们是没有办法只允许某些权限或者拒绝某些权限。例如，小米5手机安装应用的情景。\n\n<img src=\"http://opkjcw4sd.bkt.clouddn.com/app_install_before.png\" width=\"250px\"/>&emsp;<img src=\"http://opkjcw4sd.bkt.clouddn.com/app_installing.png\" width=\"250px%\"/>\n\n### 6.0运行时权限\n从Android 6.0M 开始，系统引入了新的运行时权限机制。以某个需要拍照的应用为例，当运行时权限生效时，其Camera权限不是在安装后赋予，而是在应用运行的时候请求权限。比如当用户按下相机拍照按钮后，看到的效果是这样子的，接下来，对于Camera权限的处理权完全交给用户。\n\n请求拍照时<img src=\"http://opkjcw4sd.bkt.clouddn.com/open_camera.png\" width=\"280px\"/>\n\n### 权限的分组\n6.0系统对权限进行了分组，一般包括如下几类：\n* 正常权限（Normal Protection）\n* 危险权限（Dangerous）\n* 特殊权限（Particular）\n* 其他权限（一般很少用到）\n\n正常权限一般不涉及用户隐私，是不需要用户进行授权的，比如访问网络，手机震动等；危险权限一般是涉及用户隐私的，需要用户进行授权，比如读取手机Sdcard,访问通讯录，打开相机等。\n\n**Normal Permissions如下**\n1. ACCESS_NETWORK_STATE\n2. VIBRATE\n3. NFC\n4. BLUETOOTH\n...\n\n**Dangerous Permissions如下**\n1. group:android.permission-group.CONTACTS\n  permission:android.permission.WRITE_CONTACTS\n  permission:android.permission.GET_ACCOUNTS\n  permission:android.permission.READ_CONTACTS\n2. group:android.permission-group.CAMERA\n  permission:android.permission.CAMERA\n...\n\n\n可以通过adb shell pm list permissions -d -g进行查看。\n看到上面的dangerous permission会发现危险权限都是一组一组的，分组对于我们会有什么影响吗？的确是有影响的，如果app运行在Android 6.x的系统上，对于授权机制是这样子的，如果你申请某个危险的权限，假设你的app早已被用户授予了同一组的某个危险权限，那么系统会立即授权，而不需要弹窗提示用户点击授权。对于申请时弹出的dialog上面的文本说明也是对整个权限组的说明，而不是单个权限。（注意：权限dialog是不能进行定制的）。\nps：不过需要注意的是，不要对权限组过多的依赖，尽可能对每个危险权限都进行正常的申请，以为在后面的版本权限组则可能发生变化！\n\n### 必须要支持运行时权限么\n目前应用实际上是可以不需要支持运行时权限的，但是最终肯定还是需要支持的，只是时间问题而已。\n\n想要不支持运行时权限很简单，只需要将targetSdkVersion设置低于23就可以了，意思是告诉系统，我还没有完全在API 23（6.0）上完全搞定，不要给我启动新的特性。\n\n### 不支持运行时权限会崩溃么\n可能会，但不是那种一上来就噼里啪啦崩溃不断的那种。\n\n如果你的应用将targetSdkVersion设置低于23，那么在6.x的系统上不会为这个应用开启运行时权限机制，即按照以前的一刀切方式处理。\n然而，6.x系统提供了一个应用权限管理界面，界面长得是这样子的\n\n6.0应用权限管理界面<img src=\"http://opkjcw4sd.bkt.clouddn.com/runtime_permission_manage.png\" width=\"280px\"/>\n\n既然是可以管理的，用户就能取消权限，当一个不支持运行时权限的应用某项权限被取消时，系统会弹出一个对话框提醒撤销的危害，如果用户执意撤销，会带来如下反应：\n* 如果你的应用程序在运行，则会被杀掉\n* 当你的应用再次运行时，可能出现崩溃\n\n为什么会可能崩溃的，比如下面这段代码\n\n```java\nTelephonyManager telephonyManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);\nString deviceId = telephonyManager.getDeviceId();\nif (deviceId.equals(mLastDeviceId)) {\n  //do something here\n}\n```\n如果用户撤销了获取DeviceId的权限，那么再次运行时，deviceId就是null,如果程序后续处理不当，就会出现崩溃。\n\n## 相关API\n6.0运行时权限，我们最终都是要支持的，通常我们需要使用如下的API\n\n* int checkSelfPermission(String permission) 用来检测应用是否已经具有权限\n* void requestPermissions(String[] permissions, int requestCode) 进行请求单个或多个权限\n* void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) 用户对请求作出响应后的回调\n* shouldShowRequestPermissionRationale 判断接下来的对话框是否包含”不再询问“选择框。\n\n以请求Camera权限为例\n\n```java\nprivate static final int REQUEST_PERMISSION_CAMERA_CODE = 1;\n@Override\npublic void onClick(View v) {\n    if (!(checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED)) {\n        requestCameraPermission();\n    }\n}\n\nprivate void requestCameraPermission() {\n    requestPermissions(new String[]{Manifest.permission.CAMERA}, REQUEST_PERMISSION_CAMERA_CODE);\n}\n\n@Override\npublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n    if (requestCode == REQUEST_PERMISSION_CAMERA_CODE) {\n        int grantResult = grantResults[0];\n        boolean granted = grantResult == PackageManager.PERMISSION_GRANTED;\n        Log.i(TAG, \">>> onRequestPermissionsResult camera granted = \" + granted);\n    }\n}\n```\n\n当用户选择允许，我们就可以在onRequestPermissionsResult方法中进行响应的处理，比如打开摄像头，进行下一步操作。当用户拒绝，你的应用可能就开始危险了，当我们再次尝试申请权限时，弹出的对话框和之前有点不一样了，主要表现为多了一个checkbox复选框。如下图\n\n再次请求拍照时<img src=\"http://opkjcw4sd.bkt.clouddn.com/open_camera_again.jpg\" width=\"280px\"/>\n\n当用户勾选了”不再询问“拒绝后，你的程序基本这个权限就Game Over了。\n不过，你还有一丝希望，那就是再出现上述的对话框之前做一些说明信息，比如你使用这个权限的目的（一定要坦白）。\n\nshouldShowRequestPermissionRationale这个API可以帮我们判断接下来的对话框是否包含”不再询问“选择框。\n\n### 一个标准的申请流程\n\n```java\nif (!(checkSelfPermission(Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED)) {\n  if (shouldShowRequestPermissionRationale(Manifest.permission.READ_CONTACTS)) {\n      Toast.makeText(this, \"Please grant the permission this time\", Toast.LENGTH_LONG).show();\n    }\n    requestReadContactsPermission();\n} else {\n  Log.i(TAG, \"onClick granted\");\n}\n```\n\n### 批量申请\n批量申请权限很简单，只需要字符串数组放置多个权限即可。如请求代码\n\n```java\nprivate static final int REQUEST_CODE = 1;\nprivate void requestMultiplePermissions() {\n    String[] permissions = {Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_PHONE_STATE};\n    requestPermissions(permissions, REQUEST_CODE);\n}\n```\n注意：间隔较短的多个权限申请建议设置成单次多个权限申请形式，避免弹出多个对话框，造成不太好的视觉效果。\n### 注意事项\n由于checkSelfPermission和requestPermissions从API 23才加入，低于23版本，需要在运行时判断 或者使用Support Library v4中提供的方法\n* ContextCompat.checkSelfPermission\n* ActivityCompat.requestPermissions\n* ActivityCompat.shouldShowRequestPermissionRationale\n\n### 多系统问题\n当我们支持了6.0必须也要支持4.4，5.0这些系统，所以需要在很多情况下，需要有两套处理。比如Camera权限\n```java\nif (Util.isOverMarshmallow()) {\n    requestPermission();//6.x申请权限\n} else {\n    openCamera();//低于6.0直接使用Camera\n}\n```\n\n## PermissionHandle库使用（封装）\n虽然权限处理并不复杂，但是需要编写很多重复的代码，PermissionHandle借鉴[PermissionGen](https://github.com/lovedise/PermissionGen)库来封装的，基于Annotation Processor编译时注解的方式来实现运行时权限申请回调。\n\n### 使用\n* 申请权限\n\n```java\n@OnClick(R.id.btn_camera)\n    public void open(View view) {\n        if (view.equals(mBtnOpenCamera)) {\n            PermissionsHandle.requestPermissions(this, REQUEST_CODE_OPEN_CAMERA, Manifest.permission.CAMERA);\n        }\n    }\n```\n* 根据授权情况进行回调\n\n```java\n    // open camera\n    @PermissionGrant(REQUEST_CODE_OPEN_CAMERA)\n    public void requestCameraSucess() {\n        Toast.makeText(mContext, \"Grant app access camera!\", Toast.LENGTH_SHORT).show();\n    }\n\n    @PermissionDenied(REQUEST_CODE_OPEN_CAMERA)\n    public void requestCameraFailed() {\n        Toast.makeText(mContext, \"Deny app access camera!!!\", Toast.LENGTH_SHORT).show();\n    }\n    \n    // request result\n      @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n        PermissionsHandle.onRequestPermissionsResult(this, requestCode, permissions, grantResults);\n    }\n```\n思路：反射实例化注解处理器生成的代理类，根据注解和requestCode找到方法，然后执行即可。详细请看[PermissionsHandle](https://github.com/haoxunwang/PermissionsHandle)\n\n### 框架依赖\n1. sample依赖permission-api，使用apt插件编译permission-compiler；\n2. permission-api依赖permission-annotation\n\n## Thanks\n* [PermissionGen](https://github.com/lovedise/PermissionGen)\n* [MPermissions](https://github.com/hongyangAndroid/MPermissions)\n* [聊一聊Android 6.0的运行时权限](http://droidyue.com/blog/2016/01/17/understanding-marshmallow-runtime-permission/)\n* Java api的方式来生成代码[javapoet](https://github.com/square/javapoet)\n* com.google.auto.service:auto-service:1.0-rc2，auto-service库生成META-INF等信息\n\n# Contacts\n * Email:haoxunwang525@163.com\n\n\n","slug":"Android6-0动态权限处理","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4ves000dn2cbzg4j8tk2","content":"<h1 id=\"PermissionsHandle-Android-6-0-运行时权限处理\"><a href=\"#PermissionsHandle-Android-6-0-运行时权限处理\" class=\"headerlink\" title=\"PermissionsHandle (Android 6.0 运行时权限处理)\"></a>PermissionsHandle (Android 6.0 运行时权限处理)</h1><blockquote>\n<p>An easy-to-use library for handling Android M runtime permissions based on the Annotation Processor.</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"Android权限说明\"><a href=\"#Android权限说明\" class=\"headerlink\" title=\"Android权限说明\"></a>Android权限说明</h2><h3 id=\"6-0以前权限一刀切\"><a href=\"#6-0以前权限一刀切\" class=\"headerlink\" title=\"6.0以前权限一刀切\"></a>6.0以前权限一刀切</h3><p>Android6.0以前的系统，所有权限都是一刀切处理方式，只要用户安装了应用，Manifest清单中申请的权限都会被赋予，且安装后撤销不了。当弹出安装对话框后，用户只有两个选择，要么选择安装，默认所有的敏感权限；要么拒绝安装应用。所以，这种一刀切的处理方式，我们是没有办法只允许某些权限或者拒绝某些权限。例如，小米5手机安装应用的情景。</p>\n<p><img src=\"http://opkjcw4sd.bkt.clouddn.com/app_install_before.png\" width=\"250px\">&emsp;<img src=\"http://opkjcw4sd.bkt.clouddn.com/app_installing.png\" width=\"250px%\"></p>\n<h3 id=\"6-0运行时权限\"><a href=\"#6-0运行时权限\" class=\"headerlink\" title=\"6.0运行时权限\"></a>6.0运行时权限</h3><p>从Android 6.0M 开始，系统引入了新的运行时权限机制。以某个需要拍照的应用为例，当运行时权限生效时，其Camera权限不是在安装后赋予，而是在应用运行的时候请求权限。比如当用户按下相机拍照按钮后，看到的效果是这样子的，接下来，对于Camera权限的处理权完全交给用户。</p>\n<p>请求拍照时<img src=\"http://opkjcw4sd.bkt.clouddn.com/open_camera.png\" width=\"280px\"></p>\n<h3 id=\"权限的分组\"><a href=\"#权限的分组\" class=\"headerlink\" title=\"权限的分组\"></a>权限的分组</h3><p>6.0系统对权限进行了分组，一般包括如下几类：</p>\n<ul>\n<li>正常权限（Normal Protection）</li>\n<li>危险权限（Dangerous）</li>\n<li>特殊权限（Particular）</li>\n<li>其他权限（一般很少用到）</li>\n</ul>\n<p>正常权限一般不涉及用户隐私，是不需要用户进行授权的，比如访问网络，手机震动等；危险权限一般是涉及用户隐私的，需要用户进行授权，比如读取手机Sdcard,访问通讯录，打开相机等。</p>\n<p><strong>Normal Permissions如下</strong></p>\n<ol>\n<li>ACCESS_NETWORK_STATE</li>\n<li>VIBRATE</li>\n<li>NFC</li>\n<li>BLUETOOTH<br>…</li>\n</ol>\n<p><strong>Dangerous Permissions如下</strong></p>\n<ol>\n<li>group:android.permission-group.CONTACTS<br>permission:android.permission.WRITE_CONTACTS<br>permission:android.permission.GET_ACCOUNTS<br>permission:android.permission.READ_CONTACTS</li>\n<li>group:android.permission-group.CAMERA<br>permission:android.permission.CAMERA<br>…</li>\n</ol>\n<p>可以通过adb shell pm list permissions -d -g进行查看。<br>看到上面的dangerous permission会发现危险权限都是一组一组的，分组对于我们会有什么影响吗？的确是有影响的，如果app运行在Android 6.x的系统上，对于授权机制是这样子的，如果你申请某个危险的权限，假设你的app早已被用户授予了同一组的某个危险权限，那么系统会立即授权，而不需要弹窗提示用户点击授权。对于申请时弹出的dialog上面的文本说明也是对整个权限组的说明，而不是单个权限。（注意：权限dialog是不能进行定制的）。<br>ps：不过需要注意的是，不要对权限组过多的依赖，尽可能对每个危险权限都进行正常的申请，以为在后面的版本权限组则可能发生变化！</p>\n<h3 id=\"必须要支持运行时权限么\"><a href=\"#必须要支持运行时权限么\" class=\"headerlink\" title=\"必须要支持运行时权限么\"></a>必须要支持运行时权限么</h3><p>目前应用实际上是可以不需要支持运行时权限的，但是最终肯定还是需要支持的，只是时间问题而已。</p>\n<p>想要不支持运行时权限很简单，只需要将targetSdkVersion设置低于23就可以了，意思是告诉系统，我还没有完全在API 23（6.0）上完全搞定，不要给我启动新的特性。</p>\n<h3 id=\"不支持运行时权限会崩溃么\"><a href=\"#不支持运行时权限会崩溃么\" class=\"headerlink\" title=\"不支持运行时权限会崩溃么\"></a>不支持运行时权限会崩溃么</h3><p>可能会，但不是那种一上来就噼里啪啦崩溃不断的那种。</p>\n<p>如果你的应用将targetSdkVersion设置低于23，那么在6.x的系统上不会为这个应用开启运行时权限机制，即按照以前的一刀切方式处理。<br>然而，6.x系统提供了一个应用权限管理界面，界面长得是这样子的</p>\n<p>6.0应用权限管理界面<img src=\"http://opkjcw4sd.bkt.clouddn.com/runtime_permission_manage.png\" width=\"280px\"></p>\n<p>既然是可以管理的，用户就能取消权限，当一个不支持运行时权限的应用某项权限被取消时，系统会弹出一个对话框提醒撤销的危害，如果用户执意撤销，会带来如下反应：</p>\n<ul>\n<li>如果你的应用程序在运行，则会被杀掉</li>\n<li>当你的应用再次运行时，可能出现崩溃</li>\n</ul>\n<p>为什么会可能崩溃的，比如下面这段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TelephonyManager telephonyManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class=\"line\">String deviceId = telephonyManager.getDeviceId();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (deviceId.equals(mLastDeviceId)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//do something here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果用户撤销了获取DeviceId的权限，那么再次运行时，deviceId就是null,如果程序后续处理不当，就会出现崩溃。</p>\n<h2 id=\"相关API\"><a href=\"#相关API\" class=\"headerlink\" title=\"相关API\"></a>相关API</h2><p>6.0运行时权限，我们最终都是要支持的，通常我们需要使用如下的API</p>\n<ul>\n<li>int checkSelfPermission(String permission) 用来检测应用是否已经具有权限</li>\n<li>void requestPermissions(String[] permissions, int requestCode) 进行请求单个或多个权限</li>\n<li>void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) 用户对请求作出响应后的回调</li>\n<li>shouldShowRequestPermissionRationale 判断接下来的对话框是否包含”不再询问“选择框。</li>\n</ul>\n<p>以请求Camera权限为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> REQUEST_PERMISSION_CAMERA_CODE = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED)) &#123;</span><br><span class=\"line\">        requestCameraPermission();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">requestCameraPermission</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    requestPermissions(<span class=\"keyword\">new</span> String[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_PERMISSION_CAMERA_CODE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, String[] permissions, <span class=\"keyword\">int</span>[] grantResults)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestCode == REQUEST_PERMISSION_CAMERA_CODE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> grantResult = grantResults[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> granted = grantResult == PackageManager.PERMISSION_GRANTED;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"&gt;&gt;&gt; onRequestPermissionsResult camera granted = \"</span> + granted);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当用户选择允许，我们就可以在onRequestPermissionsResult方法中进行响应的处理，比如打开摄像头，进行下一步操作。当用户拒绝，你的应用可能就开始危险了，当我们再次尝试申请权限时，弹出的对话框和之前有点不一样了，主要表现为多了一个checkbox复选框。如下图</p>\n<p>再次请求拍照时<img src=\"http://opkjcw4sd.bkt.clouddn.com/open_camera_again.jpg\" width=\"280px\"></p>\n<p>当用户勾选了”不再询问“拒绝后，你的程序基本这个权限就Game Over了。<br>不过，你还有一丝希望，那就是再出现上述的对话框之前做一些说明信息，比如你使用这个权限的目的（一定要坦白）。</p>\n<p>shouldShowRequestPermissionRationale这个API可以帮我们判断接下来的对话框是否包含”不再询问“选择框。</p>\n<h3 id=\"一个标准的申请流程\"><a href=\"#一个标准的申请流程\" class=\"headerlink\" title=\"一个标准的申请流程\"></a>一个标准的申请流程</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!(checkSelfPermission(Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldShowRequestPermissionRationale(Manifest.permission.READ_CONTACTS)) &#123;</span><br><span class=\"line\">      Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"Please grant the permission this time\"</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    requestReadContactsPermission();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  Log.i(TAG, <span class=\"string\">\"onClick granted\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"批量申请\"><a href=\"#批量申请\" class=\"headerlink\" title=\"批量申请\"></a>批量申请</h3><p>批量申请权限很简单，只需要字符串数组放置多个权限即可。如请求代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> REQUEST_CODE = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">requestMultiplePermissions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    String[] permissions = &#123;Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_PHONE_STATE&#125;;</span><br><span class=\"line\">    requestPermissions(permissions, REQUEST_CODE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：间隔较短的多个权限申请建议设置成单次多个权限申请形式，避免弹出多个对话框，造成不太好的视觉效果。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>由于checkSelfPermission和requestPermissions从API 23才加入，低于23版本，需要在运行时判断 或者使用Support Library v4中提供的方法</p>\n<ul>\n<li>ContextCompat.checkSelfPermission</li>\n<li>ActivityCompat.requestPermissions</li>\n<li>ActivityCompat.shouldShowRequestPermissionRationale</li>\n</ul>\n<h3 id=\"多系统问题\"><a href=\"#多系统问题\" class=\"headerlink\" title=\"多系统问题\"></a>多系统问题</h3><p>当我们支持了6.0必须也要支持4.4，5.0这些系统，所以需要在很多情况下，需要有两套处理。比如Camera权限<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (Util.isOverMarshmallow()) &#123;</span><br><span class=\"line\">    requestPermission();<span class=\"comment\">//6.x申请权限</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    openCamera();<span class=\"comment\">//低于6.0直接使用Camera</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"PermissionHandle库使用（封装）\"><a href=\"#PermissionHandle库使用（封装）\" class=\"headerlink\" title=\"PermissionHandle库使用（封装）\"></a>PermissionHandle库使用（封装）</h2><p>虽然权限处理并不复杂，但是需要编写很多重复的代码，PermissionHandle借鉴<a href=\"https://github.com/lovedise/PermissionGen\" target=\"_blank\" rel=\"noopener\">PermissionGen</a>库来封装的，基于Annotation Processor编译时注解的方式来实现运行时权限申请回调。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>申请权限</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@OnClick</span>(R.id.btn_camera)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view.equals(mBtnOpenCamera)) &#123;</span><br><span class=\"line\">            PermissionsHandle.requestPermissions(<span class=\"keyword\">this</span>, REQUEST_CODE_OPEN_CAMERA, Manifest.permission.CAMERA);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>根据授权情况进行回调</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// open camera</span></span><br><span class=\"line\"><span class=\"meta\">@PermissionGrant</span>(REQUEST_CODE_OPEN_CAMERA)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestCameraSucess</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Toast.makeText(mContext, <span class=\"string\">\"Grant app access camera!\"</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@PermissionDenied</span>(REQUEST_CODE_OPEN_CAMERA)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestCameraFailed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Toast.makeText(mContext, <span class=\"string\">\"Deny app access camera!!!\"</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// request result</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class=\"keyword\">int</span>[] grantResults)</span> </span>&#123;</span><br><span class=\"line\">    PermissionsHandle.onRequestPermissionsResult(<span class=\"keyword\">this</span>, requestCode, permissions, grantResults);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>思路：反射实例化注解处理器生成的代理类，根据注解和requestCode找到方法，然后执行即可。详细请看<a href=\"https://github.com/haoxunwang/PermissionsHandle\" target=\"_blank\" rel=\"noopener\">PermissionsHandle</a></p>\n<h3 id=\"框架依赖\"><a href=\"#框架依赖\" class=\"headerlink\" title=\"框架依赖\"></a>框架依赖</h3><ol>\n<li>sample依赖permission-api，使用apt插件编译permission-compiler；</li>\n<li>permission-api依赖permission-annotation</li>\n</ol>\n<h2 id=\"Thanks\"><a href=\"#Thanks\" class=\"headerlink\" title=\"Thanks\"></a>Thanks</h2><ul>\n<li><a href=\"https://github.com/lovedise/PermissionGen\" target=\"_blank\" rel=\"noopener\">PermissionGen</a></li>\n<li><a href=\"https://github.com/hongyangAndroid/MPermissions\" target=\"_blank\" rel=\"noopener\">MPermissions</a></li>\n<li><a href=\"http://droidyue.com/blog/2016/01/17/understanding-marshmallow-runtime-permission/\" target=\"_blank\" rel=\"noopener\">聊一聊Android 6.0的运行时权限</a></li>\n<li>Java api的方式来生成代码<a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"noopener\">javapoet</a></li>\n<li>com.google.auto.service:auto-service:1.0-rc2，auto-service库生成META-INF等信息</li>\n</ul>\n<h1 id=\"Contacts\"><a href=\"#Contacts\" class=\"headerlink\" title=\"Contacts\"></a>Contacts</h1><ul>\n<li>Email:<a href=\"mailto:haoxunwang525@163.com\" target=\"_blank\" rel=\"noopener\">haoxunwang525@163.com</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"PermissionsHandle-Android-6-0-运行时权限处理\"><a href=\"#PermissionsHandle-Android-6-0-运行时权限处理\" class=\"headerlink\" title=\"PermissionsHandle (Android 6.0 运行时权限处理)\"></a>PermissionsHandle (Android 6.0 运行时权限处理)</h1><blockquote>\n<p>An easy-to-use library for handling Android M runtime permissions based on the Annotation Processor.</p>\n</blockquote>","more":"<h2 id=\"Android权限说明\"><a href=\"#Android权限说明\" class=\"headerlink\" title=\"Android权限说明\"></a>Android权限说明</h2><h3 id=\"6-0以前权限一刀切\"><a href=\"#6-0以前权限一刀切\" class=\"headerlink\" title=\"6.0以前权限一刀切\"></a>6.0以前权限一刀切</h3><p>Android6.0以前的系统，所有权限都是一刀切处理方式，只要用户安装了应用，Manifest清单中申请的权限都会被赋予，且安装后撤销不了。当弹出安装对话框后，用户只有两个选择，要么选择安装，默认所有的敏感权限；要么拒绝安装应用。所以，这种一刀切的处理方式，我们是没有办法只允许某些权限或者拒绝某些权限。例如，小米5手机安装应用的情景。</p>\n<p><img src=\"http://opkjcw4sd.bkt.clouddn.com/app_install_before.png\" width=\"250px\">&emsp;<img src=\"http://opkjcw4sd.bkt.clouddn.com/app_installing.png\" width=\"250px%\"></p>\n<h3 id=\"6-0运行时权限\"><a href=\"#6-0运行时权限\" class=\"headerlink\" title=\"6.0运行时权限\"></a>6.0运行时权限</h3><p>从Android 6.0M 开始，系统引入了新的运行时权限机制。以某个需要拍照的应用为例，当运行时权限生效时，其Camera权限不是在安装后赋予，而是在应用运行的时候请求权限。比如当用户按下相机拍照按钮后，看到的效果是这样子的，接下来，对于Camera权限的处理权完全交给用户。</p>\n<p>请求拍照时<img src=\"http://opkjcw4sd.bkt.clouddn.com/open_camera.png\" width=\"280px\"></p>\n<h3 id=\"权限的分组\"><a href=\"#权限的分组\" class=\"headerlink\" title=\"权限的分组\"></a>权限的分组</h3><p>6.0系统对权限进行了分组，一般包括如下几类：</p>\n<ul>\n<li>正常权限（Normal Protection）</li>\n<li>危险权限（Dangerous）</li>\n<li>特殊权限（Particular）</li>\n<li>其他权限（一般很少用到）</li>\n</ul>\n<p>正常权限一般不涉及用户隐私，是不需要用户进行授权的，比如访问网络，手机震动等；危险权限一般是涉及用户隐私的，需要用户进行授权，比如读取手机Sdcard,访问通讯录，打开相机等。</p>\n<p><strong>Normal Permissions如下</strong></p>\n<ol>\n<li>ACCESS_NETWORK_STATE</li>\n<li>VIBRATE</li>\n<li>NFC</li>\n<li>BLUETOOTH<br>…</li>\n</ol>\n<p><strong>Dangerous Permissions如下</strong></p>\n<ol>\n<li>group:android.permission-group.CONTACTS<br>permission:android.permission.WRITE_CONTACTS<br>permission:android.permission.GET_ACCOUNTS<br>permission:android.permission.READ_CONTACTS</li>\n<li>group:android.permission-group.CAMERA<br>permission:android.permission.CAMERA<br>…</li>\n</ol>\n<p>可以通过adb shell pm list permissions -d -g进行查看。<br>看到上面的dangerous permission会发现危险权限都是一组一组的，分组对于我们会有什么影响吗？的确是有影响的，如果app运行在Android 6.x的系统上，对于授权机制是这样子的，如果你申请某个危险的权限，假设你的app早已被用户授予了同一组的某个危险权限，那么系统会立即授权，而不需要弹窗提示用户点击授权。对于申请时弹出的dialog上面的文本说明也是对整个权限组的说明，而不是单个权限。（注意：权限dialog是不能进行定制的）。<br>ps：不过需要注意的是，不要对权限组过多的依赖，尽可能对每个危险权限都进行正常的申请，以为在后面的版本权限组则可能发生变化！</p>\n<h3 id=\"必须要支持运行时权限么\"><a href=\"#必须要支持运行时权限么\" class=\"headerlink\" title=\"必须要支持运行时权限么\"></a>必须要支持运行时权限么</h3><p>目前应用实际上是可以不需要支持运行时权限的，但是最终肯定还是需要支持的，只是时间问题而已。</p>\n<p>想要不支持运行时权限很简单，只需要将targetSdkVersion设置低于23就可以了，意思是告诉系统，我还没有完全在API 23（6.0）上完全搞定，不要给我启动新的特性。</p>\n<h3 id=\"不支持运行时权限会崩溃么\"><a href=\"#不支持运行时权限会崩溃么\" class=\"headerlink\" title=\"不支持运行时权限会崩溃么\"></a>不支持运行时权限会崩溃么</h3><p>可能会，但不是那种一上来就噼里啪啦崩溃不断的那种。</p>\n<p>如果你的应用将targetSdkVersion设置低于23，那么在6.x的系统上不会为这个应用开启运行时权限机制，即按照以前的一刀切方式处理。<br>然而，6.x系统提供了一个应用权限管理界面，界面长得是这样子的</p>\n<p>6.0应用权限管理界面<img src=\"http://opkjcw4sd.bkt.clouddn.com/runtime_permission_manage.png\" width=\"280px\"></p>\n<p>既然是可以管理的，用户就能取消权限，当一个不支持运行时权限的应用某项权限被取消时，系统会弹出一个对话框提醒撤销的危害，如果用户执意撤销，会带来如下反应：</p>\n<ul>\n<li>如果你的应用程序在运行，则会被杀掉</li>\n<li>当你的应用再次运行时，可能出现崩溃</li>\n</ul>\n<p>为什么会可能崩溃的，比如下面这段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TelephonyManager telephonyManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class=\"line\">String deviceId = telephonyManager.getDeviceId();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (deviceId.equals(mLastDeviceId)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//do something here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果用户撤销了获取DeviceId的权限，那么再次运行时，deviceId就是null,如果程序后续处理不当，就会出现崩溃。</p>\n<h2 id=\"相关API\"><a href=\"#相关API\" class=\"headerlink\" title=\"相关API\"></a>相关API</h2><p>6.0运行时权限，我们最终都是要支持的，通常我们需要使用如下的API</p>\n<ul>\n<li>int checkSelfPermission(String permission) 用来检测应用是否已经具有权限</li>\n<li>void requestPermissions(String[] permissions, int requestCode) 进行请求单个或多个权限</li>\n<li>void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) 用户对请求作出响应后的回调</li>\n<li>shouldShowRequestPermissionRationale 判断接下来的对话框是否包含”不再询问“选择框。</li>\n</ul>\n<p>以请求Camera权限为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> REQUEST_PERMISSION_CAMERA_CODE = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED)) &#123;</span><br><span class=\"line\">        requestCameraPermission();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">requestCameraPermission</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    requestPermissions(<span class=\"keyword\">new</span> String[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_PERMISSION_CAMERA_CODE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, String[] permissions, <span class=\"keyword\">int</span>[] grantResults)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestCode == REQUEST_PERMISSION_CAMERA_CODE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> grantResult = grantResults[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> granted = grantResult == PackageManager.PERMISSION_GRANTED;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"&gt;&gt;&gt; onRequestPermissionsResult camera granted = \"</span> + granted);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当用户选择允许，我们就可以在onRequestPermissionsResult方法中进行响应的处理，比如打开摄像头，进行下一步操作。当用户拒绝，你的应用可能就开始危险了，当我们再次尝试申请权限时，弹出的对话框和之前有点不一样了，主要表现为多了一个checkbox复选框。如下图</p>\n<p>再次请求拍照时<img src=\"http://opkjcw4sd.bkt.clouddn.com/open_camera_again.jpg\" width=\"280px\"></p>\n<p>当用户勾选了”不再询问“拒绝后，你的程序基本这个权限就Game Over了。<br>不过，你还有一丝希望，那就是再出现上述的对话框之前做一些说明信息，比如你使用这个权限的目的（一定要坦白）。</p>\n<p>shouldShowRequestPermissionRationale这个API可以帮我们判断接下来的对话框是否包含”不再询问“选择框。</p>\n<h3 id=\"一个标准的申请流程\"><a href=\"#一个标准的申请流程\" class=\"headerlink\" title=\"一个标准的申请流程\"></a>一个标准的申请流程</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!(checkSelfPermission(Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldShowRequestPermissionRationale(Manifest.permission.READ_CONTACTS)) &#123;</span><br><span class=\"line\">      Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"Please grant the permission this time\"</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    requestReadContactsPermission();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  Log.i(TAG, <span class=\"string\">\"onClick granted\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"批量申请\"><a href=\"#批量申请\" class=\"headerlink\" title=\"批量申请\"></a>批量申请</h3><p>批量申请权限很简单，只需要字符串数组放置多个权限即可。如请求代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> REQUEST_CODE = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">requestMultiplePermissions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    String[] permissions = &#123;Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_PHONE_STATE&#125;;</span><br><span class=\"line\">    requestPermissions(permissions, REQUEST_CODE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：间隔较短的多个权限申请建议设置成单次多个权限申请形式，避免弹出多个对话框，造成不太好的视觉效果。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>由于checkSelfPermission和requestPermissions从API 23才加入，低于23版本，需要在运行时判断 或者使用Support Library v4中提供的方法</p>\n<ul>\n<li>ContextCompat.checkSelfPermission</li>\n<li>ActivityCompat.requestPermissions</li>\n<li>ActivityCompat.shouldShowRequestPermissionRationale</li>\n</ul>\n<h3 id=\"多系统问题\"><a href=\"#多系统问题\" class=\"headerlink\" title=\"多系统问题\"></a>多系统问题</h3><p>当我们支持了6.0必须也要支持4.4，5.0这些系统，所以需要在很多情况下，需要有两套处理。比如Camera权限<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (Util.isOverMarshmallow()) &#123;</span><br><span class=\"line\">    requestPermission();<span class=\"comment\">//6.x申请权限</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    openCamera();<span class=\"comment\">//低于6.0直接使用Camera</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"PermissionHandle库使用（封装）\"><a href=\"#PermissionHandle库使用（封装）\" class=\"headerlink\" title=\"PermissionHandle库使用（封装）\"></a>PermissionHandle库使用（封装）</h2><p>虽然权限处理并不复杂，但是需要编写很多重复的代码，PermissionHandle借鉴<a href=\"https://github.com/lovedise/PermissionGen\" target=\"_blank\" rel=\"noopener\">PermissionGen</a>库来封装的，基于Annotation Processor编译时注解的方式来实现运行时权限申请回调。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>申请权限</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@OnClick</span>(R.id.btn_camera)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view.equals(mBtnOpenCamera)) &#123;</span><br><span class=\"line\">            PermissionsHandle.requestPermissions(<span class=\"keyword\">this</span>, REQUEST_CODE_OPEN_CAMERA, Manifest.permission.CAMERA);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>根据授权情况进行回调</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// open camera</span></span><br><span class=\"line\"><span class=\"meta\">@PermissionGrant</span>(REQUEST_CODE_OPEN_CAMERA)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestCameraSucess</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Toast.makeText(mContext, <span class=\"string\">\"Grant app access camera!\"</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@PermissionDenied</span>(REQUEST_CODE_OPEN_CAMERA)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestCameraFailed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Toast.makeText(mContext, <span class=\"string\">\"Deny app access camera!!!\"</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// request result</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class=\"keyword\">int</span>[] grantResults)</span> </span>&#123;</span><br><span class=\"line\">    PermissionsHandle.onRequestPermissionsResult(<span class=\"keyword\">this</span>, requestCode, permissions, grantResults);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>思路：反射实例化注解处理器生成的代理类，根据注解和requestCode找到方法，然后执行即可。详细请看<a href=\"https://github.com/haoxunwang/PermissionsHandle\" target=\"_blank\" rel=\"noopener\">PermissionsHandle</a></p>\n<h3 id=\"框架依赖\"><a href=\"#框架依赖\" class=\"headerlink\" title=\"框架依赖\"></a>框架依赖</h3><ol>\n<li>sample依赖permission-api，使用apt插件编译permission-compiler；</li>\n<li>permission-api依赖permission-annotation</li>\n</ol>\n<h2 id=\"Thanks\"><a href=\"#Thanks\" class=\"headerlink\" title=\"Thanks\"></a>Thanks</h2><ul>\n<li><a href=\"https://github.com/lovedise/PermissionGen\" target=\"_blank\" rel=\"noopener\">PermissionGen</a></li>\n<li><a href=\"https://github.com/hongyangAndroid/MPermissions\" target=\"_blank\" rel=\"noopener\">MPermissions</a></li>\n<li><a href=\"http://droidyue.com/blog/2016/01/17/understanding-marshmallow-runtime-permission/\" target=\"_blank\" rel=\"noopener\">聊一聊Android 6.0的运行时权限</a></li>\n<li>Java api的方式来生成代码<a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"noopener\">javapoet</a></li>\n<li>com.google.auto.service:auto-service:1.0-rc2，auto-service库生成META-INF等信息</li>\n</ul>\n<h1 id=\"Contacts\"><a href=\"#Contacts\" class=\"headerlink\" title=\"Contacts\"></a>Contacts</h1><ul>\n<li>Email:<a href=\"mailto:haoxunwang525@163.com\" target=\"_blank\" rel=\"noopener\">haoxunwang525@163.com</a></li>\n</ul>"},{"title":"Android图片压缩","date":"2017-02-23T13:49:15.000Z","_content":"\n> 本文讲解了Android Compress image的方式，主要从**图片的存在形式**、**检测图片大小的方法**、**压缩方式**、**数据对比**等方面阐述了压缩方案。\n\n<!-- more -->\n\n\n## 图片的存在形式\n1. **文件形式**（即以二进制形式存在于硬盘上）\n2. **流的形式** （即以二进制形式存在于内存中）\n3. **Bitmap形式**\n\n>  **区别：**文件形式和流的形式对图片体积大小没有影响，也就是说，如果图片在手机SD卡上的大小是100KB，那么通过流的形式读到内存中，也是占用100KB的大小，注意是流的形式，不是bitmap的形式；当图片以Bitmap的形式存在时，其占用的内存会瞬间变大，曾经试过把500KB左右的图片加载到内存中，以Bitmap形式存在时，内存占用近10MB，当然这个增大的倍数不是固定的。\n\n## 检测图片大小的方法\n1. **文件形式** file.length( )\n2. **流的形式** 将图片文件读到内存输入流中，看它的byte数\n3. **Bitmap** bitmap.getByteCount( )\n\n## 压缩方式\n\n### 质量压缩\n\n`bitmap.compress(CompressFormat,quality,outputstream)`\n1. 第一个参数是个枚举类CompressFormat，主要有JPEG，PNG，WEBP三种类型，一般使用JPEG；\n2. 第二个参数是压缩质量，取值0-100之间，100代表质量最高，0代表最低；\n3. 第三个参数是输出流，可把图片字节流保存成指定文件。\n使用实例：\n\n```java\n    public static void compressBmpToFile(Bitmap bmp, File file) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int options = 80;// 压缩质量从80开始 \n        bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);\n        while (baos.toByteArray().length / 1024 > 100) { // 如果大于100KB时，压缩质量-10；  \n            baos.reset();\n            options -= 10;\n            bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);\n        }\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baos.toByteArray());\n            fos.flush();\n            fos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n**方法说明：**该方法是压缩图片的质量，*但并不会减少图片的像素*，比如，图片是800KB 1008x756像素的，经该方法压缩后，File形式的图片是在100KB左右，以方便上传服务器，但是BitmapFactory.decodeFile( )到内存中变成bitmap时，它的像素值仍然是1008x756，计算图片像素的方法是bitmap.getWidth( )和bitmap.getHeight( )，图片是由像素组成的，每个像素又包含什么呢？熟悉PS的人都知道，图片是有色相，明度和饱和度构成的。\n\n该方法也是Google官方文档解释说，它会让图片重新构造，但是有可能图片的位深（既色深）和每个像素的透明度会变化，JPEG only supports opaque(不透明)，也就是说jpeg格式压缩后，原来图片中透明的元素将会消失，所以这种格式很可能造成失真。 \n\n既然它是改变了图片的显示质量，达到了对File形式的图片进行压缩，图片的像素没有改变的话，重新读取经过压缩file为bitmap时，它占用的内存并不会减少。\n\n因为：bitmap.getByteCount( )是计算它的像素所占用的内存，请看官方解释：Returns the number of bytes used to store this bitmap's pixels.\n\n### 像素压缩\n\n**特点：**通过设置采样率，减少图片的像素，即图片从File形式变成Bitmap形式\n\n先看一个方法: 该方法是对内存中的Bitmap进行质量上的压缩, 由上面的理论可以得出该方法是无效的, 而且也是没有必要的,因为你已经将它读到内存中了,再压缩多此一举, 尽管在获取系统相册图片时,某些手机会直接返回一个Bitmap,但是这种情况下, 返回的Bitmap都是经过压缩的, 它不可能直接返回一个原声的Bitmap形式的图片, 后果可想而知。\n\n```java\n    private Bitmap compressBmpFromBmp(Bitmap image) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int options = 100;\n        image.compress(Bitmap.CompressFormat.JPEG, 100, baos);\n        while (baos.toByteArray().length / 1024 > 100) {\n            baos.reset();\n            options -= 10;\n            image.compress(Bitmap.CompressFormat.JPEG, options, baos);\n        }\n        ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());\n        Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);\n        return bitmap;\n    }\n\n```\n\n再看一个方法:\n\n```java\n    private Bitmap compressImageFromFile(String srcPath) {\n        BitmapFactory.Options newOpts = new BitmapFactory.Options();\n        newOpts.inJustDecodeBounds = true;//只读边,不读内容  \n        Bitmap bitmap = BitmapFactory.decodeFile(srcPath, newOpts);\n\n        newOpts.inJustDecodeBounds = false;\n        int w = newOpts.outWidth;\n        int h = newOpts.outHeight;\n        float hh = 800f;//  \n        float ww = 480f;//  \n        int be = 1;\n        if (w > h && w > ww) {\n            be = (int) (newOpts.outWidth / ww);\n        } else if (w < h && h > hh) {\n            be = (int) (newOpts.outHeight / hh);\n        }\n        if (be <= 0)\n            be = 1;\n        newOpts.inSampleSize = be;//设置采样率  \n\n        newOpts.inPreferredConfig = Config.ARGB_8888;//该模式是默认的,可不设  \n        newOpts.inPurgeable = true;// 同时设置才会有效  \n        newOpts.inInputShareable = true;//。当系统内存不够时候图片自动被回收  \n\n        bitmap = BitmapFactory.decodeFile(srcPath, newOpts);\n        // return compressBmpFromBmp(bitmap);//原来的方法调用了这个方法企图进行二次压缩  \n        // 其实是无效的,大家尽管尝试  \n        return bitmap;\n    }\n\n```\n\n###  压缩终极方案，修改libjpeg图像库，使用c库来保存bitmap到file\n\n* [[Android算法] android图片压缩终极解决方案](http://www.see-source.com/blog/300000022/684.html)\n* [为什么Android的图片质量会比iPhone的差？](http://www.cnblogs.com/MaxIE/p/3951294.html)\n* [github demo](https://github.com/bither/bither-android-lib)\n\n> 以上是参考文章和修改libjpeg图像库的demo，本人亲自试了下，没有像介绍的那样可靠，也有可能不同ROM是否已经修复了此bug？暂时还不得而知，需要在此验证。\n\n### 数据对比\n\n**默认使用的位图配置是ARGB_8888**，图片加载到内存大小3456x4608x4字节约等于60.75MB，直接加载会OOM，需要进行长宽压缩 + 像素质量压缩。\n> 原图大小 5.21MB 3456x4608px，缩小4时，quality = 80，864x1152px\n\n|   origin  |   jpegTrue    |   jpegFalse   |   sampleSize  |   quality | \n|   :--:        |   :--:            |   :--:            |   :--:                |   :--:        | \n|145.75KB|      -           |   -               |   4                   | 80            |       \n|               |   141.63KB |  -               |   4                   | 80            |  \n|               |                   |  144.79KB  |  4                   | 80            |\n\n| origin            |    jpegTrue |     jpegFalse  | sampleSize | quality | \n|   :--:            |   :--:            |       :--:         |  :--:                |   :--:      | \n| 706.34KB  |   -               |       -           |   4                   | 100        |      \n|                  |    629.34KB |          -           |   4                   | 100        |  \n|                  |                     |      661.51KB |  4                   | 100        |\n\n\n| origin            |    jpegTrue |     jpegFalse  | sampleSize | quality   | \n| :--:              | :--:              |       :--:         |  :--:                |   :--:        | \n| 8.71MB        |   -               |       -           |   1                   | 100       |       \n|                  |    7.13MB  |       -           |   1                   | 100       |  \n|                  |                    |   7.62MB  |   1                   | 100       |\n\n| origin            |    jpegTrue |     jpegFalse  | sampleSize | quality  | \n| :--:              |       :--:          |         :--:         |  :--:                |   :--:      | \n| 1.43MB        |       -           |       -           |   1                   | 80          |     \n|                  |    1.34MB  |       -           |   1                   | 80          |  \n|                  |                    |   1.41MB  |   1                   | 80          |\n\n\n-------\n\n> Transform a bitmap into an input stream \n\n```java\n    // Your Bitmap.\n    Bitmap bitmap = XXX;  \n\n    int byteSize = bitmap.getRowBytes() * bitmap.getHeight();\n    //int byteSize = bitmap.getByteCount();\n    ByteBuffer byteBuffer = ByteBuffer.allocate(byteSize);\n    bitmap.copyPixelsToBuffer(byteBuffer);  \n\n    // Get the byteArray.\n    byte[] byteArray = byteBuffer.array();\n\n    // Get the ByteArrayInputStream.\n    ByteArrayInputStream bs = new ByteArrayInputStream(byteArray);\n```\n\n\n","source":"_posts/Android图片压缩.md","raw":"\n---\ntitle: Android图片压缩\ndate: 2017-02-23 21:49:15\ntags: Android\ncategories: Android\n---\n\n> 本文讲解了Android Compress image的方式，主要从**图片的存在形式**、**检测图片大小的方法**、**压缩方式**、**数据对比**等方面阐述了压缩方案。\n\n<!-- more -->\n\n\n## 图片的存在形式\n1. **文件形式**（即以二进制形式存在于硬盘上）\n2. **流的形式** （即以二进制形式存在于内存中）\n3. **Bitmap形式**\n\n>  **区别：**文件形式和流的形式对图片体积大小没有影响，也就是说，如果图片在手机SD卡上的大小是100KB，那么通过流的形式读到内存中，也是占用100KB的大小，注意是流的形式，不是bitmap的形式；当图片以Bitmap的形式存在时，其占用的内存会瞬间变大，曾经试过把500KB左右的图片加载到内存中，以Bitmap形式存在时，内存占用近10MB，当然这个增大的倍数不是固定的。\n\n## 检测图片大小的方法\n1. **文件形式** file.length( )\n2. **流的形式** 将图片文件读到内存输入流中，看它的byte数\n3. **Bitmap** bitmap.getByteCount( )\n\n## 压缩方式\n\n### 质量压缩\n\n`bitmap.compress(CompressFormat,quality,outputstream)`\n1. 第一个参数是个枚举类CompressFormat，主要有JPEG，PNG，WEBP三种类型，一般使用JPEG；\n2. 第二个参数是压缩质量，取值0-100之间，100代表质量最高，0代表最低；\n3. 第三个参数是输出流，可把图片字节流保存成指定文件。\n使用实例：\n\n```java\n    public static void compressBmpToFile(Bitmap bmp, File file) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int options = 80;// 压缩质量从80开始 \n        bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);\n        while (baos.toByteArray().length / 1024 > 100) { // 如果大于100KB时，压缩质量-10；  \n            baos.reset();\n            options -= 10;\n            bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);\n        }\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baos.toByteArray());\n            fos.flush();\n            fos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n**方法说明：**该方法是压缩图片的质量，*但并不会减少图片的像素*，比如，图片是800KB 1008x756像素的，经该方法压缩后，File形式的图片是在100KB左右，以方便上传服务器，但是BitmapFactory.decodeFile( )到内存中变成bitmap时，它的像素值仍然是1008x756，计算图片像素的方法是bitmap.getWidth( )和bitmap.getHeight( )，图片是由像素组成的，每个像素又包含什么呢？熟悉PS的人都知道，图片是有色相，明度和饱和度构成的。\n\n该方法也是Google官方文档解释说，它会让图片重新构造，但是有可能图片的位深（既色深）和每个像素的透明度会变化，JPEG only supports opaque(不透明)，也就是说jpeg格式压缩后，原来图片中透明的元素将会消失，所以这种格式很可能造成失真。 \n\n既然它是改变了图片的显示质量，达到了对File形式的图片进行压缩，图片的像素没有改变的话，重新读取经过压缩file为bitmap时，它占用的内存并不会减少。\n\n因为：bitmap.getByteCount( )是计算它的像素所占用的内存，请看官方解释：Returns the number of bytes used to store this bitmap's pixels.\n\n### 像素压缩\n\n**特点：**通过设置采样率，减少图片的像素，即图片从File形式变成Bitmap形式\n\n先看一个方法: 该方法是对内存中的Bitmap进行质量上的压缩, 由上面的理论可以得出该方法是无效的, 而且也是没有必要的,因为你已经将它读到内存中了,再压缩多此一举, 尽管在获取系统相册图片时,某些手机会直接返回一个Bitmap,但是这种情况下, 返回的Bitmap都是经过压缩的, 它不可能直接返回一个原声的Bitmap形式的图片, 后果可想而知。\n\n```java\n    private Bitmap compressBmpFromBmp(Bitmap image) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int options = 100;\n        image.compress(Bitmap.CompressFormat.JPEG, 100, baos);\n        while (baos.toByteArray().length / 1024 > 100) {\n            baos.reset();\n            options -= 10;\n            image.compress(Bitmap.CompressFormat.JPEG, options, baos);\n        }\n        ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());\n        Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);\n        return bitmap;\n    }\n\n```\n\n再看一个方法:\n\n```java\n    private Bitmap compressImageFromFile(String srcPath) {\n        BitmapFactory.Options newOpts = new BitmapFactory.Options();\n        newOpts.inJustDecodeBounds = true;//只读边,不读内容  \n        Bitmap bitmap = BitmapFactory.decodeFile(srcPath, newOpts);\n\n        newOpts.inJustDecodeBounds = false;\n        int w = newOpts.outWidth;\n        int h = newOpts.outHeight;\n        float hh = 800f;//  \n        float ww = 480f;//  \n        int be = 1;\n        if (w > h && w > ww) {\n            be = (int) (newOpts.outWidth / ww);\n        } else if (w < h && h > hh) {\n            be = (int) (newOpts.outHeight / hh);\n        }\n        if (be <= 0)\n            be = 1;\n        newOpts.inSampleSize = be;//设置采样率  \n\n        newOpts.inPreferredConfig = Config.ARGB_8888;//该模式是默认的,可不设  \n        newOpts.inPurgeable = true;// 同时设置才会有效  \n        newOpts.inInputShareable = true;//。当系统内存不够时候图片自动被回收  \n\n        bitmap = BitmapFactory.decodeFile(srcPath, newOpts);\n        // return compressBmpFromBmp(bitmap);//原来的方法调用了这个方法企图进行二次压缩  \n        // 其实是无效的,大家尽管尝试  \n        return bitmap;\n    }\n\n```\n\n###  压缩终极方案，修改libjpeg图像库，使用c库来保存bitmap到file\n\n* [[Android算法] android图片压缩终极解决方案](http://www.see-source.com/blog/300000022/684.html)\n* [为什么Android的图片质量会比iPhone的差？](http://www.cnblogs.com/MaxIE/p/3951294.html)\n* [github demo](https://github.com/bither/bither-android-lib)\n\n> 以上是参考文章和修改libjpeg图像库的demo，本人亲自试了下，没有像介绍的那样可靠，也有可能不同ROM是否已经修复了此bug？暂时还不得而知，需要在此验证。\n\n### 数据对比\n\n**默认使用的位图配置是ARGB_8888**，图片加载到内存大小3456x4608x4字节约等于60.75MB，直接加载会OOM，需要进行长宽压缩 + 像素质量压缩。\n> 原图大小 5.21MB 3456x4608px，缩小4时，quality = 80，864x1152px\n\n|   origin  |   jpegTrue    |   jpegFalse   |   sampleSize  |   quality | \n|   :--:        |   :--:            |   :--:            |   :--:                |   :--:        | \n|145.75KB|      -           |   -               |   4                   | 80            |       \n|               |   141.63KB |  -               |   4                   | 80            |  \n|               |                   |  144.79KB  |  4                   | 80            |\n\n| origin            |    jpegTrue |     jpegFalse  | sampleSize | quality | \n|   :--:            |   :--:            |       :--:         |  :--:                |   :--:      | \n| 706.34KB  |   -               |       -           |   4                   | 100        |      \n|                  |    629.34KB |          -           |   4                   | 100        |  \n|                  |                     |      661.51KB |  4                   | 100        |\n\n\n| origin            |    jpegTrue |     jpegFalse  | sampleSize | quality   | \n| :--:              | :--:              |       :--:         |  :--:                |   :--:        | \n| 8.71MB        |   -               |       -           |   1                   | 100       |       \n|                  |    7.13MB  |       -           |   1                   | 100       |  \n|                  |                    |   7.62MB  |   1                   | 100       |\n\n| origin            |    jpegTrue |     jpegFalse  | sampleSize | quality  | \n| :--:              |       :--:          |         :--:         |  :--:                |   :--:      | \n| 1.43MB        |       -           |       -           |   1                   | 80          |     \n|                  |    1.34MB  |       -           |   1                   | 80          |  \n|                  |                    |   1.41MB  |   1                   | 80          |\n\n\n-------\n\n> Transform a bitmap into an input stream \n\n```java\n    // Your Bitmap.\n    Bitmap bitmap = XXX;  \n\n    int byteSize = bitmap.getRowBytes() * bitmap.getHeight();\n    //int byteSize = bitmap.getByteCount();\n    ByteBuffer byteBuffer = ByteBuffer.allocate(byteSize);\n    bitmap.copyPixelsToBuffer(byteBuffer);  \n\n    // Get the byteArray.\n    byte[] byteArray = byteBuffer.array();\n\n    // Get the ByteArrayInputStream.\n    ByteArrayInputStream bs = new ByteArrayInputStream(byteArray);\n```\n\n\n","slug":"Android图片压缩","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4veu000en2cb8viocqq7","content":"<blockquote>\n<p>本文讲解了Android Compress image的方式，主要从<strong>图片的存在形式</strong>、<strong>检测图片大小的方法</strong>、<strong>压缩方式</strong>、<strong>数据对比</strong>等方面阐述了压缩方案。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"图片的存在形式\"><a href=\"#图片的存在形式\" class=\"headerlink\" title=\"图片的存在形式\"></a>图片的存在形式</h2><ol>\n<li><strong>文件形式</strong>（即以二进制形式存在于硬盘上）</li>\n<li><strong>流的形式</strong> （即以二进制形式存在于内存中）</li>\n<li><strong>Bitmap形式</strong></li>\n</ol>\n<blockquote>\n<p> <strong>区别：</strong>文件形式和流的形式对图片体积大小没有影响，也就是说，如果图片在手机SD卡上的大小是100KB，那么通过流的形式读到内存中，也是占用100KB的大小，注意是流的形式，不是bitmap的形式；当图片以Bitmap的形式存在时，其占用的内存会瞬间变大，曾经试过把500KB左右的图片加载到内存中，以Bitmap形式存在时，内存占用近10MB，当然这个增大的倍数不是固定的。</p>\n</blockquote>\n<h2 id=\"检测图片大小的方法\"><a href=\"#检测图片大小的方法\" class=\"headerlink\" title=\"检测图片大小的方法\"></a>检测图片大小的方法</h2><ol>\n<li><strong>文件形式</strong> file.length( )</li>\n<li><strong>流的形式</strong> 将图片文件读到内存输入流中，看它的byte数</li>\n<li><strong>Bitmap</strong> bitmap.getByteCount( )</li>\n</ol>\n<h2 id=\"压缩方式\"><a href=\"#压缩方式\" class=\"headerlink\" title=\"压缩方式\"></a>压缩方式</h2><h3 id=\"质量压缩\"><a href=\"#质量压缩\" class=\"headerlink\" title=\"质量压缩\"></a>质量压缩</h3><p><code>bitmap.compress(CompressFormat,quality,outputstream)</code></p>\n<ol>\n<li>第一个参数是个枚举类CompressFormat，主要有JPEG，PNG，WEBP三种类型，一般使用JPEG；</li>\n<li>第二个参数是压缩质量，取值0-100之间，100代表质量最高，0代表最低；</li>\n<li>第三个参数是输出流，可把图片字节流保存成指定文件。<br>使用实例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">compressBmpToFile</span><span class=\"params\">(Bitmap bmp, File file)</span> </span>&#123;</span><br><span class=\"line\">    ByteArrayOutputStream baos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> options = <span class=\"number\">80</span>;<span class=\"comment\">// 压缩质量从80开始 </span></span><br><span class=\"line\">    bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (baos.toByteArray().length / <span class=\"number\">1024</span> &gt; <span class=\"number\">100</span>) &#123; <span class=\"comment\">// 如果大于100KB时，压缩质量-10；  </span></span><br><span class=\"line\">        baos.reset();</span><br><span class=\"line\">        options -= <span class=\"number\">10</span>;</span><br><span class=\"line\">        bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        FileOutputStream fos = <span class=\"keyword\">new</span> FileOutputStream(file);</span><br><span class=\"line\">        fos.write(baos.toByteArray());</span><br><span class=\"line\">        fos.flush();</span><br><span class=\"line\">        fos.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>方法说明：</strong>该方法是压缩图片的质量，<em>但并不会减少图片的像素</em>，比如，图片是800KB 1008x756像素的，经该方法压缩后，File形式的图片是在100KB左右，以方便上传服务器，但是BitmapFactory.decodeFile( )到内存中变成bitmap时，它的像素值仍然是1008x756，计算图片像素的方法是bitmap.getWidth( )和bitmap.getHeight( )，图片是由像素组成的，每个像素又包含什么呢？熟悉PS的人都知道，图片是有色相，明度和饱和度构成的。</p>\n<p>该方法也是Google官方文档解释说，它会让图片重新构造，但是有可能图片的位深（既色深）和每个像素的透明度会变化，JPEG only supports opaque(不透明)，也就是说jpeg格式压缩后，原来图片中透明的元素将会消失，所以这种格式很可能造成失真。 </p>\n<p>既然它是改变了图片的显示质量，达到了对File形式的图片进行压缩，图片的像素没有改变的话，重新读取经过压缩file为bitmap时，它占用的内存并不会减少。</p>\n<p>因为：bitmap.getByteCount( )是计算它的像素所占用的内存，请看官方解释：Returns the number of bytes used to store this bitmap’s pixels.</p>\n<h3 id=\"像素压缩\"><a href=\"#像素压缩\" class=\"headerlink\" title=\"像素压缩\"></a>像素压缩</h3><p><strong>特点：</strong>通过设置采样率，减少图片的像素，即图片从File形式变成Bitmap形式</p>\n<p>先看一个方法: 该方法是对内存中的Bitmap进行质量上的压缩, 由上面的理论可以得出该方法是无效的, 而且也是没有必要的,因为你已经将它读到内存中了,再压缩多此一举, 尽管在获取系统相册图片时,某些手机会直接返回一个Bitmap,但是这种情况下, 返回的Bitmap都是经过压缩的, 它不可能直接返回一个原声的Bitmap形式的图片, 后果可想而知。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Bitmap <span class=\"title\">compressBmpFromBmp</span><span class=\"params\">(Bitmap image)</span> </span>&#123;</span><br><span class=\"line\">    ByteArrayOutputStream baos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> options = <span class=\"number\">100</span>;</span><br><span class=\"line\">    image.compress(Bitmap.CompressFormat.JPEG, <span class=\"number\">100</span>, baos);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (baos.toByteArray().length / <span class=\"number\">1024</span> &gt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">        baos.reset();</span><br><span class=\"line\">        options -= <span class=\"number\">10</span>;</span><br><span class=\"line\">        image.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ByteArrayInputStream isBm = <span class=\"keyword\">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class=\"line\">    Bitmap bitmap = BitmapFactory.decodeStream(isBm, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bitmap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看一个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Bitmap <span class=\"title\">compressImageFromFile</span><span class=\"params\">(String srcPath)</span> </span>&#123;</span><br><span class=\"line\">    BitmapFactory.Options newOpts = <span class=\"keyword\">new</span> BitmapFactory.Options();</span><br><span class=\"line\">    newOpts.inJustDecodeBounds = <span class=\"keyword\">true</span>;<span class=\"comment\">//只读边,不读内容  </span></span><br><span class=\"line\">    Bitmap bitmap = BitmapFactory.decodeFile(srcPath, newOpts);</span><br><span class=\"line\"></span><br><span class=\"line\">    newOpts.inJustDecodeBounds = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> w = newOpts.outWidth;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = newOpts.outHeight;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> hh = <span class=\"number\">800f</span>;<span class=\"comment\">//  </span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> ww = <span class=\"number\">480f</span>;<span class=\"comment\">//  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> be = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (w &gt; h &amp;&amp; w &gt; ww) &#123;</span><br><span class=\"line\">        be = (<span class=\"keyword\">int</span>) (newOpts.outWidth / ww);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (w &lt; h &amp;&amp; h &gt; hh) &#123;</span><br><span class=\"line\">        be = (<span class=\"keyword\">int</span>) (newOpts.outHeight / hh);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (be &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        be = <span class=\"number\">1</span>;</span><br><span class=\"line\">    newOpts.inSampleSize = be;<span class=\"comment\">//设置采样率  </span></span><br><span class=\"line\"></span><br><span class=\"line\">    newOpts.inPreferredConfig = Config.ARGB_8888;<span class=\"comment\">//该模式是默认的,可不设  </span></span><br><span class=\"line\">    newOpts.inPurgeable = <span class=\"keyword\">true</span>;<span class=\"comment\">// 同时设置才会有效  </span></span><br><span class=\"line\">    newOpts.inInputShareable = <span class=\"keyword\">true</span>;<span class=\"comment\">//。当系统内存不够时候图片自动被回收  </span></span><br><span class=\"line\"></span><br><span class=\"line\">    bitmap = BitmapFactory.decodeFile(srcPath, newOpts);</span><br><span class=\"line\">    <span class=\"comment\">// return compressBmpFromBmp(bitmap);//原来的方法调用了这个方法企图进行二次压缩  </span></span><br><span class=\"line\">    <span class=\"comment\">// 其实是无效的,大家尽管尝试  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bitmap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"压缩终极方案，修改libjpeg图像库，使用c库来保存bitmap到file\"><a href=\"#压缩终极方案，修改libjpeg图像库，使用c库来保存bitmap到file\" class=\"headerlink\" title=\"压缩终极方案，修改libjpeg图像库，使用c库来保存bitmap到file\"></a>压缩终极方案，修改libjpeg图像库，使用c库来保存bitmap到file</h3><ul>\n<li><a href=\"http://www.see-source.com/blog/300000022/684.html\" target=\"_blank\" rel=\"noopener\">[Android算法] android图片压缩终极解决方案</a></li>\n<li><a href=\"http://www.cnblogs.com/MaxIE/p/3951294.html\" target=\"_blank\" rel=\"noopener\">为什么Android的图片质量会比iPhone的差？</a></li>\n<li><a href=\"https://github.com/bither/bither-android-lib\" target=\"_blank\" rel=\"noopener\">github demo</a></li>\n</ul>\n<blockquote>\n<p>以上是参考文章和修改libjpeg图像库的demo，本人亲自试了下，没有像介绍的那样可靠，也有可能不同ROM是否已经修复了此bug？暂时还不得而知，需要在此验证。</p>\n</blockquote>\n<h3 id=\"数据对比\"><a href=\"#数据对比\" class=\"headerlink\" title=\"数据对比\"></a>数据对比</h3><p><strong>默认使用的位图配置是ARGB_8888</strong>，图片加载到内存大小3456x4608x4字节约等于60.75MB，直接加载会OOM，需要进行长宽压缩 + 像素质量压缩。</p>\n<blockquote>\n<p>原图大小 5.21MB 3456x4608px，缩小4时，quality = 80，864x1152px</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">origin</th>\n<th style=\"text-align:center\">jpegTrue</th>\n<th style=\"text-align:center\">jpegFalse</th>\n<th style=\"text-align:center\">sampleSize</th>\n<th style=\"text-align:center\">quality</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">145.75KB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">80</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">141.63KB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">80</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">144.79KB</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">80</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">origin</th>\n<th style=\"text-align:center\">jpegTrue</th>\n<th style=\"text-align:center\">jpegFalse</th>\n<th style=\"text-align:center\">sampleSize</th>\n<th style=\"text-align:center\">quality</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">706.34KB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">629.34KB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">661.51KB</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">origin</th>\n<th style=\"text-align:center\">jpegTrue</th>\n<th style=\"text-align:center\">jpegFalse</th>\n<th style=\"text-align:center\">sampleSize</th>\n<th style=\"text-align:center\">quality</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">8.71MB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">7.13MB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">7.62MB</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">origin</th>\n<th style=\"text-align:center\">jpegTrue</th>\n<th style=\"text-align:center\">jpegFalse</th>\n<th style=\"text-align:center\">sampleSize</th>\n<th style=\"text-align:center\">quality</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1.43MB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">80</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">1.34MB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">80</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">1.41MB</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">80</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<blockquote>\n<p>Transform a bitmap into an input stream </p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Your Bitmap.</span></span><br><span class=\"line\">Bitmap bitmap = XXX;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> byteSize = bitmap.getRowBytes() * bitmap.getHeight();</span><br><span class=\"line\"><span class=\"comment\">//int byteSize = bitmap.getByteCount();</span></span><br><span class=\"line\">ByteBuffer byteBuffer = ByteBuffer.allocate(byteSize);</span><br><span class=\"line\">bitmap.copyPixelsToBuffer(byteBuffer);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get the byteArray.</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] byteArray = byteBuffer.array();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get the ByteArrayInputStream.</span></span><br><span class=\"line\">ByteArrayInputStream bs = <span class=\"keyword\">new</span> ByteArrayInputStream(byteArray);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文讲解了Android Compress image的方式，主要从<strong>图片的存在形式</strong>、<strong>检测图片大小的方法</strong>、<strong>压缩方式</strong>、<strong>数据对比</strong>等方面阐述了压缩方案。</p>\n</blockquote>","more":"<h2 id=\"图片的存在形式\"><a href=\"#图片的存在形式\" class=\"headerlink\" title=\"图片的存在形式\"></a>图片的存在形式</h2><ol>\n<li><strong>文件形式</strong>（即以二进制形式存在于硬盘上）</li>\n<li><strong>流的形式</strong> （即以二进制形式存在于内存中）</li>\n<li><strong>Bitmap形式</strong></li>\n</ol>\n<blockquote>\n<p> <strong>区别：</strong>文件形式和流的形式对图片体积大小没有影响，也就是说，如果图片在手机SD卡上的大小是100KB，那么通过流的形式读到内存中，也是占用100KB的大小，注意是流的形式，不是bitmap的形式；当图片以Bitmap的形式存在时，其占用的内存会瞬间变大，曾经试过把500KB左右的图片加载到内存中，以Bitmap形式存在时，内存占用近10MB，当然这个增大的倍数不是固定的。</p>\n</blockquote>\n<h2 id=\"检测图片大小的方法\"><a href=\"#检测图片大小的方法\" class=\"headerlink\" title=\"检测图片大小的方法\"></a>检测图片大小的方法</h2><ol>\n<li><strong>文件形式</strong> file.length( )</li>\n<li><strong>流的形式</strong> 将图片文件读到内存输入流中，看它的byte数</li>\n<li><strong>Bitmap</strong> bitmap.getByteCount( )</li>\n</ol>\n<h2 id=\"压缩方式\"><a href=\"#压缩方式\" class=\"headerlink\" title=\"压缩方式\"></a>压缩方式</h2><h3 id=\"质量压缩\"><a href=\"#质量压缩\" class=\"headerlink\" title=\"质量压缩\"></a>质量压缩</h3><p><code>bitmap.compress(CompressFormat,quality,outputstream)</code></p>\n<ol>\n<li>第一个参数是个枚举类CompressFormat，主要有JPEG，PNG，WEBP三种类型，一般使用JPEG；</li>\n<li>第二个参数是压缩质量，取值0-100之间，100代表质量最高，0代表最低；</li>\n<li>第三个参数是输出流，可把图片字节流保存成指定文件。<br>使用实例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">compressBmpToFile</span><span class=\"params\">(Bitmap bmp, File file)</span> </span>&#123;</span><br><span class=\"line\">    ByteArrayOutputStream baos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> options = <span class=\"number\">80</span>;<span class=\"comment\">// 压缩质量从80开始 </span></span><br><span class=\"line\">    bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (baos.toByteArray().length / <span class=\"number\">1024</span> &gt; <span class=\"number\">100</span>) &#123; <span class=\"comment\">// 如果大于100KB时，压缩质量-10；  </span></span><br><span class=\"line\">        baos.reset();</span><br><span class=\"line\">        options -= <span class=\"number\">10</span>;</span><br><span class=\"line\">        bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        FileOutputStream fos = <span class=\"keyword\">new</span> FileOutputStream(file);</span><br><span class=\"line\">        fos.write(baos.toByteArray());</span><br><span class=\"line\">        fos.flush();</span><br><span class=\"line\">        fos.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>方法说明：</strong>该方法是压缩图片的质量，<em>但并不会减少图片的像素</em>，比如，图片是800KB 1008x756像素的，经该方法压缩后，File形式的图片是在100KB左右，以方便上传服务器，但是BitmapFactory.decodeFile( )到内存中变成bitmap时，它的像素值仍然是1008x756，计算图片像素的方法是bitmap.getWidth( )和bitmap.getHeight( )，图片是由像素组成的，每个像素又包含什么呢？熟悉PS的人都知道，图片是有色相，明度和饱和度构成的。</p>\n<p>该方法也是Google官方文档解释说，它会让图片重新构造，但是有可能图片的位深（既色深）和每个像素的透明度会变化，JPEG only supports opaque(不透明)，也就是说jpeg格式压缩后，原来图片中透明的元素将会消失，所以这种格式很可能造成失真。 </p>\n<p>既然它是改变了图片的显示质量，达到了对File形式的图片进行压缩，图片的像素没有改变的话，重新读取经过压缩file为bitmap时，它占用的内存并不会减少。</p>\n<p>因为：bitmap.getByteCount( )是计算它的像素所占用的内存，请看官方解释：Returns the number of bytes used to store this bitmap’s pixels.</p>\n<h3 id=\"像素压缩\"><a href=\"#像素压缩\" class=\"headerlink\" title=\"像素压缩\"></a>像素压缩</h3><p><strong>特点：</strong>通过设置采样率，减少图片的像素，即图片从File形式变成Bitmap形式</p>\n<p>先看一个方法: 该方法是对内存中的Bitmap进行质量上的压缩, 由上面的理论可以得出该方法是无效的, 而且也是没有必要的,因为你已经将它读到内存中了,再压缩多此一举, 尽管在获取系统相册图片时,某些手机会直接返回一个Bitmap,但是这种情况下, 返回的Bitmap都是经过压缩的, 它不可能直接返回一个原声的Bitmap形式的图片, 后果可想而知。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Bitmap <span class=\"title\">compressBmpFromBmp</span><span class=\"params\">(Bitmap image)</span> </span>&#123;</span><br><span class=\"line\">    ByteArrayOutputStream baos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> options = <span class=\"number\">100</span>;</span><br><span class=\"line\">    image.compress(Bitmap.CompressFormat.JPEG, <span class=\"number\">100</span>, baos);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (baos.toByteArray().length / <span class=\"number\">1024</span> &gt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">        baos.reset();</span><br><span class=\"line\">        options -= <span class=\"number\">10</span>;</span><br><span class=\"line\">        image.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ByteArrayInputStream isBm = <span class=\"keyword\">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class=\"line\">    Bitmap bitmap = BitmapFactory.decodeStream(isBm, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bitmap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看一个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Bitmap <span class=\"title\">compressImageFromFile</span><span class=\"params\">(String srcPath)</span> </span>&#123;</span><br><span class=\"line\">    BitmapFactory.Options newOpts = <span class=\"keyword\">new</span> BitmapFactory.Options();</span><br><span class=\"line\">    newOpts.inJustDecodeBounds = <span class=\"keyword\">true</span>;<span class=\"comment\">//只读边,不读内容  </span></span><br><span class=\"line\">    Bitmap bitmap = BitmapFactory.decodeFile(srcPath, newOpts);</span><br><span class=\"line\"></span><br><span class=\"line\">    newOpts.inJustDecodeBounds = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> w = newOpts.outWidth;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = newOpts.outHeight;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> hh = <span class=\"number\">800f</span>;<span class=\"comment\">//  </span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> ww = <span class=\"number\">480f</span>;<span class=\"comment\">//  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> be = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (w &gt; h &amp;&amp; w &gt; ww) &#123;</span><br><span class=\"line\">        be = (<span class=\"keyword\">int</span>) (newOpts.outWidth / ww);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (w &lt; h &amp;&amp; h &gt; hh) &#123;</span><br><span class=\"line\">        be = (<span class=\"keyword\">int</span>) (newOpts.outHeight / hh);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (be &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        be = <span class=\"number\">1</span>;</span><br><span class=\"line\">    newOpts.inSampleSize = be;<span class=\"comment\">//设置采样率  </span></span><br><span class=\"line\"></span><br><span class=\"line\">    newOpts.inPreferredConfig = Config.ARGB_8888;<span class=\"comment\">//该模式是默认的,可不设  </span></span><br><span class=\"line\">    newOpts.inPurgeable = <span class=\"keyword\">true</span>;<span class=\"comment\">// 同时设置才会有效  </span></span><br><span class=\"line\">    newOpts.inInputShareable = <span class=\"keyword\">true</span>;<span class=\"comment\">//。当系统内存不够时候图片自动被回收  </span></span><br><span class=\"line\"></span><br><span class=\"line\">    bitmap = BitmapFactory.decodeFile(srcPath, newOpts);</span><br><span class=\"line\">    <span class=\"comment\">// return compressBmpFromBmp(bitmap);//原来的方法调用了这个方法企图进行二次压缩  </span></span><br><span class=\"line\">    <span class=\"comment\">// 其实是无效的,大家尽管尝试  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bitmap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"压缩终极方案，修改libjpeg图像库，使用c库来保存bitmap到file\"><a href=\"#压缩终极方案，修改libjpeg图像库，使用c库来保存bitmap到file\" class=\"headerlink\" title=\"压缩终极方案，修改libjpeg图像库，使用c库来保存bitmap到file\"></a>压缩终极方案，修改libjpeg图像库，使用c库来保存bitmap到file</h3><ul>\n<li><a href=\"http://www.see-source.com/blog/300000022/684.html\" target=\"_blank\" rel=\"noopener\">[Android算法] android图片压缩终极解决方案</a></li>\n<li><a href=\"http://www.cnblogs.com/MaxIE/p/3951294.html\" target=\"_blank\" rel=\"noopener\">为什么Android的图片质量会比iPhone的差？</a></li>\n<li><a href=\"https://github.com/bither/bither-android-lib\" target=\"_blank\" rel=\"noopener\">github demo</a></li>\n</ul>\n<blockquote>\n<p>以上是参考文章和修改libjpeg图像库的demo，本人亲自试了下，没有像介绍的那样可靠，也有可能不同ROM是否已经修复了此bug？暂时还不得而知，需要在此验证。</p>\n</blockquote>\n<h3 id=\"数据对比\"><a href=\"#数据对比\" class=\"headerlink\" title=\"数据对比\"></a>数据对比</h3><p><strong>默认使用的位图配置是ARGB_8888</strong>，图片加载到内存大小3456x4608x4字节约等于60.75MB，直接加载会OOM，需要进行长宽压缩 + 像素质量压缩。</p>\n<blockquote>\n<p>原图大小 5.21MB 3456x4608px，缩小4时，quality = 80，864x1152px</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">origin</th>\n<th style=\"text-align:center\">jpegTrue</th>\n<th style=\"text-align:center\">jpegFalse</th>\n<th style=\"text-align:center\">sampleSize</th>\n<th style=\"text-align:center\">quality</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">145.75KB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">80</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">141.63KB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">80</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">144.79KB</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">80</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">origin</th>\n<th style=\"text-align:center\">jpegTrue</th>\n<th style=\"text-align:center\">jpegFalse</th>\n<th style=\"text-align:center\">sampleSize</th>\n<th style=\"text-align:center\">quality</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">706.34KB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">629.34KB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">661.51KB</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">origin</th>\n<th style=\"text-align:center\">jpegTrue</th>\n<th style=\"text-align:center\">jpegFalse</th>\n<th style=\"text-align:center\">sampleSize</th>\n<th style=\"text-align:center\">quality</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">8.71MB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">7.13MB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">7.62MB</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">100</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">origin</th>\n<th style=\"text-align:center\">jpegTrue</th>\n<th style=\"text-align:center\">jpegFalse</th>\n<th style=\"text-align:center\">sampleSize</th>\n<th style=\"text-align:center\">quality</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1.43MB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">80</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">1.34MB</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">80</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">1.41MB</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">80</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<blockquote>\n<p>Transform a bitmap into an input stream </p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Your Bitmap.</span></span><br><span class=\"line\">Bitmap bitmap = XXX;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> byteSize = bitmap.getRowBytes() * bitmap.getHeight();</span><br><span class=\"line\"><span class=\"comment\">//int byteSize = bitmap.getByteCount();</span></span><br><span class=\"line\">ByteBuffer byteBuffer = ByteBuffer.allocate(byteSize);</span><br><span class=\"line\">bitmap.copyPixelsToBuffer(byteBuffer);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get the byteArray.</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] byteArray = byteBuffer.array();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get the ByteArrayInputStream.</span></span><br><span class=\"line\">ByteArrayInputStream bs = <span class=\"keyword\">new</span> ByteArrayInputStream(byteArray);</span><br></pre></td></tr></table></figure>"},{"title":"Github Tips之Git","date":"2018-08-04T05:34:06.000Z","_content":"\n\n> Github是为开发者提供Git仓库的托管服务，是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。除了Git仓库的托管服务外，还为开发者和团队提供了一系列功能，帮助其提高效率、高品质地进行代码编写。本文将讲解一些关于Github Git的使用。\n\n<img src=\"http://wanghaoxun.com/github_logo.png\" width=\"60%\" height=\"30%\">\n\n<!-- more -->\n\n\n## Git\n* git diff HEAD 查看本次提交与上次提交之间有什么差别\n* git checkout - 切换回前一个分支\n* git merge 合并分支，git merge --no-ff feature-A  为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交\n* git log --graph 以图表形式查看分支\n* git reset --hard SHA-1 回退到某次提交\n* git reflog 查看以当前状态为终点的历史日志，\n* git commit -am \"Add feature-C\" -am命令来一次完成两步操作\n* git rebase -i HEAD~1 选定当前分支中包含HEAD（最新提交）在内的2个最新历史记录为对象，并在编辑器中打开，在编辑器中修改命令参数，使用fixup即可，然后保存退出vim即可\n\n![git rebase合并历史示例图](http://wanghaoxun.com/git_rebase.jpeg)\n\n* git remote show origin 显示当前远端仓库地址\n* git format-path 前一次commit hash -o ~/Downloads/nelson/script/\n* git apply --reject ~/Downloads/nelson/script/path.patch\n\n## Q & A\n\n1. git add . -A -u 区别？\n\n* git add -u：(保存修改和删除，但是不包括新建文件) - 将文件的修改、文件的删除，添加到暂存区。update\n* git add .：(保存新的添加和修改，但是不包括删除) - 将文件的修改，文件的新建，添加到暂存区。\n* git add -A：(保存所有的修改) - 将文件的修改，文件的删除，文件的新建，添加到暂存区。\n\n","source":"_posts/Github-Tips之Git.md","raw":"---\ntitle: Github Tips之Git\ndate: 2018-08-04 13:34:06\ntags: Github\ncategories: Github\n---\n\n\n> Github是为开发者提供Git仓库的托管服务，是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。除了Git仓库的托管服务外，还为开发者和团队提供了一系列功能，帮助其提高效率、高品质地进行代码编写。本文将讲解一些关于Github Git的使用。\n\n<img src=\"http://wanghaoxun.com/github_logo.png\" width=\"60%\" height=\"30%\">\n\n<!-- more -->\n\n\n## Git\n* git diff HEAD 查看本次提交与上次提交之间有什么差别\n* git checkout - 切换回前一个分支\n* git merge 合并分支，git merge --no-ff feature-A  为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交\n* git log --graph 以图表形式查看分支\n* git reset --hard SHA-1 回退到某次提交\n* git reflog 查看以当前状态为终点的历史日志，\n* git commit -am \"Add feature-C\" -am命令来一次完成两步操作\n* git rebase -i HEAD~1 选定当前分支中包含HEAD（最新提交）在内的2个最新历史记录为对象，并在编辑器中打开，在编辑器中修改命令参数，使用fixup即可，然后保存退出vim即可\n\n![git rebase合并历史示例图](http://wanghaoxun.com/git_rebase.jpeg)\n\n* git remote show origin 显示当前远端仓库地址\n* git format-path 前一次commit hash -o ~/Downloads/nelson/script/\n* git apply --reject ~/Downloads/nelson/script/path.patch\n\n## Q & A\n\n1. git add . -A -u 区别？\n\n* git add -u：(保存修改和删除，但是不包括新建文件) - 将文件的修改、文件的删除，添加到暂存区。update\n* git add .：(保存新的添加和修改，但是不包括删除) - 将文件的修改，文件的新建，添加到暂存区。\n* git add -A：(保存所有的修改) - 将文件的修改，文件的删除，文件的新建，添加到暂存区。\n\n","slug":"Github-Tips之Git","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vew000jn2cb6bmnnde3","content":"<blockquote>\n<p>Github是为开发者提供Git仓库的托管服务，是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。除了Git仓库的托管服务外，还为开发者和团队提供了一系列功能，帮助其提高效率、高品质地进行代码编写。本文将讲解一些关于Github Git的使用。</p>\n</blockquote>\n<p><img src=\"http://wanghaoxun.com/github_logo.png\" width=\"60%\" height=\"30%\"></p>\n<a id=\"more\"></a>\n<h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><ul>\n<li>git diff HEAD 查看本次提交与上次提交之间有什么差别</li>\n<li>git checkout - 切换回前一个分支</li>\n<li>git merge 合并分支，git merge –no-ff feature-A  为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交</li>\n<li>git log –graph 以图表形式查看分支</li>\n<li>git reset –hard SHA-1 回退到某次提交</li>\n<li>git reflog 查看以当前状态为终点的历史日志，</li>\n<li>git commit -am “Add feature-C” -am命令来一次完成两步操作</li>\n<li>git rebase -i HEAD~1 选定当前分支中包含HEAD（最新提交）在内的2个最新历史记录为对象，并在编辑器中打开，在编辑器中修改命令参数，使用fixup即可，然后保存退出vim即可</li>\n</ul>\n<p><img src=\"http://wanghaoxun.com/git_rebase.jpeg\" alt=\"git rebase合并历史示例图\"></p>\n<ul>\n<li>git remote show origin 显示当前远端仓库地址</li>\n<li>git format-path 前一次commit hash -o ~/Downloads/nelson/script/</li>\n<li>git apply –reject ~/Downloads/nelson/script/path.patch</li>\n</ul>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q &amp; A\"></a>Q &amp; A</h2><ol>\n<li>git add . -A -u 区别？</li>\n</ol>\n<ul>\n<li>git add -u：(保存修改和删除，但是不包括新建文件) - 将文件的修改、文件的删除，添加到暂存区。update</li>\n<li>git add .：(保存新的添加和修改，但是不包括删除) - 将文件的修改，文件的新建，添加到暂存区。</li>\n<li>git add -A：(保存所有的修改) - 将文件的修改，文件的删除，文件的新建，添加到暂存区。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Github是为开发者提供Git仓库的托管服务，是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。除了Git仓库的托管服务外，还为开发者和团队提供了一系列功能，帮助其提高效率、高品质地进行代码编写。本文将讲解一些关于Github Git的使用。</p>\n</blockquote>\n<p><img src=\"http://wanghaoxun.com/github_logo.png\" width=\"60%\" height=\"30%\"></p>","more":"<h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><ul>\n<li>git diff HEAD 查看本次提交与上次提交之间有什么差别</li>\n<li>git checkout - 切换回前一个分支</li>\n<li>git merge 合并分支，git merge –no-ff feature-A  为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交</li>\n<li>git log –graph 以图表形式查看分支</li>\n<li>git reset –hard SHA-1 回退到某次提交</li>\n<li>git reflog 查看以当前状态为终点的历史日志，</li>\n<li>git commit -am “Add feature-C” -am命令来一次完成两步操作</li>\n<li>git rebase -i HEAD~1 选定当前分支中包含HEAD（最新提交）在内的2个最新历史记录为对象，并在编辑器中打开，在编辑器中修改命令参数，使用fixup即可，然后保存退出vim即可</li>\n</ul>\n<p><img src=\"http://wanghaoxun.com/git_rebase.jpeg\" alt=\"git rebase合并历史示例图\"></p>\n<ul>\n<li>git remote show origin 显示当前远端仓库地址</li>\n<li>git format-path 前一次commit hash -o ~/Downloads/nelson/script/</li>\n<li>git apply –reject ~/Downloads/nelson/script/path.patch</li>\n</ul>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q &amp; A\"></a>Q &amp; A</h2><ol>\n<li>git add . -A -u 区别？</li>\n</ol>\n<ul>\n<li>git add -u：(保存修改和删除，但是不包括新建文件) - 将文件的修改、文件的删除，添加到暂存区。update</li>\n<li>git add .：(保存新的添加和修改，但是不包括删除) - 将文件的修改，文件的新建，添加到暂存区。</li>\n<li>git add -A：(保存所有的修改) - 将文件的修改，文件的删除，文件的新建，添加到暂存区。</li>\n</ul>"},{"title":"Github Tips之快捷键","date":"2018-08-04T05:21:19.000Z","_content":"\n\n> Github是为开发者提供Git仓库的托管服务，是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。除了Git仓库的托管服务外，还为开发者和团队提供了一系列功能，帮助其提高效率、高品质地进行代码编写。本文将讲解一些关于Github 快捷键的使用和技巧。\n\n<img src=\"http://wanghaoxun.com/github_logo.png\" width=\"60%\" height=\"30%\">\n\n<!-- more -->\n\n## 查看文件差别\n\nGithub是一个优秀的源代码查看器，直接修改URL来查看差别的方法，能帮你节省不少时间。\n\n1. https://github.com/bumptech/glide/compare/master@{7.day.ago}...master 查看master分支在最近7天内的差别，指定期间可使用day，week，month，year四个时间单位\n2. https://github.com/bumptech/glide/compare/2.0...3.0 查看2.0和3.0分支的区别\n3. https://github.com/bumptech/glide/compare/master@{2018-01-01}...master 查看master分支2018年1月1日与现在的区别\n\n## Github快捷键\n\n* 按 t 键会打开一个文件浏览器\n* 按 w 键会打开分支选择菜单\n* 按 s 键会激活顶端的命令栏 (Command Bar)\n* 按 l 键编辑Issue列表页的标签\n* 查看文件内容时 （如： https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.md ），按 y 键将会冻结这个页面，这样就算代码被修改了也不会影响你当前看到的\n* 按 / 键打开快捷搜索，可以全局搜索文件\n* 按 g c 2个键，可以快速跳转到仓库代码首页\n* 按 g i 2个键，可以快速跳转到issue列表页\n* 按 g p 2个键，可以快速跳转到PR列表页\n* 按 g w 2个键，可以快速跳转到WIKI列表页\n* 按 ? 查看当前页面支持的快捷键列表：\n![快捷键列表](http://wanghaoxun.com/github_keymap.jpg)\n\n\n","source":"_posts/Github-Tips之快捷键.md","raw":"---\ntitle: Github Tips之快捷键\ndate: 2018-08-04 13:21:19\ntags: Github\ncategories: Github\n---\n\n\n> Github是为开发者提供Git仓库的托管服务，是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。除了Git仓库的托管服务外，还为开发者和团队提供了一系列功能，帮助其提高效率、高品质地进行代码编写。本文将讲解一些关于Github 快捷键的使用和技巧。\n\n<img src=\"http://wanghaoxun.com/github_logo.png\" width=\"60%\" height=\"30%\">\n\n<!-- more -->\n\n## 查看文件差别\n\nGithub是一个优秀的源代码查看器，直接修改URL来查看差别的方法，能帮你节省不少时间。\n\n1. https://github.com/bumptech/glide/compare/master@{7.day.ago}...master 查看master分支在最近7天内的差别，指定期间可使用day，week，month，year四个时间单位\n2. https://github.com/bumptech/glide/compare/2.0...3.0 查看2.0和3.0分支的区别\n3. https://github.com/bumptech/glide/compare/master@{2018-01-01}...master 查看master分支2018年1月1日与现在的区别\n\n## Github快捷键\n\n* 按 t 键会打开一个文件浏览器\n* 按 w 键会打开分支选择菜单\n* 按 s 键会激活顶端的命令栏 (Command Bar)\n* 按 l 键编辑Issue列表页的标签\n* 查看文件内容时 （如： https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.md ），按 y 键将会冻结这个页面，这样就算代码被修改了也不会影响你当前看到的\n* 按 / 键打开快捷搜索，可以全局搜索文件\n* 按 g c 2个键，可以快速跳转到仓库代码首页\n* 按 g i 2个键，可以快速跳转到issue列表页\n* 按 g p 2个键，可以快速跳转到PR列表页\n* 按 g w 2个键，可以快速跳转到WIKI列表页\n* 按 ? 查看当前页面支持的快捷键列表：\n![快捷键列表](http://wanghaoxun.com/github_keymap.jpg)\n\n\n","slug":"Github-Tips之快捷键","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vex000kn2cbw6i0it90","content":"<blockquote>\n<p>Github是为开发者提供Git仓库的托管服务，是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。除了Git仓库的托管服务外，还为开发者和团队提供了一系列功能，帮助其提高效率、高品质地进行代码编写。本文将讲解一些关于Github 快捷键的使用和技巧。</p>\n</blockquote>\n<p><img src=\"http://wanghaoxun.com/github_logo.png\" width=\"60%\" height=\"30%\"></p>\n<a id=\"more\"></a>\n<h2 id=\"查看文件差别\"><a href=\"#查看文件差别\" class=\"headerlink\" title=\"查看文件差别\"></a>查看文件差别</h2><p>Github是一个优秀的源代码查看器，直接修改URL来查看差别的方法，能帮你节省不少时间。</p>\n<ol>\n<li><a href=\"https://github.com/bumptech/glide/compare/master@{7.day.ago}...master\" target=\"_blank\" rel=\"noopener\">https://github.com/bumptech/glide/compare/master@{7.day.ago}...master</a> 查看master分支在最近7天内的差别，指定期间可使用day，week，month，year四个时间单位</li>\n<li><a href=\"https://github.com/bumptech/glide/compare/2.0...3.0\" target=\"_blank\" rel=\"noopener\">https://github.com/bumptech/glide/compare/2.0...3.0</a> 查看2.0和3.0分支的区别</li>\n<li><a href=\"https://github.com/bumptech/glide/compare/master@{2018-01-01}...master\" target=\"_blank\" rel=\"noopener\">https://github.com/bumptech/glide/compare/master@{2018-01-01}...master</a> 查看master分支2018年1月1日与现在的区别</li>\n</ol>\n<h2 id=\"Github快捷键\"><a href=\"#Github快捷键\" class=\"headerlink\" title=\"Github快捷键\"></a>Github快捷键</h2><ul>\n<li>按 t 键会打开一个文件浏览器</li>\n<li>按 w 键会打开分支选择菜单</li>\n<li>按 s 键会激活顶端的命令栏 (Command Bar)</li>\n<li>按 l 键编辑Issue列表页的标签</li>\n<li>查看文件内容时 （如： <a href=\"https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.md</a> ），按 y 键将会冻结这个页面，这样就算代码被修改了也不会影响你当前看到的</li>\n<li>按 / 键打开快捷搜索，可以全局搜索文件</li>\n<li>按 g c 2个键，可以快速跳转到仓库代码首页</li>\n<li>按 g i 2个键，可以快速跳转到issue列表页</li>\n<li>按 g p 2个键，可以快速跳转到PR列表页</li>\n<li>按 g w 2个键，可以快速跳转到WIKI列表页</li>\n<li>按 ? 查看当前页面支持的快捷键列表：<br><img src=\"http://wanghaoxun.com/github_keymap.jpg\" alt=\"快捷键列表\"></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Github是为开发者提供Git仓库的托管服务，是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。除了Git仓库的托管服务外，还为开发者和团队提供了一系列功能，帮助其提高效率、高品质地进行代码编写。本文将讲解一些关于Github 快捷键的使用和技巧。</p>\n</blockquote>\n<p><img src=\"http://wanghaoxun.com/github_logo.png\" width=\"60%\" height=\"30%\"></p>","more":"<h2 id=\"查看文件差别\"><a href=\"#查看文件差别\" class=\"headerlink\" title=\"查看文件差别\"></a>查看文件差别</h2><p>Github是一个优秀的源代码查看器，直接修改URL来查看差别的方法，能帮你节省不少时间。</p>\n<ol>\n<li><a href=\"https://github.com/bumptech/glide/compare/master@{7.day.ago}...master\" target=\"_blank\" rel=\"noopener\">https://github.com/bumptech/glide/compare/master@{7.day.ago}...master</a> 查看master分支在最近7天内的差别，指定期间可使用day，week，month，year四个时间单位</li>\n<li><a href=\"https://github.com/bumptech/glide/compare/2.0...3.0\" target=\"_blank\" rel=\"noopener\">https://github.com/bumptech/glide/compare/2.0...3.0</a> 查看2.0和3.0分支的区别</li>\n<li><a href=\"https://github.com/bumptech/glide/compare/master@{2018-01-01}...master\" target=\"_blank\" rel=\"noopener\">https://github.com/bumptech/glide/compare/master@{2018-01-01}...master</a> 查看master分支2018年1月1日与现在的区别</li>\n</ol>\n<h2 id=\"Github快捷键\"><a href=\"#Github快捷键\" class=\"headerlink\" title=\"Github快捷键\"></a>Github快捷键</h2><ul>\n<li>按 t 键会打开一个文件浏览器</li>\n<li>按 w 键会打开分支选择菜单</li>\n<li>按 s 键会激活顶端的命令栏 (Command Bar)</li>\n<li>按 l 键编辑Issue列表页的标签</li>\n<li>查看文件内容时 （如： <a href=\"https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.md</a> ），按 y 键将会冻结这个页面，这样就算代码被修改了也不会影响你当前看到的</li>\n<li>按 / 键打开快捷搜索，可以全局搜索文件</li>\n<li>按 g c 2个键，可以快速跳转到仓库代码首页</li>\n<li>按 g i 2个键，可以快速跳转到issue列表页</li>\n<li>按 g p 2个键，可以快速跳转到PR列表页</li>\n<li>按 g w 2个键，可以快速跳转到WIKI列表页</li>\n<li>按 ? 查看当前页面支持的快捷键列表：<br><img src=\"http://wanghaoxun.com/github_keymap.jpg\" alt=\"快捷键列表\"></li>\n</ul>"},{"title":"Github Tips之pull request(PR)","date":"2018-08-04T04:16:25.000Z","_content":"\n> Github是为开发者提供Git仓库的托管服务，是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。除了Git仓库的托管服务外，还为开发者和团队提供了一系列功能，帮助其提高效率、高品质地进行代码编写。本文将讲解一些关于Github PR(pull request)的使用和技巧。\n\n<img src=\"http://wanghaoxun.com/github_logo.png\" width=\"60%\" height=\"30%\">\n\n<!-- more -->\n\n## 前言\n\nPull Request 是用户修改代码后向对方仓库发送采纳请求的功能，也是GitHub的核心功能正因为有了这个功能，才会让众多开发者轻松地加入到开源开发的队伍中来。\n\n在 Pull Request页面能够列表查看当前处于Open状态的 Pull Request。通过点击页面左部和上部的选项可以进行筛选和重新排列。\n在列表中点击特定的 Pull Request 就会进入详细页面。页 面上方显示着这次是从谁的哪个分支向谁的哪个分支发送了 Pull Request。下面，我们以[GlideTest](https://github.com/haoxunwang/GlideTest)仓库为例进行讲解。注：下面haoxunwang是[GlideTest](https://github.com/haoxunwang/GlideTest)仓库的原作者，MogaoCaves是提交PR的开发者，MogaoCaves的[GlideTest](https://github.com/MogaoCaves/GlideTest)仓库是fork来自原作者haoxunwang的仓库。\n\n图1【PR首页，显示了[GlideTest](https://github.com/haoxunwang/GlideTest)仓库的pr所有的信息】\n![github_pr_home](http://wanghaoxun.com/github_pr_home.jpg)\n\n图2【PR详情，可以看到提交者从哪个分支提交到仓库的哪个分支】\n![github_pr_detail](http://wanghaoxun.com/github_pr_detail.png)\n\n## 发送PR流程\n\n![PR概念图](http://wanghaoxun.com/pr%E6%A6%82%E5%BF%B5%E5%9B%BE.jpg)\n\n### 拉取代码\n\n* 首先fork目标仓库（以[GlideTest](https://github.com/haoxunwang/GlideTest)为例）\n* git clone git@github.com:MogaoCaves/GlideTest.git\n* git checkout -b work master创建特性分支并自动切换\n* 添加代码\n* git diff 查看修改是否正确\n* git push origin work 创建远程分支\n* git branch -a 查看分支，origin/work已经被创建\n\n### 发送PR\n\n* 登录GitHub并切换到work分支，点击分支名左侧的绿色按钮，查看修改是否正确\n* 确认无误之后，点击create pull request \n* send pull request\n* 该仓库的管理者会接到通知\n* 代码修改合理，我们此次提交Pull Request会被仓库拥有者采纳\n\n### 想让PR更加有效的方法？  \n\n* 不必等代码最终开发完成，在PR中附带一段简单代码让大家有个大体印象，能获取不少反馈\n* 使用Tasklist语法，反映出哪些功能已经实现，将来要做哪些工作，能加快审查者的工作效率，还能作为自己的备忘录使用\n* 不要在PR中添加无关的修改，处理与主题无关的作业请另外创建分支，不然会让原本清晰的讨论变得一团糟\n* 明确标出“正在开发过程中”，在标题前加上“[WIP]”字样，WIP是work in progress的简写，等所有功能完成之后，再消去这个前缀\n![WIP示意图](http://wanghaoxun.com/WIP%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n### 仓库的维护\n\n> Fork或clone来的仓库，一旦放置不管就会离最新的源代码越来越远。如果不以最新的源代码为基础开发，劳神费力地编写代码也很可能是白费力气。所以需要我们学习如何让仓库保持最新状态。\n\n![将仓库更新至最新状态](http://wanghaoxun.com/UpdateToNew.jpg)\n\n* git clone git@github.com:MogaoCaves/GlideTest.git 克隆fork来的仓库\n* git remote add upstream git@github.com:haoxunwang/GlideTest.git 给原仓库设置upstream名称，将其作为远程仓库。今后，这个仓库以upstream作为原仓库的标识符，只需要设定一次\n* git fetch upstream 获取最新数据，让仓库维持最新状态\n* git merge upstream/master 将upstream/master分支与当前分支(master)合并，\n\n## 接受PR流程\n\n> 采纳PR前的准备：代码审查\n\n![PR接受](http://wanghaoxun.com/PR%E6%8E%A5%E5%8F%97.jpg)\n\n* 在本地开发环境中反映PR的内容，例如，PR接受方的用户名为haoxunwang，发送方的用户名为“PR 发送者”\n* git clone git@github.com:haoxunwang/GlideTest.git 克隆接受方仓库到本地\n* git remote add mogao(PR发送者) git@github.com:(PR发送者)MogaoCaves/GlideTest.git \n* git fetch PR发送者 获取发送方的远程仓库 git fetch mogao\n* git checkout -b pr1 创建用于检查的分支 git checkout -b work\n![PR_checkout](http://wanghaoxun.com/PR_checkout.jpg)\n\n* git merge PR发送者/work 合并发送方分支代码 git merge mogao/work\n* git branch -D PR1 检查无误之后，删除分支 git branch -D work\n* git checkout master 切换至我们master分支\n* git merge PR发送者/work 合并PR发送者/work分支的内容 git merge mogao/work\n* git push 推送至远端\n\n## Q & A\n\n* 为何要在特性分支（例如，本文的work分支）中进行作业再提交PR？\n    当前Git的主流开发模式都会使用特性分支。特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由master分支担当。所以请养成创建特性分支后再修改代码的好习惯吧。在Github上发送Pull Request时，一般都是发送特性分支。这样一来，PR就拥有了更明确的特性（主题）。为了让对方了解自己修改代码的意图，有助于提高代码审查的效率。\n\n\n","source":"_posts/Github-Tips之pull-request-PR.md","raw":"---\ntitle: Github Tips之pull request(PR)\ndate: 2018-08-04 12:16:25\ntags: Github\ncategories: Github\n---\n\n> Github是为开发者提供Git仓库的托管服务，是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。除了Git仓库的托管服务外，还为开发者和团队提供了一系列功能，帮助其提高效率、高品质地进行代码编写。本文将讲解一些关于Github PR(pull request)的使用和技巧。\n\n<img src=\"http://wanghaoxun.com/github_logo.png\" width=\"60%\" height=\"30%\">\n\n<!-- more -->\n\n## 前言\n\nPull Request 是用户修改代码后向对方仓库发送采纳请求的功能，也是GitHub的核心功能正因为有了这个功能，才会让众多开发者轻松地加入到开源开发的队伍中来。\n\n在 Pull Request页面能够列表查看当前处于Open状态的 Pull Request。通过点击页面左部和上部的选项可以进行筛选和重新排列。\n在列表中点击特定的 Pull Request 就会进入详细页面。页 面上方显示着这次是从谁的哪个分支向谁的哪个分支发送了 Pull Request。下面，我们以[GlideTest](https://github.com/haoxunwang/GlideTest)仓库为例进行讲解。注：下面haoxunwang是[GlideTest](https://github.com/haoxunwang/GlideTest)仓库的原作者，MogaoCaves是提交PR的开发者，MogaoCaves的[GlideTest](https://github.com/MogaoCaves/GlideTest)仓库是fork来自原作者haoxunwang的仓库。\n\n图1【PR首页，显示了[GlideTest](https://github.com/haoxunwang/GlideTest)仓库的pr所有的信息】\n![github_pr_home](http://wanghaoxun.com/github_pr_home.jpg)\n\n图2【PR详情，可以看到提交者从哪个分支提交到仓库的哪个分支】\n![github_pr_detail](http://wanghaoxun.com/github_pr_detail.png)\n\n## 发送PR流程\n\n![PR概念图](http://wanghaoxun.com/pr%E6%A6%82%E5%BF%B5%E5%9B%BE.jpg)\n\n### 拉取代码\n\n* 首先fork目标仓库（以[GlideTest](https://github.com/haoxunwang/GlideTest)为例）\n* git clone git@github.com:MogaoCaves/GlideTest.git\n* git checkout -b work master创建特性分支并自动切换\n* 添加代码\n* git diff 查看修改是否正确\n* git push origin work 创建远程分支\n* git branch -a 查看分支，origin/work已经被创建\n\n### 发送PR\n\n* 登录GitHub并切换到work分支，点击分支名左侧的绿色按钮，查看修改是否正确\n* 确认无误之后，点击create pull request \n* send pull request\n* 该仓库的管理者会接到通知\n* 代码修改合理，我们此次提交Pull Request会被仓库拥有者采纳\n\n### 想让PR更加有效的方法？  \n\n* 不必等代码最终开发完成，在PR中附带一段简单代码让大家有个大体印象，能获取不少反馈\n* 使用Tasklist语法，反映出哪些功能已经实现，将来要做哪些工作，能加快审查者的工作效率，还能作为自己的备忘录使用\n* 不要在PR中添加无关的修改，处理与主题无关的作业请另外创建分支，不然会让原本清晰的讨论变得一团糟\n* 明确标出“正在开发过程中”，在标题前加上“[WIP]”字样，WIP是work in progress的简写，等所有功能完成之后，再消去这个前缀\n![WIP示意图](http://wanghaoxun.com/WIP%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n### 仓库的维护\n\n> Fork或clone来的仓库，一旦放置不管就会离最新的源代码越来越远。如果不以最新的源代码为基础开发，劳神费力地编写代码也很可能是白费力气。所以需要我们学习如何让仓库保持最新状态。\n\n![将仓库更新至最新状态](http://wanghaoxun.com/UpdateToNew.jpg)\n\n* git clone git@github.com:MogaoCaves/GlideTest.git 克隆fork来的仓库\n* git remote add upstream git@github.com:haoxunwang/GlideTest.git 给原仓库设置upstream名称，将其作为远程仓库。今后，这个仓库以upstream作为原仓库的标识符，只需要设定一次\n* git fetch upstream 获取最新数据，让仓库维持最新状态\n* git merge upstream/master 将upstream/master分支与当前分支(master)合并，\n\n## 接受PR流程\n\n> 采纳PR前的准备：代码审查\n\n![PR接受](http://wanghaoxun.com/PR%E6%8E%A5%E5%8F%97.jpg)\n\n* 在本地开发环境中反映PR的内容，例如，PR接受方的用户名为haoxunwang，发送方的用户名为“PR 发送者”\n* git clone git@github.com:haoxunwang/GlideTest.git 克隆接受方仓库到本地\n* git remote add mogao(PR发送者) git@github.com:(PR发送者)MogaoCaves/GlideTest.git \n* git fetch PR发送者 获取发送方的远程仓库 git fetch mogao\n* git checkout -b pr1 创建用于检查的分支 git checkout -b work\n![PR_checkout](http://wanghaoxun.com/PR_checkout.jpg)\n\n* git merge PR发送者/work 合并发送方分支代码 git merge mogao/work\n* git branch -D PR1 检查无误之后，删除分支 git branch -D work\n* git checkout master 切换至我们master分支\n* git merge PR发送者/work 合并PR发送者/work分支的内容 git merge mogao/work\n* git push 推送至远端\n\n## Q & A\n\n* 为何要在特性分支（例如，本文的work分支）中进行作业再提交PR？\n    当前Git的主流开发模式都会使用特性分支。特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由master分支担当。所以请养成创建特性分支后再修改代码的好习惯吧。在Github上发送Pull Request时，一般都是发送特性分支。这样一来，PR就拥有了更明确的特性（主题）。为了让对方了解自己修改代码的意图，有助于提高代码审查的效率。\n\n\n","slug":"Github-Tips之pull-request-PR","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vez000on2cba0m7bbhb","content":"<blockquote>\n<p>Github是为开发者提供Git仓库的托管服务，是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。除了Git仓库的托管服务外，还为开发者和团队提供了一系列功能，帮助其提高效率、高品质地进行代码编写。本文将讲解一些关于Github PR(pull request)的使用和技巧。</p>\n</blockquote>\n<p><img src=\"http://wanghaoxun.com/github_logo.png\" width=\"60%\" height=\"30%\"></p>\n<a id=\"more\"></a>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Pull Request 是用户修改代码后向对方仓库发送采纳请求的功能，也是GitHub的核心功能正因为有了这个功能，才会让众多开发者轻松地加入到开源开发的队伍中来。</p>\n<p>在 Pull Request页面能够列表查看当前处于Open状态的 Pull Request。通过点击页面左部和上部的选项可以进行筛选和重新排列。<br>在列表中点击特定的 Pull Request 就会进入详细页面。页 面上方显示着这次是从谁的哪个分支向谁的哪个分支发送了 Pull Request。下面，我们以<a href=\"https://github.com/haoxunwang/GlideTest\" target=\"_blank\" rel=\"noopener\">GlideTest</a>仓库为例进行讲解。注：下面haoxunwang是<a href=\"https://github.com/haoxunwang/GlideTest\" target=\"_blank\" rel=\"noopener\">GlideTest</a>仓库的原作者，MogaoCaves是提交PR的开发者，MogaoCaves的<a href=\"https://github.com/MogaoCaves/GlideTest\" target=\"_blank\" rel=\"noopener\">GlideTest</a>仓库是fork来自原作者haoxunwang的仓库。</p>\n<p>图1【PR首页，显示了<a href=\"https://github.com/haoxunwang/GlideTest\" target=\"_blank\" rel=\"noopener\">GlideTest</a>仓库的pr所有的信息】<br><img src=\"http://wanghaoxun.com/github_pr_home.jpg\" alt=\"github_pr_home\"></p>\n<p>图2【PR详情，可以看到提交者从哪个分支提交到仓库的哪个分支】<br><img src=\"http://wanghaoxun.com/github_pr_detail.png\" alt=\"github_pr_detail\"></p>\n<h2 id=\"发送PR流程\"><a href=\"#发送PR流程\" class=\"headerlink\" title=\"发送PR流程\"></a>发送PR流程</h2><p><img src=\"http://wanghaoxun.com/pr%E6%A6%82%E5%BF%B5%E5%9B%BE.jpg\" alt=\"PR概念图\"></p>\n<h3 id=\"拉取代码\"><a href=\"#拉取代码\" class=\"headerlink\" title=\"拉取代码\"></a>拉取代码</h3><ul>\n<li>首先fork目标仓库（以<a href=\"https://github.com/haoxunwang/GlideTest\" target=\"_blank\" rel=\"noopener\">GlideTest</a>为例）</li>\n<li>git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:MogaoCaves/GlideTest.git</li>\n<li>git checkout -b work master创建特性分支并自动切换</li>\n<li>添加代码</li>\n<li>git diff 查看修改是否正确</li>\n<li>git push origin work 创建远程分支</li>\n<li>git branch -a 查看分支，origin/work已经被创建</li>\n</ul>\n<h3 id=\"发送PR\"><a href=\"#发送PR\" class=\"headerlink\" title=\"发送PR\"></a>发送PR</h3><ul>\n<li>登录GitHub并切换到work分支，点击分支名左侧的绿色按钮，查看修改是否正确</li>\n<li>确认无误之后，点击create pull request </li>\n<li>send pull request</li>\n<li>该仓库的管理者会接到通知</li>\n<li>代码修改合理，我们此次提交Pull Request会被仓库拥有者采纳</li>\n</ul>\n<h3 id=\"想让PR更加有效的方法？\"><a href=\"#想让PR更加有效的方法？\" class=\"headerlink\" title=\"想让PR更加有效的方法？\"></a>想让PR更加有效的方法？</h3><ul>\n<li>不必等代码最终开发完成，在PR中附带一段简单代码让大家有个大体印象，能获取不少反馈</li>\n<li>使用Tasklist语法，反映出哪些功能已经实现，将来要做哪些工作，能加快审查者的工作效率，还能作为自己的备忘录使用</li>\n<li>不要在PR中添加无关的修改，处理与主题无关的作业请另外创建分支，不然会让原本清晰的讨论变得一团糟</li>\n<li>明确标出“正在开发过程中”，在标题前加上“[WIP]”字样，WIP是work in progress的简写，等所有功能完成之后，再消去这个前缀<br><img src=\"http://wanghaoxun.com/WIP%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"WIP示意图\"></li>\n</ul>\n<h3 id=\"仓库的维护\"><a href=\"#仓库的维护\" class=\"headerlink\" title=\"仓库的维护\"></a>仓库的维护</h3><blockquote>\n<p>Fork或clone来的仓库，一旦放置不管就会离最新的源代码越来越远。如果不以最新的源代码为基础开发，劳神费力地编写代码也很可能是白费力气。所以需要我们学习如何让仓库保持最新状态。</p>\n</blockquote>\n<p><img src=\"http://wanghaoxun.com/UpdateToNew.jpg\" alt=\"将仓库更新至最新状态\"></p>\n<ul>\n<li>git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:MogaoCaves/GlideTest.git 克隆fork来的仓库</li>\n<li>git remote add upstream <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:haoxunwang/GlideTest.git 给原仓库设置upstream名称，将其作为远程仓库。今后，这个仓库以upstream作为原仓库的标识符，只需要设定一次</li>\n<li>git fetch upstream 获取最新数据，让仓库维持最新状态</li>\n<li>git merge upstream/master 将upstream/master分支与当前分支(master)合并，</li>\n</ul>\n<h2 id=\"接受PR流程\"><a href=\"#接受PR流程\" class=\"headerlink\" title=\"接受PR流程\"></a>接受PR流程</h2><blockquote>\n<p>采纳PR前的准备：代码审查</p>\n</blockquote>\n<p><img src=\"http://wanghaoxun.com/PR%E6%8E%A5%E5%8F%97.jpg\" alt=\"PR接受\"></p>\n<ul>\n<li>在本地开发环境中反映PR的内容，例如，PR接受方的用户名为haoxunwang，发送方的用户名为“PR 发送者”</li>\n<li>git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:haoxunwang/GlideTest.git 克隆接受方仓库到本地</li>\n<li>git remote add mogao(PR发送者) <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:(PR发送者)MogaoCaves/GlideTest.git </li>\n<li>git fetch PR发送者 获取发送方的远程仓库 git fetch mogao</li>\n<li><p>git checkout -b pr1 创建用于检查的分支 git checkout -b work<br><img src=\"http://wanghaoxun.com/PR_checkout.jpg\" alt=\"PR_checkout\"></p>\n</li>\n<li><p>git merge PR发送者/work 合并发送方分支代码 git merge mogao/work</p>\n</li>\n<li>git branch -D PR1 检查无误之后，删除分支 git branch -D work</li>\n<li>git checkout master 切换至我们master分支</li>\n<li>git merge PR发送者/work 合并PR发送者/work分支的内容 git merge mogao/work</li>\n<li>git push 推送至远端</li>\n</ul>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q &amp; A\"></a>Q &amp; A</h2><ul>\n<li>为何要在特性分支（例如，本文的work分支）中进行作业再提交PR？<br>  当前Git的主流开发模式都会使用特性分支。特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由master分支担当。所以请养成创建特性分支后再修改代码的好习惯吧。在Github上发送Pull Request时，一般都是发送特性分支。这样一来，PR就拥有了更明确的特性（主题）。为了让对方了解自己修改代码的意图，有助于提高代码审查的效率。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Github是为开发者提供Git仓库的托管服务，是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。除了Git仓库的托管服务外，还为开发者和团队提供了一系列功能，帮助其提高效率、高品质地进行代码编写。本文将讲解一些关于Github PR(pull request)的使用和技巧。</p>\n</blockquote>\n<p><img src=\"http://wanghaoxun.com/github_logo.png\" width=\"60%\" height=\"30%\"></p>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Pull Request 是用户修改代码后向对方仓库发送采纳请求的功能，也是GitHub的核心功能正因为有了这个功能，才会让众多开发者轻松地加入到开源开发的队伍中来。</p>\n<p>在 Pull Request页面能够列表查看当前处于Open状态的 Pull Request。通过点击页面左部和上部的选项可以进行筛选和重新排列。<br>在列表中点击特定的 Pull Request 就会进入详细页面。页 面上方显示着这次是从谁的哪个分支向谁的哪个分支发送了 Pull Request。下面，我们以<a href=\"https://github.com/haoxunwang/GlideTest\" target=\"_blank\" rel=\"noopener\">GlideTest</a>仓库为例进行讲解。注：下面haoxunwang是<a href=\"https://github.com/haoxunwang/GlideTest\" target=\"_blank\" rel=\"noopener\">GlideTest</a>仓库的原作者，MogaoCaves是提交PR的开发者，MogaoCaves的<a href=\"https://github.com/MogaoCaves/GlideTest\" target=\"_blank\" rel=\"noopener\">GlideTest</a>仓库是fork来自原作者haoxunwang的仓库。</p>\n<p>图1【PR首页，显示了<a href=\"https://github.com/haoxunwang/GlideTest\" target=\"_blank\" rel=\"noopener\">GlideTest</a>仓库的pr所有的信息】<br><img src=\"http://wanghaoxun.com/github_pr_home.jpg\" alt=\"github_pr_home\"></p>\n<p>图2【PR详情，可以看到提交者从哪个分支提交到仓库的哪个分支】<br><img src=\"http://wanghaoxun.com/github_pr_detail.png\" alt=\"github_pr_detail\"></p>\n<h2 id=\"发送PR流程\"><a href=\"#发送PR流程\" class=\"headerlink\" title=\"发送PR流程\"></a>发送PR流程</h2><p><img src=\"http://wanghaoxun.com/pr%E6%A6%82%E5%BF%B5%E5%9B%BE.jpg\" alt=\"PR概念图\"></p>\n<h3 id=\"拉取代码\"><a href=\"#拉取代码\" class=\"headerlink\" title=\"拉取代码\"></a>拉取代码</h3><ul>\n<li>首先fork目标仓库（以<a href=\"https://github.com/haoxunwang/GlideTest\" target=\"_blank\" rel=\"noopener\">GlideTest</a>为例）</li>\n<li>git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:MogaoCaves/GlideTest.git</li>\n<li>git checkout -b work master创建特性分支并自动切换</li>\n<li>添加代码</li>\n<li>git diff 查看修改是否正确</li>\n<li>git push origin work 创建远程分支</li>\n<li>git branch -a 查看分支，origin/work已经被创建</li>\n</ul>\n<h3 id=\"发送PR\"><a href=\"#发送PR\" class=\"headerlink\" title=\"发送PR\"></a>发送PR</h3><ul>\n<li>登录GitHub并切换到work分支，点击分支名左侧的绿色按钮，查看修改是否正确</li>\n<li>确认无误之后，点击create pull request </li>\n<li>send pull request</li>\n<li>该仓库的管理者会接到通知</li>\n<li>代码修改合理，我们此次提交Pull Request会被仓库拥有者采纳</li>\n</ul>\n<h3 id=\"想让PR更加有效的方法？\"><a href=\"#想让PR更加有效的方法？\" class=\"headerlink\" title=\"想让PR更加有效的方法？\"></a>想让PR更加有效的方法？</h3><ul>\n<li>不必等代码最终开发完成，在PR中附带一段简单代码让大家有个大体印象，能获取不少反馈</li>\n<li>使用Tasklist语法，反映出哪些功能已经实现，将来要做哪些工作，能加快审查者的工作效率，还能作为自己的备忘录使用</li>\n<li>不要在PR中添加无关的修改，处理与主题无关的作业请另外创建分支，不然会让原本清晰的讨论变得一团糟</li>\n<li>明确标出“正在开发过程中”，在标题前加上“[WIP]”字样，WIP是work in progress的简写，等所有功能完成之后，再消去这个前缀<br><img src=\"http://wanghaoxun.com/WIP%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"WIP示意图\"></li>\n</ul>\n<h3 id=\"仓库的维护\"><a href=\"#仓库的维护\" class=\"headerlink\" title=\"仓库的维护\"></a>仓库的维护</h3><blockquote>\n<p>Fork或clone来的仓库，一旦放置不管就会离最新的源代码越来越远。如果不以最新的源代码为基础开发，劳神费力地编写代码也很可能是白费力气。所以需要我们学习如何让仓库保持最新状态。</p>\n</blockquote>\n<p><img src=\"http://wanghaoxun.com/UpdateToNew.jpg\" alt=\"将仓库更新至最新状态\"></p>\n<ul>\n<li>git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:MogaoCaves/GlideTest.git 克隆fork来的仓库</li>\n<li>git remote add upstream <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:haoxunwang/GlideTest.git 给原仓库设置upstream名称，将其作为远程仓库。今后，这个仓库以upstream作为原仓库的标识符，只需要设定一次</li>\n<li>git fetch upstream 获取最新数据，让仓库维持最新状态</li>\n<li>git merge upstream/master 将upstream/master分支与当前分支(master)合并，</li>\n</ul>\n<h2 id=\"接受PR流程\"><a href=\"#接受PR流程\" class=\"headerlink\" title=\"接受PR流程\"></a>接受PR流程</h2><blockquote>\n<p>采纳PR前的准备：代码审查</p>\n</blockquote>\n<p><img src=\"http://wanghaoxun.com/PR%E6%8E%A5%E5%8F%97.jpg\" alt=\"PR接受\"></p>\n<ul>\n<li>在本地开发环境中反映PR的内容，例如，PR接受方的用户名为haoxunwang，发送方的用户名为“PR 发送者”</li>\n<li>git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:haoxunwang/GlideTest.git 克隆接受方仓库到本地</li>\n<li>git remote add mogao(PR发送者) <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:(PR发送者)MogaoCaves/GlideTest.git </li>\n<li>git fetch PR发送者 获取发送方的远程仓库 git fetch mogao</li>\n<li><p>git checkout -b pr1 创建用于检查的分支 git checkout -b work<br><img src=\"http://wanghaoxun.com/PR_checkout.jpg\" alt=\"PR_checkout\"></p>\n</li>\n<li><p>git merge PR发送者/work 合并发送方分支代码 git merge mogao/work</p>\n</li>\n<li>git branch -D PR1 检查无误之后，删除分支 git branch -D work</li>\n<li>git checkout master 切换至我们master分支</li>\n<li>git merge PR发送者/work 合并PR发送者/work分支的内容 git merge mogao/work</li>\n<li>git push 推送至远端</li>\n</ul>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q &amp; A\"></a>Q &amp; A</h2><ul>\n<li>为何要在特性分支（例如，本文的work分支）中进行作业再提交PR？<br>  当前Git的主流开发模式都会使用特性分支。特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由master分支担当。所以请养成创建特性分支后再修改代码的好习惯吧。在Github上发送Pull Request时，一般都是发送特性分支。这样一来，PR就拥有了更明确的特性（主题）。为了让对方了解自己修改代码的意图，有助于提高代码审查的效率。</li>\n</ul>"},{"title":"Glide4.x在Android 8.0手机上加载图片崩溃问题","date":"2018-07-15T09:44:08.000Z","_content":"\n最近自己负责的项目在发布了新版本后，Fabric 收到了一些关于 ImageView onDraw 的问题，而且都是在 Android Oreo 8.0 (API 26)上出现的，分析异常日志可以清晰发现都是 bitmap 解码出错，关键日志异常：**java.lang.IllegalStateException: Software rendering doesn't support hardware bitmaps**。同时新版本向日葵把图片加载库[Glide](https://github.com/bumptech/glide)从 3.7.1 版本更新到了 4.7.1，App 内部图片展示和操作代码都没有做更改。\n\n<img src=\"http://wanghaoxun.com/glide_logo.png\">\n\n<!-- more -->\n\n## 分析\n\n既然 App 代码没有做更改，那么问题就很有可能出在了 Glide 加载器和 Android 8.0系统。所以有必要了解这2者在新版本有哪些更新。\n\n### 不同Android版本时Bitmap内存模型\n\nBitmap内存优化[^Bitmap内存优化]\n[^Bitmap内存优化]: https://juejin.im/entry/5ad0213f6fb9a028df2306cd\n\n我们知道Android系统中，一个进程的内存可以简单分为Java内存和native内存两部分，而Bitmap对象占用的内存，有Bitmap对象内存和像素数据内存两部分，在不同的Android系统版本中，其所存放的位置也有变化。[Android Developers](https://link.juejin.im/?target=https%3A%2F%2Flink.jianshu.com%3Ft%3Dhttps%253A%252F%252Fdeveloper.android.com%252Ftopic%252Fperformance%252Fgraphics%252Fmanage-memory.html)上列举了从API 8 到API 26之间的分配方式：\n\n\n| API级别           | API 10- | API 11 ~ API 25 | API 26+|\n| :---              | :--: | :--: |   :---    |\n| Bitmap对象存放    | Java heap | Java heap | Java heap   |\n| 像素(pixel data)数据存放    | native heap | Java heap    | native heap    |\n\n最新的Android 8.0之后，谷歌又把像素存放的位置，从java heap该回到了native heap，API 11的那次改动，是源于native的内存释放不及时，会导致OOM，因此才将像素数据保存到java heap，从而保证Bitmap对象释放时，能够同时把像素数据内存也释放掉。至于为什么在8.0上改变了Bitmap像素数据的存放方式，我猜想和8.0中的GC算法调整有关系。GC算法的优化，使得Bitmap占用的大内存区域，在GC后也能够比较快速的回收、压缩，重新利用。\n\n### Bitmap.Config.HARDWARE\n\nAndroid 8.0 Bitmap.Config配置枚举新增了HARDWARE[^Bitmap.Config]，来配置图片像素数据存储在GPU里，去掉了内存存储的相同一份数据，来节省内存开销，加速UI渲染。如果要使用hardware，在bitmap decode时，设置`option.inPreferredConfig = Bitmap.Config.HARDWARE;`即可。如果要获取存储到显存上的bitmap，需要使用`PixelCopy`类把bitmap数据拷贝到内存中。PixelCopy类有几个静态方法，传递一个surface或window，指定一个bitmap，就可以把surface或window上的bitmap拷贝到你指定的bitmap上了。\n\n[^Bitmap.Config]: https://developer.android.com/reference/android/graphics/Bitmap.Config\n\n### Glide 4.x\n\nGlide4.+版本开始，适配了8.0系统的变化，解码默认是禁用hardware，如果外面设置了其它值，会打开hardware开关使用系统新特性。\n\n## 解决\n\n由于应用内对于图片显示没有严格的要求，所以使用`RGB_565`每像素4个字节加载图片来节省内存。在**Android 8.0**系统官方对bitmap的存储又进行了调整，图片像素(pixel data)数据存放到了**native heap**，如果图片只用作展示，不进行缩放、matrix处理的时候，图片数据只会在GPU存储一份用来渲染UI，否则图片需要在运存上也存在一份数据，来进行后续其它操作。\n\nGlide全局配置类代码（线上）：\n\n```java\n@GlideModule\npublic class GlideService extends AppGlideModule {\n\n    @Override\n    public void applyOptions(Context context, GlideBuilder builder) {\n        ViewTarget.setTagId(R.id.glide_tag_id);\n        builder.setDefaultRequestOptions(RequestOptions.formatOf(DecodeFormat.PREFER_RGB_565));\n    }\n}\n\n```\n\nGlide关于DecodeFormat文档解释\n\n```java\n\npublic enum DecodeFormat {\n\n  PREFER_ARGB_8888,\n\n  /**\n   * Identical to {@link #PREFER_ARGB_8888} but prevents Glide from using {@link\n   * android.graphics.Bitmap.Config#HARDWARE} on Android O+.\n   *\n   * @deprecated If you must disable hardware bitmaps, set\n   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false\n   * instead.\n   */\n  @Deprecated\n  PREFER_ARGB_8888_DISALLOW_HARDWARE,\n\n  /**\n   * Bitmaps decoded from image formats that support and/or use alpha (some types of PNGs, GIFs etc)\n   * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for\n   * {@link android.graphics.Bitmap#getConfig()}. Bitmaps decoded from formats that don't support or\n   * use alpha should return {@link android.graphics.Bitmap.Config#RGB_565} for\n   * {@link android.graphics.Bitmap#getConfig()}.\n   *\n   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use\n   * {@link android.graphics.Bitmap.Config#HARDWARE}.\n   */\n  PREFER_RGB_565;\n\n  /**\n   * The default value for DecodeFormat.\n   */\n  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;\n}\n```\n\n可以看到Glide 4.7.1上默认使用了`PREFER_ARGB_8888_DISALLOW_HARDWARE`，来禁用硬件位图，阻止Glide使用Android O+ 上`android.graphics.Bitmap.Config＃HARDWARE`。\n而应用设置了`PREFER_RGB_565`，从而打开了硬件位图存储的开关，只要应用内有读取变换`bitmap`的操作都有奔溃的问题。基于这个问题，目前做了disable hardware配置，使用Glide默认配置来解决图片解码问题。后续计划分出来只加载和变化的图片，使用不用的配置策略，兼容系统新API。\n\nPS：为单个请求设置禁止hardware，可进行如下设置。\n\n```java\nRequestOptions options = new RequestOptions().disallowHardwareConfig();\nGlide.with(fragment)\n  .load(url)\n  .apply(options)\n  .into(imageView);\n```\n\n## 总结\n\n* 新版本Glide 4.x适配了Android O+系统，做了bitmap加载优化\n* Android O+ 系统修改了图片像素数据存储位置，从java heap改到native heap\n* Android O+ 系统新增了`Bitmap.Config.HARDWARE`选项，hardware标志不是关于质量，而是关于像素存储位置（graphics memory），这样看来hardware更像个黑客\n* 如果使用了hardware功能，像从java层面获取bitmap byte数据，可以使用`PixelCopy`类来赋值获取，友情提示：从surface拷贝数据到内存很缓慢哦 :)\n* 如果你还想知道更多关于hardware的解释，请移步这里[Hardware Bitmaps](https://bumptech.github.io/glide/doc/hardwarebitmaps.html)\n\n## 更多关于Glide\n\n本人创建了一个github repo，包含了Glide3.x和4.x版本的入门和高级使用演示。如果你想知道更多关于Glide的使用，可以参考[GlideTest](https://github.com/haoxunwang/GlideTest)项目。备注：master分支是3.7.1版本演示，4.7.1分支是4.7.1版本演示。\n\n## 参考\n\n* [Bitmap.Config SDK Docs](https://developer.android.com/reference/android/graphics/Bitmap.Config)\n* [Android中Bitmap内存优化](https://juejin.im/entry/5ad0213f6fb9a028df2306cd)\n* [Bitmap.Config.HARDWARE vs Bitmap.Config.RGB_565](https://stackoverflow.com/questions/45511017/bitmap-config-hardware-vs-bitmap-config-rgb-565)\n* [Glide高级演示项目-GlideTest](https://github.com/haoxunwang/GlideTest)\n\n\n\n\n\n\n\n\n\n","source":"_posts/Glide4-x在Android-8-0手机上加载图片崩溃问题.md","raw":"---\ntitle: Glide4.x在Android 8.0手机上加载图片崩溃问题\ndate: 2018-07-15 17:44:08\ntags: Android\ncategories: Android\n---\n\n最近自己负责的项目在发布了新版本后，Fabric 收到了一些关于 ImageView onDraw 的问题，而且都是在 Android Oreo 8.0 (API 26)上出现的，分析异常日志可以清晰发现都是 bitmap 解码出错，关键日志异常：**java.lang.IllegalStateException: Software rendering doesn't support hardware bitmaps**。同时新版本向日葵把图片加载库[Glide](https://github.com/bumptech/glide)从 3.7.1 版本更新到了 4.7.1，App 内部图片展示和操作代码都没有做更改。\n\n<img src=\"http://wanghaoxun.com/glide_logo.png\">\n\n<!-- more -->\n\n## 分析\n\n既然 App 代码没有做更改，那么问题就很有可能出在了 Glide 加载器和 Android 8.0系统。所以有必要了解这2者在新版本有哪些更新。\n\n### 不同Android版本时Bitmap内存模型\n\nBitmap内存优化[^Bitmap内存优化]\n[^Bitmap内存优化]: https://juejin.im/entry/5ad0213f6fb9a028df2306cd\n\n我们知道Android系统中，一个进程的内存可以简单分为Java内存和native内存两部分，而Bitmap对象占用的内存，有Bitmap对象内存和像素数据内存两部分，在不同的Android系统版本中，其所存放的位置也有变化。[Android Developers](https://link.juejin.im/?target=https%3A%2F%2Flink.jianshu.com%3Ft%3Dhttps%253A%252F%252Fdeveloper.android.com%252Ftopic%252Fperformance%252Fgraphics%252Fmanage-memory.html)上列举了从API 8 到API 26之间的分配方式：\n\n\n| API级别           | API 10- | API 11 ~ API 25 | API 26+|\n| :---              | :--: | :--: |   :---    |\n| Bitmap对象存放    | Java heap | Java heap | Java heap   |\n| 像素(pixel data)数据存放    | native heap | Java heap    | native heap    |\n\n最新的Android 8.0之后，谷歌又把像素存放的位置，从java heap该回到了native heap，API 11的那次改动，是源于native的内存释放不及时，会导致OOM，因此才将像素数据保存到java heap，从而保证Bitmap对象释放时，能够同时把像素数据内存也释放掉。至于为什么在8.0上改变了Bitmap像素数据的存放方式，我猜想和8.0中的GC算法调整有关系。GC算法的优化，使得Bitmap占用的大内存区域，在GC后也能够比较快速的回收、压缩，重新利用。\n\n### Bitmap.Config.HARDWARE\n\nAndroid 8.0 Bitmap.Config配置枚举新增了HARDWARE[^Bitmap.Config]，来配置图片像素数据存储在GPU里，去掉了内存存储的相同一份数据，来节省内存开销，加速UI渲染。如果要使用hardware，在bitmap decode时，设置`option.inPreferredConfig = Bitmap.Config.HARDWARE;`即可。如果要获取存储到显存上的bitmap，需要使用`PixelCopy`类把bitmap数据拷贝到内存中。PixelCopy类有几个静态方法，传递一个surface或window，指定一个bitmap，就可以把surface或window上的bitmap拷贝到你指定的bitmap上了。\n\n[^Bitmap.Config]: https://developer.android.com/reference/android/graphics/Bitmap.Config\n\n### Glide 4.x\n\nGlide4.+版本开始，适配了8.0系统的变化，解码默认是禁用hardware，如果外面设置了其它值，会打开hardware开关使用系统新特性。\n\n## 解决\n\n由于应用内对于图片显示没有严格的要求，所以使用`RGB_565`每像素4个字节加载图片来节省内存。在**Android 8.0**系统官方对bitmap的存储又进行了调整，图片像素(pixel data)数据存放到了**native heap**，如果图片只用作展示，不进行缩放、matrix处理的时候，图片数据只会在GPU存储一份用来渲染UI，否则图片需要在运存上也存在一份数据，来进行后续其它操作。\n\nGlide全局配置类代码（线上）：\n\n```java\n@GlideModule\npublic class GlideService extends AppGlideModule {\n\n    @Override\n    public void applyOptions(Context context, GlideBuilder builder) {\n        ViewTarget.setTagId(R.id.glide_tag_id);\n        builder.setDefaultRequestOptions(RequestOptions.formatOf(DecodeFormat.PREFER_RGB_565));\n    }\n}\n\n```\n\nGlide关于DecodeFormat文档解释\n\n```java\n\npublic enum DecodeFormat {\n\n  PREFER_ARGB_8888,\n\n  /**\n   * Identical to {@link #PREFER_ARGB_8888} but prevents Glide from using {@link\n   * android.graphics.Bitmap.Config#HARDWARE} on Android O+.\n   *\n   * @deprecated If you must disable hardware bitmaps, set\n   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false\n   * instead.\n   */\n  @Deprecated\n  PREFER_ARGB_8888_DISALLOW_HARDWARE,\n\n  /**\n   * Bitmaps decoded from image formats that support and/or use alpha (some types of PNGs, GIFs etc)\n   * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for\n   * {@link android.graphics.Bitmap#getConfig()}. Bitmaps decoded from formats that don't support or\n   * use alpha should return {@link android.graphics.Bitmap.Config#RGB_565} for\n   * {@link android.graphics.Bitmap#getConfig()}.\n   *\n   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use\n   * {@link android.graphics.Bitmap.Config#HARDWARE}.\n   */\n  PREFER_RGB_565;\n\n  /**\n   * The default value for DecodeFormat.\n   */\n  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;\n}\n```\n\n可以看到Glide 4.7.1上默认使用了`PREFER_ARGB_8888_DISALLOW_HARDWARE`，来禁用硬件位图，阻止Glide使用Android O+ 上`android.graphics.Bitmap.Config＃HARDWARE`。\n而应用设置了`PREFER_RGB_565`，从而打开了硬件位图存储的开关，只要应用内有读取变换`bitmap`的操作都有奔溃的问题。基于这个问题，目前做了disable hardware配置，使用Glide默认配置来解决图片解码问题。后续计划分出来只加载和变化的图片，使用不用的配置策略，兼容系统新API。\n\nPS：为单个请求设置禁止hardware，可进行如下设置。\n\n```java\nRequestOptions options = new RequestOptions().disallowHardwareConfig();\nGlide.with(fragment)\n  .load(url)\n  .apply(options)\n  .into(imageView);\n```\n\n## 总结\n\n* 新版本Glide 4.x适配了Android O+系统，做了bitmap加载优化\n* Android O+ 系统修改了图片像素数据存储位置，从java heap改到native heap\n* Android O+ 系统新增了`Bitmap.Config.HARDWARE`选项，hardware标志不是关于质量，而是关于像素存储位置（graphics memory），这样看来hardware更像个黑客\n* 如果使用了hardware功能，像从java层面获取bitmap byte数据，可以使用`PixelCopy`类来赋值获取，友情提示：从surface拷贝数据到内存很缓慢哦 :)\n* 如果你还想知道更多关于hardware的解释，请移步这里[Hardware Bitmaps](https://bumptech.github.io/glide/doc/hardwarebitmaps.html)\n\n## 更多关于Glide\n\n本人创建了一个github repo，包含了Glide3.x和4.x版本的入门和高级使用演示。如果你想知道更多关于Glide的使用，可以参考[GlideTest](https://github.com/haoxunwang/GlideTest)项目。备注：master分支是3.7.1版本演示，4.7.1分支是4.7.1版本演示。\n\n## 参考\n\n* [Bitmap.Config SDK Docs](https://developer.android.com/reference/android/graphics/Bitmap.Config)\n* [Android中Bitmap内存优化](https://juejin.im/entry/5ad0213f6fb9a028df2306cd)\n* [Bitmap.Config.HARDWARE vs Bitmap.Config.RGB_565](https://stackoverflow.com/questions/45511017/bitmap-config-hardware-vs-bitmap-config-rgb-565)\n* [Glide高级演示项目-GlideTest](https://github.com/haoxunwang/GlideTest)\n\n\n\n\n\n\n\n\n\n","slug":"Glide4-x在Android-8-0手机上加载图片崩溃问题","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vf0000qn2cbz1wb8c19","content":"<p>最近自己负责的项目在发布了新版本后，Fabric 收到了一些关于 ImageView onDraw 的问题，而且都是在 Android Oreo 8.0 (API 26)上出现的，分析异常日志可以清晰发现都是 bitmap 解码出错，关键日志异常：<strong>java.lang.IllegalStateException: Software rendering doesn’t support hardware bitmaps</strong>。同时新版本向日葵把图片加载库<a href=\"https://github.com/bumptech/glide\" target=\"_blank\" rel=\"noopener\">Glide</a>从 3.7.1 版本更新到了 4.7.1，App 内部图片展示和操作代码都没有做更改。</p>\n<p><img src=\"http://wanghaoxun.com/glide_logo.png\"></p>\n<a id=\"more\"></a>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>既然 App 代码没有做更改，那么问题就很有可能出在了 Glide 加载器和 Android 8.0系统。所以有必要了解这2者在新版本有哪些更新。</p>\n<h3 id=\"不同Android版本时Bitmap内存模型\"><a href=\"#不同Android版本时Bitmap内存模型\" class=\"headerlink\" title=\"不同Android版本时Bitmap内存模型\"></a>不同Android版本时Bitmap内存模型</h3><p>Bitmap内存优化[^Bitmap内存优化]<br>[^Bitmap内存优化]: <a href=\"https://juejin.im/entry/5ad0213f6fb9a028df2306cd\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5ad0213f6fb9a028df2306cd</a></p>\n<p>我们知道Android系统中，一个进程的内存可以简单分为Java内存和native内存两部分，而Bitmap对象占用的内存，有Bitmap对象内存和像素数据内存两部分，在不同的Android系统版本中，其所存放的位置也有变化。<a href=\"https://link.juejin.im/?target=https%3A%2F%2Flink.jianshu.com%3Ft%3Dhttps%253A%252F%252Fdeveloper.android.com%252Ftopic%252Fperformance%252Fgraphics%252Fmanage-memory.html\" target=\"_blank\" rel=\"noopener\">Android Developers</a>上列举了从API 8 到API 26之间的分配方式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">API级别</th>\n<th style=\"text-align:center\">API 10-</th>\n<th style=\"text-align:center\">API 11 ~ API 25</th>\n<th style=\"text-align:left\">API 26+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Bitmap对象存放</td>\n<td style=\"text-align:center\">Java heap</td>\n<td style=\"text-align:center\">Java heap</td>\n<td style=\"text-align:left\">Java heap</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">像素(pixel data)数据存放</td>\n<td style=\"text-align:center\">native heap</td>\n<td style=\"text-align:center\">Java heap</td>\n<td style=\"text-align:left\">native heap</td>\n</tr>\n</tbody>\n</table>\n<p>最新的Android 8.0之后，谷歌又把像素存放的位置，从java heap该回到了native heap，API 11的那次改动，是源于native的内存释放不及时，会导致OOM，因此才将像素数据保存到java heap，从而保证Bitmap对象释放时，能够同时把像素数据内存也释放掉。至于为什么在8.0上改变了Bitmap像素数据的存放方式，我猜想和8.0中的GC算法调整有关系。GC算法的优化，使得Bitmap占用的大内存区域，在GC后也能够比较快速的回收、压缩，重新利用。</p>\n<h3 id=\"Bitmap-Config-HARDWARE\"><a href=\"#Bitmap-Config-HARDWARE\" class=\"headerlink\" title=\"Bitmap.Config.HARDWARE\"></a>Bitmap.Config.HARDWARE</h3><p>Android 8.0 Bitmap.Config配置枚举新增了HARDWARE<a href=\"https://developer.android.com/reference/android/graphics/Bitmap.Config\" target=\"_blank\" rel=\"noopener\">^Bitmap.Config</a>，来配置图片像素数据存储在GPU里，去掉了内存存储的相同一份数据，来节省内存开销，加速UI渲染。如果要使用hardware，在bitmap decode时，设置<code>option.inPreferredConfig = Bitmap.Config.HARDWARE;</code>即可。如果要获取存储到显存上的bitmap，需要使用<code>PixelCopy</code>类把bitmap数据拷贝到内存中。PixelCopy类有几个静态方法，传递一个surface或window，指定一个bitmap，就可以把surface或window上的bitmap拷贝到你指定的bitmap上了。</p>\n<h3 id=\"Glide-4-x\"><a href=\"#Glide-4-x\" class=\"headerlink\" title=\"Glide 4.x\"></a>Glide 4.x</h3><p>Glide4.+版本开始，适配了8.0系统的变化，解码默认是禁用hardware，如果外面设置了其它值，会打开hardware开关使用系统新特性。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>由于应用内对于图片显示没有严格的要求，所以使用<code>RGB_565</code>每像素4个字节加载图片来节省内存。在<strong>Android 8.0</strong>系统官方对bitmap的存储又进行了调整，图片像素(pixel data)数据存放到了<strong>native heap</strong>，如果图片只用作展示，不进行缩放、matrix处理的时候，图片数据只会在GPU存储一份用来渲染UI，否则图片需要在运存上也存在一份数据，来进行后续其它操作。</p>\n<p>Glide全局配置类代码（线上）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GlideModule</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlideService</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppGlideModule</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">applyOptions</span><span class=\"params\">(Context context, GlideBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">        ViewTarget.setTagId(R.id.glide_tag_id);</span><br><span class=\"line\">        builder.setDefaultRequestOptions(RequestOptions.formatOf(DecodeFormat.PREFER_RGB_565));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Glide关于DecodeFormat文档解释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> DecodeFormat &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  PREFER_ARGB_8888,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Identical to &#123;<span class=\"doctag\">@link</span> #PREFER_ARGB_8888&#125; but prevents Glide from using &#123;<span class=\"doctag\">@link</span></span></span><br><span class=\"line\"><span class=\"comment\">   * android.graphics.Bitmap.Config#HARDWARE&#125; on Android O+.</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@deprecated</span> If you must disable hardware bitmaps, set</span></span><br><span class=\"line\"><span class=\"comment\">   * &#123;<span class=\"doctag\">@link</span> com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG&#125; to false</span></span><br><span class=\"line\"><span class=\"comment\">   * instead.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Deprecated</span></span><br><span class=\"line\">  PREFER_ARGB_8888_DISALLOW_HARDWARE,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Bitmaps decoded from image formats that support and/or use alpha (some types of PNGs, GIFs etc)</span></span><br><span class=\"line\"><span class=\"comment\">   * should return &#123;<span class=\"doctag\">@link</span> android.graphics.Bitmap.Config#ARGB_8888&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">   * &#123;<span class=\"doctag\">@link</span> android.graphics.Bitmap#getConfig()&#125;. Bitmaps decoded from formats that don't support or</span></span><br><span class=\"line\"><span class=\"comment\">   * use alpha should return &#123;<span class=\"doctag\">@link</span> android.graphics.Bitmap.Config#RGB_565&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">   * &#123;<span class=\"doctag\">@link</span> android.graphics.Bitmap#getConfig()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * &lt;p&gt;On Android O+, this format will will use ARGB_8888 only when it's not possible to use</span></span><br><span class=\"line\"><span class=\"comment\">   * &#123;<span class=\"doctag\">@link</span> android.graphics.Bitmap.Config#HARDWARE&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  PREFER_RGB_565;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * The default value for DecodeFormat.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到Glide 4.7.1上默认使用了<code>PREFER_ARGB_8888_DISALLOW_HARDWARE</code>，来禁用硬件位图，阻止Glide使用Android O+ 上<code>android.graphics.Bitmap.Config＃HARDWARE</code>。<br>而应用设置了<code>PREFER_RGB_565</code>，从而打开了硬件位图存储的开关，只要应用内有读取变换<code>bitmap</code>的操作都有奔溃的问题。基于这个问题，目前做了disable hardware配置，使用Glide默认配置来解决图片解码问题。后续计划分出来只加载和变化的图片，使用不用的配置策略，兼容系统新API。</p>\n<p>PS：为单个请求设置禁止hardware，可进行如下设置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RequestOptions options = <span class=\"keyword\">new</span> RequestOptions().disallowHardwareConfig();</span><br><span class=\"line\">Glide.with(fragment)</span><br><span class=\"line\">  .load(url)</span><br><span class=\"line\">  .apply(options)</span><br><span class=\"line\">  .into(imageView);</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>新版本Glide 4.x适配了Android O+系统，做了bitmap加载优化</li>\n<li>Android O+ 系统修改了图片像素数据存储位置，从java heap改到native heap</li>\n<li>Android O+ 系统新增了<code>Bitmap.Config.HARDWARE</code>选项，hardware标志不是关于质量，而是关于像素存储位置（graphics memory），这样看来hardware更像个黑客</li>\n<li>如果使用了hardware功能，像从java层面获取bitmap byte数据，可以使用<code>PixelCopy</code>类来赋值获取，友情提示：从surface拷贝数据到内存很缓慢哦 :)</li>\n<li>如果你还想知道更多关于hardware的解释，请移步这里<a href=\"https://bumptech.github.io/glide/doc/hardwarebitmaps.html\" target=\"_blank\" rel=\"noopener\">Hardware Bitmaps</a></li>\n</ul>\n<h2 id=\"更多关于Glide\"><a href=\"#更多关于Glide\" class=\"headerlink\" title=\"更多关于Glide\"></a>更多关于Glide</h2><p>本人创建了一个github repo，包含了Glide3.x和4.x版本的入门和高级使用演示。如果你想知道更多关于Glide的使用，可以参考<a href=\"https://github.com/haoxunwang/GlideTest\" target=\"_blank\" rel=\"noopener\">GlideTest</a>项目。备注：master分支是3.7.1版本演示，4.7.1分支是4.7.1版本演示。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://developer.android.com/reference/android/graphics/Bitmap.Config\" target=\"_blank\" rel=\"noopener\">Bitmap.Config SDK Docs</a></li>\n<li><a href=\"https://juejin.im/entry/5ad0213f6fb9a028df2306cd\" target=\"_blank\" rel=\"noopener\">Android中Bitmap内存优化</a></li>\n<li><a href=\"https://stackoverflow.com/questions/45511017/bitmap-config-hardware-vs-bitmap-config-rgb-565\" target=\"_blank\" rel=\"noopener\">Bitmap.Config.HARDWARE vs Bitmap.Config.RGB_565</a></li>\n<li><a href=\"https://github.com/haoxunwang/GlideTest\" target=\"_blank\" rel=\"noopener\">Glide高级演示项目-GlideTest</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近自己负责的项目在发布了新版本后，Fabric 收到了一些关于 ImageView onDraw 的问题，而且都是在 Android Oreo 8.0 (API 26)上出现的，分析异常日志可以清晰发现都是 bitmap 解码出错，关键日志异常：<strong>java.lang.IllegalStateException: Software rendering doesn’t support hardware bitmaps</strong>。同时新版本向日葵把图片加载库<a href=\"https://github.com/bumptech/glide\" target=\"_blank\" rel=\"noopener\">Glide</a>从 3.7.1 版本更新到了 4.7.1，App 内部图片展示和操作代码都没有做更改。</p>\n<p><img src=\"http://wanghaoxun.com/glide_logo.png\"></p>","more":"<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>既然 App 代码没有做更改，那么问题就很有可能出在了 Glide 加载器和 Android 8.0系统。所以有必要了解这2者在新版本有哪些更新。</p>\n<h3 id=\"不同Android版本时Bitmap内存模型\"><a href=\"#不同Android版本时Bitmap内存模型\" class=\"headerlink\" title=\"不同Android版本时Bitmap内存模型\"></a>不同Android版本时Bitmap内存模型</h3><p>Bitmap内存优化[^Bitmap内存优化]<br>[^Bitmap内存优化]: <a href=\"https://juejin.im/entry/5ad0213f6fb9a028df2306cd\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5ad0213f6fb9a028df2306cd</a></p>\n<p>我们知道Android系统中，一个进程的内存可以简单分为Java内存和native内存两部分，而Bitmap对象占用的内存，有Bitmap对象内存和像素数据内存两部分，在不同的Android系统版本中，其所存放的位置也有变化。<a href=\"https://link.juejin.im/?target=https%3A%2F%2Flink.jianshu.com%3Ft%3Dhttps%253A%252F%252Fdeveloper.android.com%252Ftopic%252Fperformance%252Fgraphics%252Fmanage-memory.html\" target=\"_blank\" rel=\"noopener\">Android Developers</a>上列举了从API 8 到API 26之间的分配方式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">API级别</th>\n<th style=\"text-align:center\">API 10-</th>\n<th style=\"text-align:center\">API 11 ~ API 25</th>\n<th style=\"text-align:left\">API 26+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Bitmap对象存放</td>\n<td style=\"text-align:center\">Java heap</td>\n<td style=\"text-align:center\">Java heap</td>\n<td style=\"text-align:left\">Java heap</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">像素(pixel data)数据存放</td>\n<td style=\"text-align:center\">native heap</td>\n<td style=\"text-align:center\">Java heap</td>\n<td style=\"text-align:left\">native heap</td>\n</tr>\n</tbody>\n</table>\n<p>最新的Android 8.0之后，谷歌又把像素存放的位置，从java heap该回到了native heap，API 11的那次改动，是源于native的内存释放不及时，会导致OOM，因此才将像素数据保存到java heap，从而保证Bitmap对象释放时，能够同时把像素数据内存也释放掉。至于为什么在8.0上改变了Bitmap像素数据的存放方式，我猜想和8.0中的GC算法调整有关系。GC算法的优化，使得Bitmap占用的大内存区域，在GC后也能够比较快速的回收、压缩，重新利用。</p>\n<h3 id=\"Bitmap-Config-HARDWARE\"><a href=\"#Bitmap-Config-HARDWARE\" class=\"headerlink\" title=\"Bitmap.Config.HARDWARE\"></a>Bitmap.Config.HARDWARE</h3><p>Android 8.0 Bitmap.Config配置枚举新增了HARDWARE<a href=\"https://developer.android.com/reference/android/graphics/Bitmap.Config\" target=\"_blank\" rel=\"noopener\">^Bitmap.Config</a>，来配置图片像素数据存储在GPU里，去掉了内存存储的相同一份数据，来节省内存开销，加速UI渲染。如果要使用hardware，在bitmap decode时，设置<code>option.inPreferredConfig = Bitmap.Config.HARDWARE;</code>即可。如果要获取存储到显存上的bitmap，需要使用<code>PixelCopy</code>类把bitmap数据拷贝到内存中。PixelCopy类有几个静态方法，传递一个surface或window，指定一个bitmap，就可以把surface或window上的bitmap拷贝到你指定的bitmap上了。</p>\n<h3 id=\"Glide-4-x\"><a href=\"#Glide-4-x\" class=\"headerlink\" title=\"Glide 4.x\"></a>Glide 4.x</h3><p>Glide4.+版本开始，适配了8.0系统的变化，解码默认是禁用hardware，如果外面设置了其它值，会打开hardware开关使用系统新特性。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>由于应用内对于图片显示没有严格的要求，所以使用<code>RGB_565</code>每像素4个字节加载图片来节省内存。在<strong>Android 8.0</strong>系统官方对bitmap的存储又进行了调整，图片像素(pixel data)数据存放到了<strong>native heap</strong>，如果图片只用作展示，不进行缩放、matrix处理的时候，图片数据只会在GPU存储一份用来渲染UI，否则图片需要在运存上也存在一份数据，来进行后续其它操作。</p>\n<p>Glide全局配置类代码（线上）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GlideModule</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlideService</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppGlideModule</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">applyOptions</span><span class=\"params\">(Context context, GlideBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">        ViewTarget.setTagId(R.id.glide_tag_id);</span><br><span class=\"line\">        builder.setDefaultRequestOptions(RequestOptions.formatOf(DecodeFormat.PREFER_RGB_565));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Glide关于DecodeFormat文档解释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> DecodeFormat &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  PREFER_ARGB_8888,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Identical to &#123;<span class=\"doctag\">@link</span> #PREFER_ARGB_8888&#125; but prevents Glide from using &#123;<span class=\"doctag\">@link</span></span></span><br><span class=\"line\"><span class=\"comment\">   * android.graphics.Bitmap.Config#HARDWARE&#125; on Android O+.</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@deprecated</span> If you must disable hardware bitmaps, set</span></span><br><span class=\"line\"><span class=\"comment\">   * &#123;<span class=\"doctag\">@link</span> com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG&#125; to false</span></span><br><span class=\"line\"><span class=\"comment\">   * instead.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Deprecated</span></span><br><span class=\"line\">  PREFER_ARGB_8888_DISALLOW_HARDWARE,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Bitmaps decoded from image formats that support and/or use alpha (some types of PNGs, GIFs etc)</span></span><br><span class=\"line\"><span class=\"comment\">   * should return &#123;<span class=\"doctag\">@link</span> android.graphics.Bitmap.Config#ARGB_8888&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">   * &#123;<span class=\"doctag\">@link</span> android.graphics.Bitmap#getConfig()&#125;. Bitmaps decoded from formats that don't support or</span></span><br><span class=\"line\"><span class=\"comment\">   * use alpha should return &#123;<span class=\"doctag\">@link</span> android.graphics.Bitmap.Config#RGB_565&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">   * &#123;<span class=\"doctag\">@link</span> android.graphics.Bitmap#getConfig()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * &lt;p&gt;On Android O+, this format will will use ARGB_8888 only when it's not possible to use</span></span><br><span class=\"line\"><span class=\"comment\">   * &#123;<span class=\"doctag\">@link</span> android.graphics.Bitmap.Config#HARDWARE&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  PREFER_RGB_565;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * The default value for DecodeFormat.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到Glide 4.7.1上默认使用了<code>PREFER_ARGB_8888_DISALLOW_HARDWARE</code>，来禁用硬件位图，阻止Glide使用Android O+ 上<code>android.graphics.Bitmap.Config＃HARDWARE</code>。<br>而应用设置了<code>PREFER_RGB_565</code>，从而打开了硬件位图存储的开关，只要应用内有读取变换<code>bitmap</code>的操作都有奔溃的问题。基于这个问题，目前做了disable hardware配置，使用Glide默认配置来解决图片解码问题。后续计划分出来只加载和变化的图片，使用不用的配置策略，兼容系统新API。</p>\n<p>PS：为单个请求设置禁止hardware，可进行如下设置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RequestOptions options = <span class=\"keyword\">new</span> RequestOptions().disallowHardwareConfig();</span><br><span class=\"line\">Glide.with(fragment)</span><br><span class=\"line\">  .load(url)</span><br><span class=\"line\">  .apply(options)</span><br><span class=\"line\">  .into(imageView);</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>新版本Glide 4.x适配了Android O+系统，做了bitmap加载优化</li>\n<li>Android O+ 系统修改了图片像素数据存储位置，从java heap改到native heap</li>\n<li>Android O+ 系统新增了<code>Bitmap.Config.HARDWARE</code>选项，hardware标志不是关于质量，而是关于像素存储位置（graphics memory），这样看来hardware更像个黑客</li>\n<li>如果使用了hardware功能，像从java层面获取bitmap byte数据，可以使用<code>PixelCopy</code>类来赋值获取，友情提示：从surface拷贝数据到内存很缓慢哦 :)</li>\n<li>如果你还想知道更多关于hardware的解释，请移步这里<a href=\"https://bumptech.github.io/glide/doc/hardwarebitmaps.html\" target=\"_blank\" rel=\"noopener\">Hardware Bitmaps</a></li>\n</ul>\n<h2 id=\"更多关于Glide\"><a href=\"#更多关于Glide\" class=\"headerlink\" title=\"更多关于Glide\"></a>更多关于Glide</h2><p>本人创建了一个github repo，包含了Glide3.x和4.x版本的入门和高级使用演示。如果你想知道更多关于Glide的使用，可以参考<a href=\"https://github.com/haoxunwang/GlideTest\" target=\"_blank\" rel=\"noopener\">GlideTest</a>项目。备注：master分支是3.7.1版本演示，4.7.1分支是4.7.1版本演示。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://developer.android.com/reference/android/graphics/Bitmap.Config\" target=\"_blank\" rel=\"noopener\">Bitmap.Config SDK Docs</a></li>\n<li><a href=\"https://juejin.im/entry/5ad0213f6fb9a028df2306cd\" target=\"_blank\" rel=\"noopener\">Android中Bitmap内存优化</a></li>\n<li><a href=\"https://stackoverflow.com/questions/45511017/bitmap-config-hardware-vs-bitmap-config-rgb-565\" target=\"_blank\" rel=\"noopener\">Bitmap.Config.HARDWARE vs Bitmap.Config.RGB_565</a></li>\n<li><a href=\"https://github.com/haoxunwang/GlideTest\" target=\"_blank\" rel=\"noopener\">Glide高级演示项目-GlideTest</a></li>\n</ul>"},{"title":"Java代理技术","date":"2018-08-02T16:21:09.000Z","_content":"\n有些时候，我们不希望有些对象直接被外界所访问，而是通过一个代理对象来访问，已达到控制权限，或者添加一些额外的操作，这种方式就成为代理。代理可以实现解耦，隐藏实现类的具体细节。。。\n\n<img src=\"http://wanghaoxun.com/java_logo.jpg\" width=\"60%\" height=\"30%\">\n\n<!-- more -->\n\n> 注意：以下文章代码来自[codeKK网站](http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86)\n\n## 代理\n\n* 静态代理，委托类（被代理类）和代理类实现同一个接口，来达到控制函数的目的。可以在代理类中函数调用委托类函数时，做一些处理。例如，加个权限判断，日志等\n* 动态代理，不用手动创建委托类，使用java api来动态生成代理类对象，可以统一对委托类接口里的所有函数集中处理，比如，集中判断，添加日志等等。\n\n## api\n\n* InvocationHandler\n```java\n    public Object invoke(Object proxy, Method method, Object[] args)\n                                          \n    * proxy表示通过Proxy.newProxyInstance()生成的代理类对象\n    * metho表示代理对象被调用的函数\n    * args表示代理对象被调用的函数的参数\n    调用代理对象的每个函数最终都是调用了InvocationHandler的invoke函数。invoke函数中我们可以通过对method做一些判断，从而对某些函数特殊处理。\n    \n    说明：为什么第一个参数要返回来proxy？返回来proxy可以获取一些proxy的信息，后续操作还可以继续使用\n```\n\n* Proxy\n\n```java\n    public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n                                          \n    * loader表示类加载器\n    * interfaces表示委托类的接口，生成代理类时需要实现这些接口\n    * h是InvocationHandler实现类对象，负责连接代理类和委托类的中间类\n\n```\n\n## 例子\n\n* 公共接口\n\n```java\npublic interface Operate {\n\n    public void operateMethod1();\n\n    public void operateMethod2();\n\n    public void operateMethod3();\n}\n\n```\n\n* 委托类（被代理类）\n\n```java\npublic class OperateImpl implements Operate {\n\n    @Override\n    public void operateMethod1() {\n        System.out.println(\"Invoke operateMethod1\");\n        sleep(110);\n    }\n\n    @Override\n    public void operateMethod2() {\n        System.out.println(\"Invoke operateMethod2\");\n        sleep(120);\n    }\n\n    @Override\n    public void operateMethod3() {\n        System.out.println(\"Invoke operateMethod3\");\n        sleep(130);\n    }\n\n    private static void sleep(long millSeconds) {\n        try {\n            Thread.sleep(millSeconds);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n````\nOperate是一个接口，定了了一些函数，我们要统计这些函数的执行时间。\nOperateImpl是委托类，实现Operate接口。每个函数简单输出字符串，并等待一段时间。\n动态代理要求委托类必须实现了某个接口，比如这里委托类OperateImpl实现了Operate\n\n* InvocationHandler\n\n```java\npublic class TimingInvocationHandler implements InvocationHandler {\n\n    private Object target;\n\n    public TimingInvocationHandler() {}\n\n    public TimingInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        long start = System.currentTimeMillis();\n        Object obj = method.invoke(target, args);\n        System.out.println(method.getName() + \" cost time is:\" + (System.currentTimeMillis() - start));\n        return obj;\n    }\n}\n```\n\ntarget属性表示委托类对象。\n\nInvocationHandler是负责连接代理类和委托类的中间类必须实现的接口。其中只有一个invoke(...)函数要去实现。\n\n* 通过 Proxy 类静态函数生成代理对象\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // create proxy instance\n        TimingInvocationHandler timingInvocationHandler = new TimingInvocationHandler(new OperateImpl());\n        Operate operate = (Operate)(Proxy.newProxyInstance(Operate.class.getClassLoader(), new Class[] {Operate.class},\n                timingInvocationHandler));\n\n        // call method of proxy instance\n        operate.operateMethod1();\n        System.out.println();\n        operate.operateMethod2();\n        System.out.println();\n        operate.operateMethod3();\n    }\n}\n```\n\n这里我们先将委托类对象new OperateImpl()作为TimingInvocationHandler构造函数入参创建timingInvocationHandler对象；\n然后通过Proxy.newProxyInstance(…)函数新建了一个代理对象，实际代理类就是在这时候动态生成的。我们调用该代理对象的函数就会调用到timingInvocationHandler的invoke函数(是不是有点类似静态代理)，而invoke函数实现中调用委托类对象new OperateImpl()相应的 method(是不是有点类似静态代理)。\n\n## 关于代理类\n\n想要查看生成的代理类，需要借助系统api（ProxyGenerator.generateProxyClass(proxyClassName, interfaces)）来生成class，输出到本地，借助jd-gui查看接口。如何得到这些生成的代码请见[ProxyUtils](https://github.com/android-cn/android-open-project-demo/blob/master/java-dynamic-proxy/src/com/codekk/java/test/dynamicproxy/util/ProxyUtils.java)。\n\n### 基本原理\n\n* 先调用getProxyClass(loader, interfaces)得到动态代理类，然后将InvocationHandler作为代理类构造函数入参新建代理类对象。这里创建代理对象使用了反射， `Constructor cons = cl.getConstructor(constructorParams); (Object) cons.newInstance(new Object[] { h })`\n* 入参 interfaces 检验，包含3部分，1）是否在入参指定的 ClassLoader 内；2）是否是 Interface；3）interfaces 中是否有重复\n* 动态生成代理类的字节码，最终调用 sun.misc.ProxyGenerator.generateClassFile() 得到代理类相关信息，返回来class字节数组，可写入 DataOutputStream 实现\n*  native 层实现，虚拟机加载代理类并返回其类对象\n\n## 使用场景\n\n例如：J2EE Web 开发中 Spring 的 AOP(面向切面编程) 特性\n\n比如在 Dao 中，每次数据库操作都需要开启事务，而且在操作的时候需要关注权限。一般写法是在 Dao 的每个函数中添加相应逻辑，造成代码冗余，耦合度高。\n使用动态代理前伪代码如下：\n\n```java\nDao {\n    insert() {\n        判断是否有保存的权限；\n        开启事务；\n        插入；\n        提交事务；\n    }\n\n    delete() {\n        判断是否有删除的权限；\n        开启事务；\n        删除；\n        提交事务；\n    }\n}\n```\n\n使用动态代理的伪代码如下：\n```java\n// 使用动态代理，组合每个切面的函数，而每个切面只需要关注自己的逻辑就行，达到减少代码，松耦合的效果\ninvoke(Object proxy, Method method, Object[] args)\n                    throws Throwable {\n    判断是否有权限；\n    开启事务；\n    Object ob = method.invoke(dao, args)；\n    提交事务；\n    return ob; \n}\n```\n\n## 参考\n\n* [codeKK-公共技术点之 Java 动态代理](http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86)\n* [本地生成代理类的函数，可使用jd-gui查看class](https://github.com/android-cn/android-open-project-demo/blob/master/java-dynamic-proxy/src/com/codekk/java/test/dynamicproxy/util/ProxyUtils.java)\n* [InvocationHandler中invoke方法中的第一个参数proxy的用途](https://blog.csdn.net/bu2_int/article/details/60150319)\n\n","source":"_posts/Java代理技术.md","raw":"---\ntitle: Java代理技术\ndate: 2018-08-03 00:21:09\ntags: Java\ncategories: Java\n---\n\n有些时候，我们不希望有些对象直接被外界所访问，而是通过一个代理对象来访问，已达到控制权限，或者添加一些额外的操作，这种方式就成为代理。代理可以实现解耦，隐藏实现类的具体细节。。。\n\n<img src=\"http://wanghaoxun.com/java_logo.jpg\" width=\"60%\" height=\"30%\">\n\n<!-- more -->\n\n> 注意：以下文章代码来自[codeKK网站](http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86)\n\n## 代理\n\n* 静态代理，委托类（被代理类）和代理类实现同一个接口，来达到控制函数的目的。可以在代理类中函数调用委托类函数时，做一些处理。例如，加个权限判断，日志等\n* 动态代理，不用手动创建委托类，使用java api来动态生成代理类对象，可以统一对委托类接口里的所有函数集中处理，比如，集中判断，添加日志等等。\n\n## api\n\n* InvocationHandler\n```java\n    public Object invoke(Object proxy, Method method, Object[] args)\n                                          \n    * proxy表示通过Proxy.newProxyInstance()生成的代理类对象\n    * metho表示代理对象被调用的函数\n    * args表示代理对象被调用的函数的参数\n    调用代理对象的每个函数最终都是调用了InvocationHandler的invoke函数。invoke函数中我们可以通过对method做一些判断，从而对某些函数特殊处理。\n    \n    说明：为什么第一个参数要返回来proxy？返回来proxy可以获取一些proxy的信息，后续操作还可以继续使用\n```\n\n* Proxy\n\n```java\n    public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n                                          \n    * loader表示类加载器\n    * interfaces表示委托类的接口，生成代理类时需要实现这些接口\n    * h是InvocationHandler实现类对象，负责连接代理类和委托类的中间类\n\n```\n\n## 例子\n\n* 公共接口\n\n```java\npublic interface Operate {\n\n    public void operateMethod1();\n\n    public void operateMethod2();\n\n    public void operateMethod3();\n}\n\n```\n\n* 委托类（被代理类）\n\n```java\npublic class OperateImpl implements Operate {\n\n    @Override\n    public void operateMethod1() {\n        System.out.println(\"Invoke operateMethod1\");\n        sleep(110);\n    }\n\n    @Override\n    public void operateMethod2() {\n        System.out.println(\"Invoke operateMethod2\");\n        sleep(120);\n    }\n\n    @Override\n    public void operateMethod3() {\n        System.out.println(\"Invoke operateMethod3\");\n        sleep(130);\n    }\n\n    private static void sleep(long millSeconds) {\n        try {\n            Thread.sleep(millSeconds);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n````\nOperate是一个接口，定了了一些函数，我们要统计这些函数的执行时间。\nOperateImpl是委托类，实现Operate接口。每个函数简单输出字符串，并等待一段时间。\n动态代理要求委托类必须实现了某个接口，比如这里委托类OperateImpl实现了Operate\n\n* InvocationHandler\n\n```java\npublic class TimingInvocationHandler implements InvocationHandler {\n\n    private Object target;\n\n    public TimingInvocationHandler() {}\n\n    public TimingInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        long start = System.currentTimeMillis();\n        Object obj = method.invoke(target, args);\n        System.out.println(method.getName() + \" cost time is:\" + (System.currentTimeMillis() - start));\n        return obj;\n    }\n}\n```\n\ntarget属性表示委托类对象。\n\nInvocationHandler是负责连接代理类和委托类的中间类必须实现的接口。其中只有一个invoke(...)函数要去实现。\n\n* 通过 Proxy 类静态函数生成代理对象\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // create proxy instance\n        TimingInvocationHandler timingInvocationHandler = new TimingInvocationHandler(new OperateImpl());\n        Operate operate = (Operate)(Proxy.newProxyInstance(Operate.class.getClassLoader(), new Class[] {Operate.class},\n                timingInvocationHandler));\n\n        // call method of proxy instance\n        operate.operateMethod1();\n        System.out.println();\n        operate.operateMethod2();\n        System.out.println();\n        operate.operateMethod3();\n    }\n}\n```\n\n这里我们先将委托类对象new OperateImpl()作为TimingInvocationHandler构造函数入参创建timingInvocationHandler对象；\n然后通过Proxy.newProxyInstance(…)函数新建了一个代理对象，实际代理类就是在这时候动态生成的。我们调用该代理对象的函数就会调用到timingInvocationHandler的invoke函数(是不是有点类似静态代理)，而invoke函数实现中调用委托类对象new OperateImpl()相应的 method(是不是有点类似静态代理)。\n\n## 关于代理类\n\n想要查看生成的代理类，需要借助系统api（ProxyGenerator.generateProxyClass(proxyClassName, interfaces)）来生成class，输出到本地，借助jd-gui查看接口。如何得到这些生成的代码请见[ProxyUtils](https://github.com/android-cn/android-open-project-demo/blob/master/java-dynamic-proxy/src/com/codekk/java/test/dynamicproxy/util/ProxyUtils.java)。\n\n### 基本原理\n\n* 先调用getProxyClass(loader, interfaces)得到动态代理类，然后将InvocationHandler作为代理类构造函数入参新建代理类对象。这里创建代理对象使用了反射， `Constructor cons = cl.getConstructor(constructorParams); (Object) cons.newInstance(new Object[] { h })`\n* 入参 interfaces 检验，包含3部分，1）是否在入参指定的 ClassLoader 内；2）是否是 Interface；3）interfaces 中是否有重复\n* 动态生成代理类的字节码，最终调用 sun.misc.ProxyGenerator.generateClassFile() 得到代理类相关信息，返回来class字节数组，可写入 DataOutputStream 实现\n*  native 层实现，虚拟机加载代理类并返回其类对象\n\n## 使用场景\n\n例如：J2EE Web 开发中 Spring 的 AOP(面向切面编程) 特性\n\n比如在 Dao 中，每次数据库操作都需要开启事务，而且在操作的时候需要关注权限。一般写法是在 Dao 的每个函数中添加相应逻辑，造成代码冗余，耦合度高。\n使用动态代理前伪代码如下：\n\n```java\nDao {\n    insert() {\n        判断是否有保存的权限；\n        开启事务；\n        插入；\n        提交事务；\n    }\n\n    delete() {\n        判断是否有删除的权限；\n        开启事务；\n        删除；\n        提交事务；\n    }\n}\n```\n\n使用动态代理的伪代码如下：\n```java\n// 使用动态代理，组合每个切面的函数，而每个切面只需要关注自己的逻辑就行，达到减少代码，松耦合的效果\ninvoke(Object proxy, Method method, Object[] args)\n                    throws Throwable {\n    判断是否有权限；\n    开启事务；\n    Object ob = method.invoke(dao, args)；\n    提交事务；\n    return ob; \n}\n```\n\n## 参考\n\n* [codeKK-公共技术点之 Java 动态代理](http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86)\n* [本地生成代理类的函数，可使用jd-gui查看class](https://github.com/android-cn/android-open-project-demo/blob/master/java-dynamic-proxy/src/com/codekk/java/test/dynamicproxy/util/ProxyUtils.java)\n* [InvocationHandler中invoke方法中的第一个参数proxy的用途](https://blog.csdn.net/bu2_int/article/details/60150319)\n\n","slug":"Java代理技术","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vf2000un2cbxb3t9hr1","content":"<p>有些时候，我们不希望有些对象直接被外界所访问，而是通过一个代理对象来访问，已达到控制权限，或者添加一些额外的操作，这种方式就成为代理。代理可以实现解耦，隐藏实现类的具体细节。。。</p>\n<p><img src=\"http://wanghaoxun.com/java_logo.jpg\" width=\"60%\" height=\"30%\"></p>\n<a id=\"more\"></a>\n<blockquote>\n<p>注意：以下文章代码来自<a href=\"http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\" target=\"_blank\" rel=\"noopener\">codeKK网站</a></p>\n</blockquote>\n<h2 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h2><ul>\n<li>静态代理，委托类（被代理类）和代理类实现同一个接口，来达到控制函数的目的。可以在代理类中函数调用委托类函数时，做一些处理。例如，加个权限判断，日志等</li>\n<li>动态代理，不用手动创建委托类，使用java api来动态生成代理类对象，可以统一对委托类接口里的所有函数集中处理，比如，集中判断，添加日志等等。</li>\n</ul>\n<h2 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h2><ul>\n<li><p>InvocationHandler</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">                                      </span></span><br><span class=\"line\"><span class=\"function\">* proxy表示通过Proxy.<span class=\"title\">newProxyInstance</span><span class=\"params\">()</span>生成的代理类对象</span></span><br><span class=\"line\"><span class=\"function\">* metho表示代理对象被调用的函数</span></span><br><span class=\"line\"><span class=\"function\">* args表示代理对象被调用的函数的参数</span></span><br><span class=\"line\"><span class=\"function\">调用代理对象的每个函数最终都是调用了InvocationHandler的invoke函数。invoke函数中我们可以通过对method做一些判断，从而对某些函数特殊处理。</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">说明：为什么第一个参数要返回来proxy？返回来proxy可以获取一些proxy的信息，后续操作还可以继续使用</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Proxy</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                      InvocationHandler h)</span></span></span><br><span class=\"line\"><span class=\"function\">                                      </span></span><br><span class=\"line\"><span class=\"function\">* loader表示类加载器</span></span><br><span class=\"line\"><span class=\"function\">* interfaces表示委托类的接口，生成代理类时需要实现这些接口</span></span><br><span class=\"line\"><span class=\"function\">* h是InvocationHandler实现类对象，负责连接代理类和委托类的中间类</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><ul>\n<li>公共接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Operate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operateMethod1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operateMethod2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operateMethod3</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>委托类（被代理类）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OperateImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Operate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operateMethod1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Invoke operateMethod1\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">110</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operateMethod2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Invoke operateMethod2\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">120</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operateMethod3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Invoke operateMethod3\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">130</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">(<span class=\"keyword\">long</span> millSeconds)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(millSeconds);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p>Operate是一个接口，定了了一些函数，我们要统计这些函数的执行时间。<br>OperateImpl是委托类，实现Operate接口。每个函数简单输出字符串，并等待一段时间。<br>动态代理要求委托类必须实现了某个接口，比如这里委托类OperateImpl实现了Operate</p>\n<ul>\n<li>InvocationHandler</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimingInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TimingInvocationHandler</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TimingInvocationHandler</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        Object obj = method.invoke(target, args);</span><br><span class=\"line\">        System.out.println(method.getName() + <span class=\"string\">\" cost time is:\"</span> + (System.currentTimeMillis() - start));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>target属性表示委托类对象。</p>\n<p>InvocationHandler是负责连接代理类和委托类的中间类必须实现的接口。其中只有一个invoke(…)函数要去实现。</p>\n<ul>\n<li>通过 Proxy 类静态函数生成代理对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create proxy instance</span></span><br><span class=\"line\">        TimingInvocationHandler timingInvocationHandler = <span class=\"keyword\">new</span> TimingInvocationHandler(<span class=\"keyword\">new</span> OperateImpl());</span><br><span class=\"line\">        Operate operate = (Operate)(Proxy.newProxyInstance(Operate.class.getClassLoader(), new Class[] &#123;Operate.class&#125;,</span><br><span class=\"line\">                timingInvocationHandler));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// call method of proxy instance</span></span><br><span class=\"line\">        operate.operateMethod1();</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        operate.operateMethod2();</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        operate.operateMethod3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们先将委托类对象new OperateImpl()作为TimingInvocationHandler构造函数入参创建timingInvocationHandler对象；<br>然后通过Proxy.newProxyInstance(…)函数新建了一个代理对象，实际代理类就是在这时候动态生成的。我们调用该代理对象的函数就会调用到timingInvocationHandler的invoke函数(是不是有点类似静态代理)，而invoke函数实现中调用委托类对象new OperateImpl()相应的 method(是不是有点类似静态代理)。</p>\n<h2 id=\"关于代理类\"><a href=\"#关于代理类\" class=\"headerlink\" title=\"关于代理类\"></a>关于代理类</h2><p>想要查看生成的代理类，需要借助系统api（ProxyGenerator.generateProxyClass(proxyClassName, interfaces)）来生成class，输出到本地，借助jd-gui查看接口。如何得到这些生成的代码请见<a href=\"https://github.com/android-cn/android-open-project-demo/blob/master/java-dynamic-proxy/src/com/codekk/java/test/dynamicproxy/util/ProxyUtils.java\" target=\"_blank\" rel=\"noopener\">ProxyUtils</a>。</p>\n<h3 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h3><ul>\n<li>先调用getProxyClass(loader, interfaces)得到动态代理类，然后将InvocationHandler作为代理类构造函数入参新建代理类对象。这里创建代理对象使用了反射， <code>Constructor cons = cl.getConstructor(constructorParams); (Object) cons.newInstance(new Object[] { h })</code></li>\n<li>入参 interfaces 检验，包含3部分，1）是否在入参指定的 ClassLoader 内；2）是否是 Interface；3）interfaces 中是否有重复</li>\n<li>动态生成代理类的字节码，最终调用 sun.misc.ProxyGenerator.generateClassFile() 得到代理类相关信息，返回来class字节数组，可写入 DataOutputStream 实现</li>\n<li>native 层实现，虚拟机加载代理类并返回其类对象</li>\n</ul>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>例如：J2EE Web 开发中 Spring 的 AOP(面向切面编程) 特性</p>\n<p>比如在 Dao 中，每次数据库操作都需要开启事务，而且在操作的时候需要关注权限。一般写法是在 Dao 的每个函数中添加相应逻辑，造成代码冗余，耦合度高。<br>使用动态代理前伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dao &#123;</span><br><span class=\"line\">    insert() &#123;</span><br><span class=\"line\">        判断是否有保存的权限；</span><br><span class=\"line\">        开启事务；</span><br><span class=\"line\">        插入；</span><br><span class=\"line\">        提交事务；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    delete() &#123;</span><br><span class=\"line\">        判断是否有删除的权限；</span><br><span class=\"line\">        开启事务；</span><br><span class=\"line\">        删除；</span><br><span class=\"line\">        提交事务；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用动态代理的伪代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用动态代理，组合每个切面的函数，而每个切面只需要关注自己的逻辑就行，达到减少代码，松耦合的效果</span></span><br><span class=\"line\">invoke(Object proxy, Method method, Object[] args)</span><br><span class=\"line\">                    <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">    判断是否有权限；</span><br><span class=\"line\">    开启事务；</span><br><span class=\"line\">    Object ob = method.invoke(dao, args)；</span><br><span class=\"line\">    提交事务；</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ob; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\" target=\"_blank\" rel=\"noopener\">codeKK-公共技术点之 Java 动态代理</a></li>\n<li><a href=\"https://github.com/android-cn/android-open-project-demo/blob/master/java-dynamic-proxy/src/com/codekk/java/test/dynamicproxy/util/ProxyUtils.java\" target=\"_blank\" rel=\"noopener\">本地生成代理类的函数，可使用jd-gui查看class</a></li>\n<li><a href=\"https://blog.csdn.net/bu2_int/article/details/60150319\" target=\"_blank\" rel=\"noopener\">InvocationHandler中invoke方法中的第一个参数proxy的用途</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>有些时候，我们不希望有些对象直接被外界所访问，而是通过一个代理对象来访问，已达到控制权限，或者添加一些额外的操作，这种方式就成为代理。代理可以实现解耦，隐藏实现类的具体细节。。。</p>\n<p><img src=\"http://wanghaoxun.com/java_logo.jpg\" width=\"60%\" height=\"30%\"></p>","more":"<blockquote>\n<p>注意：以下文章代码来自<a href=\"http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\" target=\"_blank\" rel=\"noopener\">codeKK网站</a></p>\n</blockquote>\n<h2 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h2><ul>\n<li>静态代理，委托类（被代理类）和代理类实现同一个接口，来达到控制函数的目的。可以在代理类中函数调用委托类函数时，做一些处理。例如，加个权限判断，日志等</li>\n<li>动态代理，不用手动创建委托类，使用java api来动态生成代理类对象，可以统一对委托类接口里的所有函数集中处理，比如，集中判断，添加日志等等。</li>\n</ul>\n<h2 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h2><ul>\n<li><p>InvocationHandler</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">                                      </span></span><br><span class=\"line\"><span class=\"function\">* proxy表示通过Proxy.<span class=\"title\">newProxyInstance</span><span class=\"params\">()</span>生成的代理类对象</span></span><br><span class=\"line\"><span class=\"function\">* metho表示代理对象被调用的函数</span></span><br><span class=\"line\"><span class=\"function\">* args表示代理对象被调用的函数的参数</span></span><br><span class=\"line\"><span class=\"function\">调用代理对象的每个函数最终都是调用了InvocationHandler的invoke函数。invoke函数中我们可以通过对method做一些判断，从而对某些函数特殊处理。</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">说明：为什么第一个参数要返回来proxy？返回来proxy可以获取一些proxy的信息，后续操作还可以继续使用</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Proxy</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                      InvocationHandler h)</span></span></span><br><span class=\"line\"><span class=\"function\">                                      </span></span><br><span class=\"line\"><span class=\"function\">* loader表示类加载器</span></span><br><span class=\"line\"><span class=\"function\">* interfaces表示委托类的接口，生成代理类时需要实现这些接口</span></span><br><span class=\"line\"><span class=\"function\">* h是InvocationHandler实现类对象，负责连接代理类和委托类的中间类</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><ul>\n<li>公共接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Operate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operateMethod1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operateMethod2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operateMethod3</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>委托类（被代理类）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OperateImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Operate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operateMethod1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Invoke operateMethod1\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">110</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operateMethod2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Invoke operateMethod2\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">120</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operateMethod3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Invoke operateMethod3\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">130</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">(<span class=\"keyword\">long</span> millSeconds)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(millSeconds);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p>Operate是一个接口，定了了一些函数，我们要统计这些函数的执行时间。<br>OperateImpl是委托类，实现Operate接口。每个函数简单输出字符串，并等待一段时间。<br>动态代理要求委托类必须实现了某个接口，比如这里委托类OperateImpl实现了Operate</p>\n<ul>\n<li>InvocationHandler</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimingInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TimingInvocationHandler</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TimingInvocationHandler</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        Object obj = method.invoke(target, args);</span><br><span class=\"line\">        System.out.println(method.getName() + <span class=\"string\">\" cost time is:\"</span> + (System.currentTimeMillis() - start));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>target属性表示委托类对象。</p>\n<p>InvocationHandler是负责连接代理类和委托类的中间类必须实现的接口。其中只有一个invoke(…)函数要去实现。</p>\n<ul>\n<li>通过 Proxy 类静态函数生成代理对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create proxy instance</span></span><br><span class=\"line\">        TimingInvocationHandler timingInvocationHandler = <span class=\"keyword\">new</span> TimingInvocationHandler(<span class=\"keyword\">new</span> OperateImpl());</span><br><span class=\"line\">        Operate operate = (Operate)(Proxy.newProxyInstance(Operate.class.getClassLoader(), new Class[] &#123;Operate.class&#125;,</span><br><span class=\"line\">                timingInvocationHandler));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// call method of proxy instance</span></span><br><span class=\"line\">        operate.operateMethod1();</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        operate.operateMethod2();</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        operate.operateMethod3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们先将委托类对象new OperateImpl()作为TimingInvocationHandler构造函数入参创建timingInvocationHandler对象；<br>然后通过Proxy.newProxyInstance(…)函数新建了一个代理对象，实际代理类就是在这时候动态生成的。我们调用该代理对象的函数就会调用到timingInvocationHandler的invoke函数(是不是有点类似静态代理)，而invoke函数实现中调用委托类对象new OperateImpl()相应的 method(是不是有点类似静态代理)。</p>\n<h2 id=\"关于代理类\"><a href=\"#关于代理类\" class=\"headerlink\" title=\"关于代理类\"></a>关于代理类</h2><p>想要查看生成的代理类，需要借助系统api（ProxyGenerator.generateProxyClass(proxyClassName, interfaces)）来生成class，输出到本地，借助jd-gui查看接口。如何得到这些生成的代码请见<a href=\"https://github.com/android-cn/android-open-project-demo/blob/master/java-dynamic-proxy/src/com/codekk/java/test/dynamicproxy/util/ProxyUtils.java\" target=\"_blank\" rel=\"noopener\">ProxyUtils</a>。</p>\n<h3 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h3><ul>\n<li>先调用getProxyClass(loader, interfaces)得到动态代理类，然后将InvocationHandler作为代理类构造函数入参新建代理类对象。这里创建代理对象使用了反射， <code>Constructor cons = cl.getConstructor(constructorParams); (Object) cons.newInstance(new Object[] { h })</code></li>\n<li>入参 interfaces 检验，包含3部分，1）是否在入参指定的 ClassLoader 内；2）是否是 Interface；3）interfaces 中是否有重复</li>\n<li>动态生成代理类的字节码，最终调用 sun.misc.ProxyGenerator.generateClassFile() 得到代理类相关信息，返回来class字节数组，可写入 DataOutputStream 实现</li>\n<li>native 层实现，虚拟机加载代理类并返回其类对象</li>\n</ul>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>例如：J2EE Web 开发中 Spring 的 AOP(面向切面编程) 特性</p>\n<p>比如在 Dao 中，每次数据库操作都需要开启事务，而且在操作的时候需要关注权限。一般写法是在 Dao 的每个函数中添加相应逻辑，造成代码冗余，耦合度高。<br>使用动态代理前伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dao &#123;</span><br><span class=\"line\">    insert() &#123;</span><br><span class=\"line\">        判断是否有保存的权限；</span><br><span class=\"line\">        开启事务；</span><br><span class=\"line\">        插入；</span><br><span class=\"line\">        提交事务；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    delete() &#123;</span><br><span class=\"line\">        判断是否有删除的权限；</span><br><span class=\"line\">        开启事务；</span><br><span class=\"line\">        删除；</span><br><span class=\"line\">        提交事务；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用动态代理的伪代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用动态代理，组合每个切面的函数，而每个切面只需要关注自己的逻辑就行，达到减少代码，松耦合的效果</span></span><br><span class=\"line\">invoke(Object proxy, Method method, Object[] args)</span><br><span class=\"line\">                    <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">    判断是否有权限；</span><br><span class=\"line\">    开启事务；</span><br><span class=\"line\">    Object ob = method.invoke(dao, args)；</span><br><span class=\"line\">    提交事务；</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ob; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\" target=\"_blank\" rel=\"noopener\">codeKK-公共技术点之 Java 动态代理</a></li>\n<li><a href=\"https://github.com/android-cn/android-open-project-demo/blob/master/java-dynamic-proxy/src/com/codekk/java/test/dynamicproxy/util/ProxyUtils.java\" target=\"_blank\" rel=\"noopener\">本地生成代理类的函数，可使用jd-gui查看class</a></li>\n<li><a href=\"https://blog.csdn.net/bu2_int/article/details/60150319\" target=\"_blank\" rel=\"noopener\">InvocationHandler中invoke方法中的第一个参数proxy的用途</a></li>\n</ul>"},{"title":"Mac Terminal 终端代理配置","date":"2019-12-02T16:04:19.000Z","_content":"\n本文讲解如何给 Mac 系统终端配置 Http 代理设置，代理我们使用 Shadowsocks。经常在命令行终端下工作的码农们，SS无法正常工作。因为在终端下不支持socks5代理，只支持http代理，这就很尴尬了。像常用的 wget、curl、git、brew 等命令行工具执行会很慢。\n\n<!-- more -->\n\n## 配置过程\n\n1. ~/.bash_profile 文件配置代理开关\n\n在 Mac 终端用 vim 编辑器打开 `~/.bash_profile`环境变量配置文件，添加如下配置代码\n\n```\n# ------terminal http proxy ----------\nfunction proxy_on() {\n    export http_proxy = http://127.0.0.1:1087\n    export https_proxy = http://127.0.0.1:1087\n    echo - e \"已开启代理\"\n}\nfunction proxy_off() {\n    unset http_proxy\n    unset https_proxy\n    echo - e \"已关闭代理\"\n}\n```\n\n注意：`http://127.0.0.1:1087`表示使用本地回环 ip 地址，端口是 Shadowsocks 开启的 HTTP 代理端口。具体可在 Shadowsocks 偏好设置里查看，如果没有开启 HTTP 代理，需要开启一下！\n\n<img desc=\"Shadowsocks-Preferences\" src=\"shadowsocks_preferences.jpg\" width=\"60%\" height=\"60%\" />\n\n2. 在终端直接运行 `proxy_on`即可打开终端 http 代理，`proxy_off` 关闭代理\n\n运行命令`curl ip.gs`来检查是否开启成功！\n\n<img desc=\"检查代理效果\" src=\"terminal_ping.jpg\" width=\"80%\" height=\"50%\" />\n\n## 其它\n\n* wikipedia 关于[ Shadowsocks](https://zh.wikipedia.org/zh-hans/Shadowsocks)的介绍如下：\n\n> Shadowsocks（简称SS）是一种基于Socks5代理方式的加密传输协议，Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。     \nShadowsocks的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。例如，用户无法直接访问Google，但代理服务器可以访问，且用户可以直接连接代理服务器，那么用户就可以通过特定软件连接代理服务器，然后由代理服务器获取网站内容并回传给用户，从而实现代理上网的效果。另外用户在成功连接到服务器后，客户端会在本机构建一个本地Socks5代理（或VPN、透明代理等）。浏览网络时，网络流量需要先通过本地代理传递到客户端软件，然后才能发送到服务器端，反之亦然。\n\n* 关于如何配置客户端和服务端代理，可以查看博主的另一篇博客  [科学上网的姿势，帮你解决翻墙上网的烦恼](http://nelsonblog.me/2018/03/25/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E5%A7%BF%E5%8A%BF%EF%BC%8C%E5%B8%AE%E4%BD%A0%E8%A7%A3%E5%86%B3%E7%BF%BB%E5%A2%99%E4%B8%8A%E7%BD%91%E7%9A%84%E7%83%A6%E6%81%BC/)\n\n## Q&A\n\n* 终端代理已经显示国外的 ip，但是还是 ping 不通，为什么？\n\nss 代理是基于 tcp 或者 udp 协议，而 ping 是走的 icmp 协议因此在 ss 下不能 ping 通 google！\n\n## 参考\n\n* [mac 终端实现翻墙](https://kerminate.me/2018/10/22/mac-%E7%BB%88%E7%AB%AF%E5%AE%9E%E7%8E%B0%E7%BF%BB%E5%A2%99/)\n\n\n","source":"_posts/Mac-Terminal-终端代理配置.md","raw":"---\ntitle: Mac Terminal 终端代理配置\ndate: 2019-12-03 00:04:19\ntags: Mac\ncategories: Mac\n---\n\n本文讲解如何给 Mac 系统终端配置 Http 代理设置，代理我们使用 Shadowsocks。经常在命令行终端下工作的码农们，SS无法正常工作。因为在终端下不支持socks5代理，只支持http代理，这就很尴尬了。像常用的 wget、curl、git、brew 等命令行工具执行会很慢。\n\n<!-- more -->\n\n## 配置过程\n\n1. ~/.bash_profile 文件配置代理开关\n\n在 Mac 终端用 vim 编辑器打开 `~/.bash_profile`环境变量配置文件，添加如下配置代码\n\n```\n# ------terminal http proxy ----------\nfunction proxy_on() {\n    export http_proxy = http://127.0.0.1:1087\n    export https_proxy = http://127.0.0.1:1087\n    echo - e \"已开启代理\"\n}\nfunction proxy_off() {\n    unset http_proxy\n    unset https_proxy\n    echo - e \"已关闭代理\"\n}\n```\n\n注意：`http://127.0.0.1:1087`表示使用本地回环 ip 地址，端口是 Shadowsocks 开启的 HTTP 代理端口。具体可在 Shadowsocks 偏好设置里查看，如果没有开启 HTTP 代理，需要开启一下！\n\n<img desc=\"Shadowsocks-Preferences\" src=\"shadowsocks_preferences.jpg\" width=\"60%\" height=\"60%\" />\n\n2. 在终端直接运行 `proxy_on`即可打开终端 http 代理，`proxy_off` 关闭代理\n\n运行命令`curl ip.gs`来检查是否开启成功！\n\n<img desc=\"检查代理效果\" src=\"terminal_ping.jpg\" width=\"80%\" height=\"50%\" />\n\n## 其它\n\n* wikipedia 关于[ Shadowsocks](https://zh.wikipedia.org/zh-hans/Shadowsocks)的介绍如下：\n\n> Shadowsocks（简称SS）是一种基于Socks5代理方式的加密传输协议，Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。     \nShadowsocks的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。例如，用户无法直接访问Google，但代理服务器可以访问，且用户可以直接连接代理服务器，那么用户就可以通过特定软件连接代理服务器，然后由代理服务器获取网站内容并回传给用户，从而实现代理上网的效果。另外用户在成功连接到服务器后，客户端会在本机构建一个本地Socks5代理（或VPN、透明代理等）。浏览网络时，网络流量需要先通过本地代理传递到客户端软件，然后才能发送到服务器端，反之亦然。\n\n* 关于如何配置客户端和服务端代理，可以查看博主的另一篇博客  [科学上网的姿势，帮你解决翻墙上网的烦恼](http://nelsonblog.me/2018/03/25/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E5%A7%BF%E5%8A%BF%EF%BC%8C%E5%B8%AE%E4%BD%A0%E8%A7%A3%E5%86%B3%E7%BF%BB%E5%A2%99%E4%B8%8A%E7%BD%91%E7%9A%84%E7%83%A6%E6%81%BC/)\n\n## Q&A\n\n* 终端代理已经显示国外的 ip，但是还是 ping 不通，为什么？\n\nss 代理是基于 tcp 或者 udp 协议，而 ping 是走的 icmp 协议因此在 ss 下不能 ping 通 google！\n\n## 参考\n\n* [mac 终端实现翻墙](https://kerminate.me/2018/10/22/mac-%E7%BB%88%E7%AB%AF%E5%AE%9E%E7%8E%B0%E7%BF%BB%E5%A2%99/)\n\n\n","slug":"Mac-Terminal-终端代理配置","published":1,"updated":"2020-01-14T03:35:49.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vf3000wn2cbkknezig6","content":"<p>本文讲解如何给 Mac 系统终端配置 Http 代理设置，代理我们使用 Shadowsocks。经常在命令行终端下工作的码农们，SS无法正常工作。因为在终端下不支持socks5代理，只支持http代理，这就很尴尬了。像常用的 wget、curl、git、brew 等命令行工具执行会很慢。</p>\n<a id=\"more\"></a>\n<h2 id=\"配置过程\"><a href=\"#配置过程\" class=\"headerlink\" title=\"配置过程\"></a>配置过程</h2><ol>\n<li>~/.bash_profile 文件配置代理开关</li>\n</ol>\n<p>在 Mac 终端用 vim 编辑器打开 <code>~/.bash_profile</code>环境变量配置文件，添加如下配置代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ------terminal http proxy ----------</span><br><span class=\"line\">function proxy_on() &#123;</span><br><span class=\"line\">    export http_proxy = http://127.0.0.1:1087</span><br><span class=\"line\">    export https_proxy = http://127.0.0.1:1087</span><br><span class=\"line\">    echo - e &quot;已开启代理&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function proxy_off() &#123;</span><br><span class=\"line\">    unset http_proxy</span><br><span class=\"line\">    unset https_proxy</span><br><span class=\"line\">    echo - e &quot;已关闭代理&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：<code>http://127.0.0.1:1087</code>表示使用本地回环 ip 地址，端口是 Shadowsocks 开启的 HTTP 代理端口。具体可在 Shadowsocks 偏好设置里查看，如果没有开启 HTTP 代理，需要开启一下！</p>\n<p><img desc=\"Shadowsocks-Preferences\" src=\"shadowsocks_preferences.jpg\" width=\"60%\" height=\"60%\"></p>\n<ol start=\"2\">\n<li>在终端直接运行 <code>proxy_on</code>即可打开终端 http 代理，<code>proxy_off</code> 关闭代理</li>\n</ol>\n<p>运行命令<code>curl ip.gs</code>来检查是否开启成功！</p>\n<p><img desc=\"检查代理效果\" src=\"terminal_ping.jpg\" width=\"80%\" height=\"50%\"></p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><ul>\n<li>wikipedia 关于<a href=\"https://zh.wikipedia.org/zh-hans/Shadowsocks\" target=\"_blank\" rel=\"noopener\"> Shadowsocks</a>的介绍如下：</li>\n</ul>\n<blockquote>\n<p>Shadowsocks（简称SS）是一种基于Socks5代理方式的加密传输协议，Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。<br>Shadowsocks的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。例如，用户无法直接访问Google，但代理服务器可以访问，且用户可以直接连接代理服务器，那么用户就可以通过特定软件连接代理服务器，然后由代理服务器获取网站内容并回传给用户，从而实现代理上网的效果。另外用户在成功连接到服务器后，客户端会在本机构建一个本地Socks5代理（或VPN、透明代理等）。浏览网络时，网络流量需要先通过本地代理传递到客户端软件，然后才能发送到服务器端，反之亦然。</p>\n</blockquote>\n<ul>\n<li>关于如何配置客户端和服务端代理，可以查看博主的另一篇博客  <a href=\"http://nelsonblog.me/2018/03/25/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E5%A7%BF%E5%8A%BF%EF%BC%8C%E5%B8%AE%E4%BD%A0%E8%A7%A3%E5%86%B3%E7%BF%BB%E5%A2%99%E4%B8%8A%E7%BD%91%E7%9A%84%E7%83%A6%E6%81%BC/\" target=\"_blank\" rel=\"noopener\">科学上网的姿势，帮你解决翻墙上网的烦恼</a></li>\n</ul>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ul>\n<li>终端代理已经显示国外的 ip，但是还是 ping 不通，为什么？</li>\n</ul>\n<p>ss 代理是基于 tcp 或者 udp 协议，而 ping 是走的 icmp 协议因此在 ss 下不能 ping 通 google！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://kerminate.me/2018/10/22/mac-%E7%BB%88%E7%AB%AF%E5%AE%9E%E7%8E%B0%E7%BF%BB%E5%A2%99/\" target=\"_blank\" rel=\"noopener\">mac 终端实现翻墙</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文讲解如何给 Mac 系统终端配置 Http 代理设置，代理我们使用 Shadowsocks。经常在命令行终端下工作的码农们，SS无法正常工作。因为在终端下不支持socks5代理，只支持http代理，这就很尴尬了。像常用的 wget、curl、git、brew 等命令行工具执行会很慢。</p>","more":"<h2 id=\"配置过程\"><a href=\"#配置过程\" class=\"headerlink\" title=\"配置过程\"></a>配置过程</h2><ol>\n<li>~/.bash_profile 文件配置代理开关</li>\n</ol>\n<p>在 Mac 终端用 vim 编辑器打开 <code>~/.bash_profile</code>环境变量配置文件，添加如下配置代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ------terminal http proxy ----------</span><br><span class=\"line\">function proxy_on() &#123;</span><br><span class=\"line\">    export http_proxy = http://127.0.0.1:1087</span><br><span class=\"line\">    export https_proxy = http://127.0.0.1:1087</span><br><span class=\"line\">    echo - e &quot;已开启代理&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function proxy_off() &#123;</span><br><span class=\"line\">    unset http_proxy</span><br><span class=\"line\">    unset https_proxy</span><br><span class=\"line\">    echo - e &quot;已关闭代理&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：<code>http://127.0.0.1:1087</code>表示使用本地回环 ip 地址，端口是 Shadowsocks 开启的 HTTP 代理端口。具体可在 Shadowsocks 偏好设置里查看，如果没有开启 HTTP 代理，需要开启一下！</p>\n<p><img desc=\"Shadowsocks-Preferences\" src=\"shadowsocks_preferences.jpg\" width=\"60%\" height=\"60%\"></p>\n<ol start=\"2\">\n<li>在终端直接运行 <code>proxy_on</code>即可打开终端 http 代理，<code>proxy_off</code> 关闭代理</li>\n</ol>\n<p>运行命令<code>curl ip.gs</code>来检查是否开启成功！</p>\n<p><img desc=\"检查代理效果\" src=\"terminal_ping.jpg\" width=\"80%\" height=\"50%\"></p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><ul>\n<li>wikipedia 关于<a href=\"https://zh.wikipedia.org/zh-hans/Shadowsocks\" target=\"_blank\" rel=\"noopener\"> Shadowsocks</a>的介绍如下：</li>\n</ul>\n<blockquote>\n<p>Shadowsocks（简称SS）是一种基于Socks5代理方式的加密传输协议，Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。<br>Shadowsocks的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。例如，用户无法直接访问Google，但代理服务器可以访问，且用户可以直接连接代理服务器，那么用户就可以通过特定软件连接代理服务器，然后由代理服务器获取网站内容并回传给用户，从而实现代理上网的效果。另外用户在成功连接到服务器后，客户端会在本机构建一个本地Socks5代理（或VPN、透明代理等）。浏览网络时，网络流量需要先通过本地代理传递到客户端软件，然后才能发送到服务器端，反之亦然。</p>\n</blockquote>\n<ul>\n<li>关于如何配置客户端和服务端代理，可以查看博主的另一篇博客  <a href=\"http://nelsonblog.me/2018/03/25/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E5%A7%BF%E5%8A%BF%EF%BC%8C%E5%B8%AE%E4%BD%A0%E8%A7%A3%E5%86%B3%E7%BF%BB%E5%A2%99%E4%B8%8A%E7%BD%91%E7%9A%84%E7%83%A6%E6%81%BC/\" target=\"_blank\" rel=\"noopener\">科学上网的姿势，帮你解决翻墙上网的烦恼</a></li>\n</ul>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ul>\n<li>终端代理已经显示国外的 ip，但是还是 ping 不通，为什么？</li>\n</ul>\n<p>ss 代理是基于 tcp 或者 udp 协议，而 ping 是走的 icmp 协议因此在 ss 下不能 ping 通 google！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://kerminate.me/2018/10/22/mac-%E7%BB%88%E7%AB%AF%E5%AE%9E%E7%8E%B0%E7%BF%BB%E5%A2%99/\" target=\"_blank\" rel=\"noopener\">mac 终端实现翻墙</a></li>\n</ul>"},{"title":"Mac 外接硬盘安装操作系统的那些事","date":"2019-11-24T16:06:21.000Z","_content":"\n本文主要讲解如何使用外接移动硬盘来安装操作系统（MacOs 和 win10），博主使用的移动硬盘为三星 T5。\n\n<!-- more -->\n\n## 固态硬盘安装mac\n\n方法一：（需要两块移动硬盘）\n\n首先，您需要把数据+系统，通过“时间机器”备份到外置磁盘A中，然后使用“时间机器”恢复到外置磁盘B中\n\n方法二：（只需一块移动硬盘）\n\n* 首先把Mac系统制作到外置SSD中\n* 然后把数据导入到外置SSD中的Mac系统内\n\n1. 外置SSD抹盘，macOS扩展日志式+GUID分区图方案\n2. 进入Mac恢复分区，在“macOS实用工具”中，点击“重新安装macOS”\n3. 最后选择安装到外置SSD\n4. 完成操作后，开机时按住option不松手，选择外置SSD进入系统\n5. 最后拷贝转移原来Mac电脑中的数据\n6. 到家后，把SSD插入家里的Mac电脑中，按住option，选择外置SSD启动进入系统，完成\n\n## 固态硬盘安装 win10\n\n准备：\n\n* windows 10 专业版 64 位 iso 镜像文件\n* WTG 辅助工具 \n\n![WTG 安装界面](wtg_setup.jpg)\n\n![安装过程](installation_process.jpg)\n\n[小容量Mac用户必看——苹果电脑外接硬盘安装windows教程](https://post.smzdm.com/p/736280/)\n\nWin10 激活工具\n\n[最简单的WIN10激活工具（永久激活）](https://blog.csdn.net/weixin_45313590/article/details/93883300)\n\n## 其他\n\nmac 格式化\n\n* [移动硬盘无法被格式化为APFS格式 只有macOS扩展日志式 怎么办 急！！！在线等！！！](https://www.macx.cn/thread-2217347-1-1.html)\n* [如何恢复已分区的移动硬盘，分区成为Mac os 日志式](https://bbs.feng.com/read-htm-tid-11885702.html)\n\n## 参考\n\n* [给Macbook Pro更换固态硬盘并转移系统的最简单办法](https://www.cnblogs.com/guogangj/p/4051894.html)\n* [用外置 SSD 拯救你的老 Mac](https://zhuanlan.zhihu.com/p/30528652)\n\n\n","source":"_posts/Mac-外接硬盘安装操作系统的那些事.md","raw":"---\ntitle: Mac 外接硬盘安装操作系统的那些事\ndate: 2019-11-25 00:06:21\ntags: Mac\ncategories: Mac\n---\n\n本文主要讲解如何使用外接移动硬盘来安装操作系统（MacOs 和 win10），博主使用的移动硬盘为三星 T5。\n\n<!-- more -->\n\n## 固态硬盘安装mac\n\n方法一：（需要两块移动硬盘）\n\n首先，您需要把数据+系统，通过“时间机器”备份到外置磁盘A中，然后使用“时间机器”恢复到外置磁盘B中\n\n方法二：（只需一块移动硬盘）\n\n* 首先把Mac系统制作到外置SSD中\n* 然后把数据导入到外置SSD中的Mac系统内\n\n1. 外置SSD抹盘，macOS扩展日志式+GUID分区图方案\n2. 进入Mac恢复分区，在“macOS实用工具”中，点击“重新安装macOS”\n3. 最后选择安装到外置SSD\n4. 完成操作后，开机时按住option不松手，选择外置SSD进入系统\n5. 最后拷贝转移原来Mac电脑中的数据\n6. 到家后，把SSD插入家里的Mac电脑中，按住option，选择外置SSD启动进入系统，完成\n\n## 固态硬盘安装 win10\n\n准备：\n\n* windows 10 专业版 64 位 iso 镜像文件\n* WTG 辅助工具 \n\n![WTG 安装界面](wtg_setup.jpg)\n\n![安装过程](installation_process.jpg)\n\n[小容量Mac用户必看——苹果电脑外接硬盘安装windows教程](https://post.smzdm.com/p/736280/)\n\nWin10 激活工具\n\n[最简单的WIN10激活工具（永久激活）](https://blog.csdn.net/weixin_45313590/article/details/93883300)\n\n## 其他\n\nmac 格式化\n\n* [移动硬盘无法被格式化为APFS格式 只有macOS扩展日志式 怎么办 急！！！在线等！！！](https://www.macx.cn/thread-2217347-1-1.html)\n* [如何恢复已分区的移动硬盘，分区成为Mac os 日志式](https://bbs.feng.com/read-htm-tid-11885702.html)\n\n## 参考\n\n* [给Macbook Pro更换固态硬盘并转移系统的最简单办法](https://www.cnblogs.com/guogangj/p/4051894.html)\n* [用外置 SSD 拯救你的老 Mac](https://zhuanlan.zhihu.com/p/30528652)\n\n\n","slug":"Mac-外接硬盘安装操作系统的那些事","published":1,"updated":"2020-01-14T03:35:49.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vf40011n2cbqetkp2pm","content":"<p>本文主要讲解如何使用外接移动硬盘来安装操作系统（MacOs 和 win10），博主使用的移动硬盘为三星 T5。</p>\n<a id=\"more\"></a>\n<h2 id=\"固态硬盘安装mac\"><a href=\"#固态硬盘安装mac\" class=\"headerlink\" title=\"固态硬盘安装mac\"></a>固态硬盘安装mac</h2><p>方法一：（需要两块移动硬盘）</p>\n<p>首先，您需要把数据+系统，通过“时间机器”备份到外置磁盘A中，然后使用“时间机器”恢复到外置磁盘B中</p>\n<p>方法二：（只需一块移动硬盘）</p>\n<ul>\n<li>首先把Mac系统制作到外置SSD中</li>\n<li>然后把数据导入到外置SSD中的Mac系统内</li>\n</ul>\n<ol>\n<li>外置SSD抹盘，macOS扩展日志式+GUID分区图方案</li>\n<li>进入Mac恢复分区，在“macOS实用工具”中，点击“重新安装macOS”</li>\n<li>最后选择安装到外置SSD</li>\n<li>完成操作后，开机时按住option不松手，选择外置SSD进入系统</li>\n<li>最后拷贝转移原来Mac电脑中的数据</li>\n<li>到家后，把SSD插入家里的Mac电脑中，按住option，选择外置SSD启动进入系统，完成</li>\n</ol>\n<h2 id=\"固态硬盘安装-win10\"><a href=\"#固态硬盘安装-win10\" class=\"headerlink\" title=\"固态硬盘安装 win10\"></a>固态硬盘安装 win10</h2><p>准备：</p>\n<ul>\n<li>windows 10 专业版 64 位 iso 镜像文件</li>\n<li>WTG 辅助工具 </li>\n</ul>\n<p><img src=\"wtg_setup.jpg\" alt=\"WTG 安装界面\"></p>\n<p><img src=\"installation_process.jpg\" alt=\"安装过程\"></p>\n<p><a href=\"https://post.smzdm.com/p/736280/\" target=\"_blank\" rel=\"noopener\">小容量Mac用户必看——苹果电脑外接硬盘安装windows教程</a></p>\n<p>Win10 激活工具</p>\n<p><a href=\"https://blog.csdn.net/weixin_45313590/article/details/93883300\" target=\"_blank\" rel=\"noopener\">最简单的WIN10激活工具（永久激活）</a></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>mac 格式化</p>\n<ul>\n<li><a href=\"https://www.macx.cn/thread-2217347-1-1.html\" target=\"_blank\" rel=\"noopener\">移动硬盘无法被格式化为APFS格式 只有macOS扩展日志式 怎么办 急！！！在线等！！！</a></li>\n<li><a href=\"https://bbs.feng.com/read-htm-tid-11885702.html\" target=\"_blank\" rel=\"noopener\">如何恢复已分区的移动硬盘，分区成为Mac os 日志式</a></li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.cnblogs.com/guogangj/p/4051894.html\" target=\"_blank\" rel=\"noopener\">给Macbook Pro更换固态硬盘并转移系统的最简单办法</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/30528652\" target=\"_blank\" rel=\"noopener\">用外置 SSD 拯救你的老 Mac</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文主要讲解如何使用外接移动硬盘来安装操作系统（MacOs 和 win10），博主使用的移动硬盘为三星 T5。</p>","more":"<h2 id=\"固态硬盘安装mac\"><a href=\"#固态硬盘安装mac\" class=\"headerlink\" title=\"固态硬盘安装mac\"></a>固态硬盘安装mac</h2><p>方法一：（需要两块移动硬盘）</p>\n<p>首先，您需要把数据+系统，通过“时间机器”备份到外置磁盘A中，然后使用“时间机器”恢复到外置磁盘B中</p>\n<p>方法二：（只需一块移动硬盘）</p>\n<ul>\n<li>首先把Mac系统制作到外置SSD中</li>\n<li>然后把数据导入到外置SSD中的Mac系统内</li>\n</ul>\n<ol>\n<li>外置SSD抹盘，macOS扩展日志式+GUID分区图方案</li>\n<li>进入Mac恢复分区，在“macOS实用工具”中，点击“重新安装macOS”</li>\n<li>最后选择安装到外置SSD</li>\n<li>完成操作后，开机时按住option不松手，选择外置SSD进入系统</li>\n<li>最后拷贝转移原来Mac电脑中的数据</li>\n<li>到家后，把SSD插入家里的Mac电脑中，按住option，选择外置SSD启动进入系统，完成</li>\n</ol>\n<h2 id=\"固态硬盘安装-win10\"><a href=\"#固态硬盘安装-win10\" class=\"headerlink\" title=\"固态硬盘安装 win10\"></a>固态硬盘安装 win10</h2><p>准备：</p>\n<ul>\n<li>windows 10 专业版 64 位 iso 镜像文件</li>\n<li>WTG 辅助工具 </li>\n</ul>\n<p><img src=\"wtg_setup.jpg\" alt=\"WTG 安装界面\"></p>\n<p><img src=\"installation_process.jpg\" alt=\"安装过程\"></p>\n<p><a href=\"https://post.smzdm.com/p/736280/\" target=\"_blank\" rel=\"noopener\">小容量Mac用户必看——苹果电脑外接硬盘安装windows教程</a></p>\n<p>Win10 激活工具</p>\n<p><a href=\"https://blog.csdn.net/weixin_45313590/article/details/93883300\" target=\"_blank\" rel=\"noopener\">最简单的WIN10激活工具（永久激活）</a></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>mac 格式化</p>\n<ul>\n<li><a href=\"https://www.macx.cn/thread-2217347-1-1.html\" target=\"_blank\" rel=\"noopener\">移动硬盘无法被格式化为APFS格式 只有macOS扩展日志式 怎么办 急！！！在线等！！！</a></li>\n<li><a href=\"https://bbs.feng.com/read-htm-tid-11885702.html\" target=\"_blank\" rel=\"noopener\">如何恢复已分区的移动硬盘，分区成为Mac os 日志式</a></li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.cnblogs.com/guogangj/p/4051894.html\" target=\"_blank\" rel=\"noopener\">给Macbook Pro更换固态硬盘并转移系统的最简单办法</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/30528652\" target=\"_blank\" rel=\"noopener\">用外置 SSD 拯救你的老 Mac</a></li>\n</ul>"},{"title":"Replugin 源码分析1-源码导入阅读","date":"2020-01-14T03:45:40.000Z","_content":"\n## 前言\n\n本文会讲解如何导入阅读 Android 热门插件化项目 [RePlugin](https://github.com/Qihoo360/RePlugin)，这个项目由 360 手机卫士客户端团队开发。号称只用一处 Hook 点（ClassLoader）来完成，详细信息请移步 [Replugin wiki](https://github.com/Qihoo360/RePlugin/wiki) 查看。\n\n<!-- more -->\n\n## RePlugin 工程\n\n[Replugin](https://github.com/Qihoo360/RePlugin) 源码 clone 下来，目录结构如下：\n\n<img desc=\"Replugin 源码目录结构\" src=\"replugin_source_dir.jpg\" width=\"30%\"/>\n\nRePlugin 框架本身是基于 Android Studio 开发的，主要包括两种类型的库：\n\n* Android Library\n* Gradle 插件\n\n每种库又分为宿主和插件，最后 RePlugin 包括五部分：\n\n* replugin-host-gradle （宿主 gradle 插件，生成清单占坑文件、自定义属性文件等）\n* replugin-host-lib （Replugin 核心 Java 工程）\n* rplugin-plugin-gradle（插件 Gradle 插件，动态生修改 activity 继承、provider 重定向等）\n* replugin-plugin-lib（通过 Java 反射调用主程序中 replugin-host-gradle 相关接口，并提供「双向通信」的能力）\n* replugin-sample、replugin-sample-extra （Replugin 使用演示工程，包含宿主和插件的演示）\n\n## 导入 Android Studio\n\n* 源码导入\n\nReplugin 源码工程中 host & plugin 的 gradle 插件是个 Android library，library 项目是个 Android Application，不能一次性导入到一个工程看查看源码，所以我们需要新建个 AS 空项目，把上面介绍的工程通过 `import module`的方式导入进来，导入进来就可以方便插件它的源码了。\n\n如图，replugin_source_reading 是我创建的一个空项目，依次点击 toolbar  -> File -> New -> Import Module 把 replugin-host-gradle、replugin-host-library、replugin-plugin-gradle、replugin-plugin-library 四个 module 导入进来，到这里就把 Replugin 源码环境搭建起来了。\n\n<img desc=\"源码库导入 AS\" src=\"replugin_source_reading.jpg\" width=\"60%\"/>\n\n* sample demo 导入\n\n    1. replugin-sample：包括 host、plugin 演示工程，都是 Android Application 的，所以只能分别导入成一个个 Android 工程来运行\n    2. replugin-sample-extra：包括 fresco host & plugin 演示工程，展示宿主和插件公共一份代码的能力，和 replugin-sample 一样导入就行\n    \n如图，导入实例工程和其它 Android App 一样，选择你要导入的 demo 工程导入即可。\n\n<img desc=\"Replugin host demo\" src=\"replugin_host_demo.jpg\" width=\"50%\" height=\"50%\"/>\n<img desc=\"Replugin plugin demo\" src=\"replugin_plugin_demo.jpg\" width=\"50%\" height=\"50%\" />\n\n\n## 参考\n\n* [Github/Replugin](https://github.com/Qihoo360/RePlugin)\n* [RePlugin阅读源码环境搭建](https://www.jianshu.com/p/2244bab4b2d5)\n\n","source":"_posts/Replugin-源码分析1-源码导入阅读.md","raw":"---\ntitle: Replugin 源码分析1-源码导入阅读\ndate: 2020-01-14 11:45:40\ncategories: [Android]\ntags: [Android, 插件化]\n---\n\n## 前言\n\n本文会讲解如何导入阅读 Android 热门插件化项目 [RePlugin](https://github.com/Qihoo360/RePlugin)，这个项目由 360 手机卫士客户端团队开发。号称只用一处 Hook 点（ClassLoader）来完成，详细信息请移步 [Replugin wiki](https://github.com/Qihoo360/RePlugin/wiki) 查看。\n\n<!-- more -->\n\n## RePlugin 工程\n\n[Replugin](https://github.com/Qihoo360/RePlugin) 源码 clone 下来，目录结构如下：\n\n<img desc=\"Replugin 源码目录结构\" src=\"replugin_source_dir.jpg\" width=\"30%\"/>\n\nRePlugin 框架本身是基于 Android Studio 开发的，主要包括两种类型的库：\n\n* Android Library\n* Gradle 插件\n\n每种库又分为宿主和插件，最后 RePlugin 包括五部分：\n\n* replugin-host-gradle （宿主 gradle 插件，生成清单占坑文件、自定义属性文件等）\n* replugin-host-lib （Replugin 核心 Java 工程）\n* rplugin-plugin-gradle（插件 Gradle 插件，动态生修改 activity 继承、provider 重定向等）\n* replugin-plugin-lib（通过 Java 反射调用主程序中 replugin-host-gradle 相关接口，并提供「双向通信」的能力）\n* replugin-sample、replugin-sample-extra （Replugin 使用演示工程，包含宿主和插件的演示）\n\n## 导入 Android Studio\n\n* 源码导入\n\nReplugin 源码工程中 host & plugin 的 gradle 插件是个 Android library，library 项目是个 Android Application，不能一次性导入到一个工程看查看源码，所以我们需要新建个 AS 空项目，把上面介绍的工程通过 `import module`的方式导入进来，导入进来就可以方便插件它的源码了。\n\n如图，replugin_source_reading 是我创建的一个空项目，依次点击 toolbar  -> File -> New -> Import Module 把 replugin-host-gradle、replugin-host-library、replugin-plugin-gradle、replugin-plugin-library 四个 module 导入进来，到这里就把 Replugin 源码环境搭建起来了。\n\n<img desc=\"源码库导入 AS\" src=\"replugin_source_reading.jpg\" width=\"60%\"/>\n\n* sample demo 导入\n\n    1. replugin-sample：包括 host、plugin 演示工程，都是 Android Application 的，所以只能分别导入成一个个 Android 工程来运行\n    2. replugin-sample-extra：包括 fresco host & plugin 演示工程，展示宿主和插件公共一份代码的能力，和 replugin-sample 一样导入就行\n    \n如图，导入实例工程和其它 Android App 一样，选择你要导入的 demo 工程导入即可。\n\n<img desc=\"Replugin host demo\" src=\"replugin_host_demo.jpg\" width=\"50%\" height=\"50%\"/>\n<img desc=\"Replugin plugin demo\" src=\"replugin_plugin_demo.jpg\" width=\"50%\" height=\"50%\" />\n\n\n## 参考\n\n* [Github/Replugin](https://github.com/Qihoo360/RePlugin)\n* [RePlugin阅读源码环境搭建](https://www.jianshu.com/p/2244bab4b2d5)\n\n","slug":"Replugin-源码分析1-源码导入阅读","published":1,"updated":"2020-01-16T07:33:06.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vf60014n2cb6ik1shyg","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文会讲解如何导入阅读 Android 热门插件化项目 <a href=\"https://github.com/Qihoo360/RePlugin\" target=\"_blank\" rel=\"noopener\">RePlugin</a>，这个项目由 360 手机卫士客户端团队开发。号称只用一处 Hook 点（ClassLoader）来完成，详细信息请移步 <a href=\"https://github.com/Qihoo360/RePlugin/wiki\" target=\"_blank\" rel=\"noopener\">Replugin wiki</a> 查看。</p>\n<a id=\"more\"></a>\n<h2 id=\"RePlugin-工程\"><a href=\"#RePlugin-工程\" class=\"headerlink\" title=\"RePlugin 工程\"></a>RePlugin 工程</h2><p><a href=\"https://github.com/Qihoo360/RePlugin\" target=\"_blank\" rel=\"noopener\">Replugin</a> 源码 clone 下来，目录结构如下：</p>\n<p><img desc=\"Replugin 源码目录结构\" src=\"replugin_source_dir.jpg\" width=\"30%\"></p>\n<p>RePlugin 框架本身是基于 Android Studio 开发的，主要包括两种类型的库：</p>\n<ul>\n<li>Android Library</li>\n<li>Gradle 插件</li>\n</ul>\n<p>每种库又分为宿主和插件，最后 RePlugin 包括五部分：</p>\n<ul>\n<li>replugin-host-gradle （宿主 gradle 插件，生成清单占坑文件、自定义属性文件等）</li>\n<li>replugin-host-lib （Replugin 核心 Java 工程）</li>\n<li>rplugin-plugin-gradle（插件 Gradle 插件，动态生修改 activity 继承、provider 重定向等）</li>\n<li>replugin-plugin-lib（通过 Java 反射调用主程序中 replugin-host-gradle 相关接口，并提供「双向通信」的能力）</li>\n<li>replugin-sample、replugin-sample-extra （Replugin 使用演示工程，包含宿主和插件的演示）</li>\n</ul>\n<h2 id=\"导入-Android-Studio\"><a href=\"#导入-Android-Studio\" class=\"headerlink\" title=\"导入 Android Studio\"></a>导入 Android Studio</h2><ul>\n<li>源码导入</li>\n</ul>\n<p>Replugin 源码工程中 host &amp; plugin 的 gradle 插件是个 Android library，library 项目是个 Android Application，不能一次性导入到一个工程看查看源码，所以我们需要新建个 AS 空项目，把上面介绍的工程通过 <code>import module</code>的方式导入进来，导入进来就可以方便插件它的源码了。</p>\n<p>如图，replugin_source_reading 是我创建的一个空项目，依次点击 toolbar  -&gt; File -&gt; New -&gt; Import Module 把 replugin-host-gradle、replugin-host-library、replugin-plugin-gradle、replugin-plugin-library 四个 module 导入进来，到这里就把 Replugin 源码环境搭建起来了。</p>\n<p><img desc=\"源码库导入 AS\" src=\"replugin_source_reading.jpg\" width=\"60%\"></p>\n<ul>\n<li><p>sample demo 导入</p>\n<ol>\n<li>replugin-sample：包括 host、plugin 演示工程，都是 Android Application 的，所以只能分别导入成一个个 Android 工程来运行</li>\n<li>replugin-sample-extra：包括 fresco host &amp; plugin 演示工程，展示宿主和插件公共一份代码的能力，和 replugin-sample 一样导入就行</li>\n</ol>\n</li>\n</ul>\n<p>如图，导入实例工程和其它 Android App 一样，选择你要导入的 demo 工程导入即可。</p>\n<p><img desc=\"Replugin host demo\" src=\"replugin_host_demo.jpg\" width=\"50%\" height=\"50%\"><br><img desc=\"Replugin plugin demo\" src=\"replugin_plugin_demo.jpg\" width=\"50%\" height=\"50%\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/Qihoo360/RePlugin\" target=\"_blank\" rel=\"noopener\">Github/Replugin</a></li>\n<li><a href=\"https://www.jianshu.com/p/2244bab4b2d5\" target=\"_blank\" rel=\"noopener\">RePlugin阅读源码环境搭建</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文会讲解如何导入阅读 Android 热门插件化项目 <a href=\"https://github.com/Qihoo360/RePlugin\" target=\"_blank\" rel=\"noopener\">RePlugin</a>，这个项目由 360 手机卫士客户端团队开发。号称只用一处 Hook 点（ClassLoader）来完成，详细信息请移步 <a href=\"https://github.com/Qihoo360/RePlugin/wiki\" target=\"_blank\" rel=\"noopener\">Replugin wiki</a> 查看。</p>","more":"<h2 id=\"RePlugin-工程\"><a href=\"#RePlugin-工程\" class=\"headerlink\" title=\"RePlugin 工程\"></a>RePlugin 工程</h2><p><a href=\"https://github.com/Qihoo360/RePlugin\" target=\"_blank\" rel=\"noopener\">Replugin</a> 源码 clone 下来，目录结构如下：</p>\n<p><img desc=\"Replugin 源码目录结构\" src=\"replugin_source_dir.jpg\" width=\"30%\"></p>\n<p>RePlugin 框架本身是基于 Android Studio 开发的，主要包括两种类型的库：</p>\n<ul>\n<li>Android Library</li>\n<li>Gradle 插件</li>\n</ul>\n<p>每种库又分为宿主和插件，最后 RePlugin 包括五部分：</p>\n<ul>\n<li>replugin-host-gradle （宿主 gradle 插件，生成清单占坑文件、自定义属性文件等）</li>\n<li>replugin-host-lib （Replugin 核心 Java 工程）</li>\n<li>rplugin-plugin-gradle（插件 Gradle 插件，动态生修改 activity 继承、provider 重定向等）</li>\n<li>replugin-plugin-lib（通过 Java 反射调用主程序中 replugin-host-gradle 相关接口，并提供「双向通信」的能力）</li>\n<li>replugin-sample、replugin-sample-extra （Replugin 使用演示工程，包含宿主和插件的演示）</li>\n</ul>\n<h2 id=\"导入-Android-Studio\"><a href=\"#导入-Android-Studio\" class=\"headerlink\" title=\"导入 Android Studio\"></a>导入 Android Studio</h2><ul>\n<li>源码导入</li>\n</ul>\n<p>Replugin 源码工程中 host &amp; plugin 的 gradle 插件是个 Android library，library 项目是个 Android Application，不能一次性导入到一个工程看查看源码，所以我们需要新建个 AS 空项目，把上面介绍的工程通过 <code>import module</code>的方式导入进来，导入进来就可以方便插件它的源码了。</p>\n<p>如图，replugin_source_reading 是我创建的一个空项目，依次点击 toolbar  -&gt; File -&gt; New -&gt; Import Module 把 replugin-host-gradle、replugin-host-library、replugin-plugin-gradle、replugin-plugin-library 四个 module 导入进来，到这里就把 Replugin 源码环境搭建起来了。</p>\n<p><img desc=\"源码库导入 AS\" src=\"replugin_source_reading.jpg\" width=\"60%\"></p>\n<ul>\n<li><p>sample demo 导入</p>\n<ol>\n<li>replugin-sample：包括 host、plugin 演示工程，都是 Android Application 的，所以只能分别导入成一个个 Android 工程来运行</li>\n<li>replugin-sample-extra：包括 fresco host &amp; plugin 演示工程，展示宿主和插件公共一份代码的能力，和 replugin-sample 一样导入就行</li>\n</ol>\n</li>\n</ul>\n<p>如图，导入实例工程和其它 Android App 一样，选择你要导入的 demo 工程导入即可。</p>\n<p><img desc=\"Replugin host demo\" src=\"replugin_host_demo.jpg\" width=\"50%\" height=\"50%\"><br><img desc=\"Replugin plugin demo\" src=\"replugin_plugin_demo.jpg\" width=\"50%\" height=\"50%\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/Qihoo360/RePlugin\" target=\"_blank\" rel=\"noopener\">Github/Replugin</a></li>\n<li><a href=\"https://www.jianshu.com/p/2244bab4b2d5\" target=\"_blank\" rel=\"noopener\">RePlugin阅读源码环境搭建</a></li>\n</ul>"},{"title":"Retrofit 几个疑问解答","date":"2019-11-24T16:01:08.000Z","_content":"\n这篇文章是关于 Retrofit 使用的几个疑问解答！\n\n<!-- more -->\n\n## 问题一：Retrofit的 baseUrl 必须以 / (斜线)结尾吗？\n\nbaseUrl 如果为 `https://api.github.com` 则会自动转换为 `https://api.github.com/`；如果为 `https://api.github.com/repos` 没有 / 结尾，会抛异常。\n\n路径生成规则表格如下：\n\nBaseUrl  | Path对应的值 |最后Url |\n---|---|---\nhttp://host:port/a/b/ | /apath | http://host:port/apath\nhttp://host:port/a/b/ | apath | http://host:port/a/b/apath\nhttp://host:port/a/b/ | \thttp://host:port/aa/apath | http://host:port/aa/apath\n\n## 问题二：如何在请求时使用动态URL？\n\n可以使用拦截器和在单个请求上使用注解 `@Url` 来定义结点。例子如下：\n\n* 案例一：\n\n```java\nRetrofit retrofit = Retrofit.Builder()  \n    .baseUrl(\"https://your.api.url/\");\n    .build();\n\nUserService service = retrofit.create(UserService.class);  \nservice.profilePicture(\"https://s3.amazon.com/profile-picture/path\");\n\n// 最后请求地址\n// request url results in:\n// https://s3.amazon.com/profile-picture/path\n```\n\n由于通过 `@Url` 设置了完全不同的包含 scheme 的 host （https://s3.amazon.com），Okhttp 的 HttpUrl 会解析它为我们设置的 url，所以直接忽略 base url，使用我们传入带 scheme 的地址。\n\n* 案例二：\n\n```java\nRetrofit retrofit = Retrofit.Builder()  \n    .baseUrl(\"https://your.api.url/\");\n    .build();\n\nUserService service = retrofit.create(UserService.class);  \nservice.profilePicture(\"profile-picture/path\");\n\n// request url results in:\n// https://your.api.url/profile-picture/path\n```\n\n我们请求中传入的 `@Url` 没有指定 scheme 和 host，所以最后的请求会使用我们定义的 base url 和动态结点 url 联系起来，生成一个请求地址。*具体拼接规则，请看问题一图示表格！*\n\n* 案例三：\n\n```java\nRetrofit retrofit = Retrofit.Builder()  \n    .baseUrl(\"https://your.api.url/v2/\");\n    .build();\n\nUserService service = retrofit.create(UserService.class);  \nservice.profilePicture(\"/profile-picture/path\");\n\n// request url results in:\n// https://your.api.url/profile-picture/path\n```\n\n这个例子和第二个案例不同的是，我们在 base url 的 host 后面添加了 `v2/` 和结点 url 的前面多了一个 `/`。实际上这将导致添加到 base url 后面的 `v2/`被舍弃，host 直接连接结点的 url。*具体拼接规则，请看问题一图示表格！*\n\n## 问题三：如何在给 Retrofit 添加 header 参数？\n\n* 方法一：方法使用注解\n\n```java\npublic interface UserService {  \n    // @Headers(\"Cache-Control: max-age=640000\")\n    // @Headers({\"Accept: application/json\", \"User-Agent: Your-App-Name\"})\n    @GET(\"/tasks\")\n    Call<List<Task>> getTasks();\n}\n```\n\n在单个请求上添加多个 header，`@Headers`注解支持传递一个或者多个 header。\n\n* 方法二：使用拦截器\n\n```java\n\nOkHttpClient.Builder httpClient = new OkHttpClient.Builder();  \nhttpClient.addInterceptor(new Interceptor() {  \n    @Override\n    public Response intercept(Interceptor.Chain chain) throws IOException {\n        Request original = chain.request();\n        Request request = original.newBuilder()\n            .header(\"User-Agent\", \"Your-App-Name\")\n            .header(\"Accept\", \"application/vnd.yourapi.v1.full+json\")\n            .method(original.method(), original.body())\n            .build();\n \n        return chain.proceed(request);\n    }\n}\n \nOkHttpClient client = httpClient.build();  \nRetrofit retrofit = new Retrofit.Builder()  \n    .baseUrl(API_BASE_URL)\n    .addConverterFactory(GsonConverterFactory.create())\n    .client(client)\n    .build();\n```\n\n使用 OkHttp 的拦截器拦截请求，给请求添加 headers。\n\n* 方法三：函数参数使用注解，动态 Header\n\n```java\n\npublic interface UserService {  \n    @GET(\"/tasks\")\n    Call<List<Task>> getTasks(@Header(\"Content-Range\") String contentRange);\n}\n```\n\n给单个请求动态添加 header。\n\n> 其中方法一和方法三很相似，为什么还要提供方法三呢？举个例子，例如我只想给某个请求的 header 添加一个 key 为 `sso`，value 为用户登录 token 时，方法一就没有办法做到，在函数注解上无法使用表达式，而用方法三就很方便，通过参数传递进去就可以了！\n\n\n## 参考\n\n* [Retrofit2 的baseUrl 真的必须以 /（斜线） 结尾吗？](https://www.jianshu.com/p/d6b8b6bc6209)\n* [Retrofit2-如何在请求时使用动态URL](https://www.jianshu.com/p/4268e434150a)\n* [Retrofit 2 — How to Use Dynamic Urls for Requests](https://futurestud.io/tutorials/retrofit-2-how-to-use-dynamic-urls-for-requests)\n* [Github/以最简洁的 Api 让 Retrofit 同时支持多个 BaseUrl 以及动态改变 BaseUrl](https://github.com/JessYanCoding/RetrofitUrlManager)\n* [Retrofit添加header参数的几种方法](https://blog.csdn.net/zhuhai__yizhi/article/details/52956719)\n\n","source":"_posts/Retrofit-几个疑问解答.md","raw":"---\ntitle: Retrofit 几个疑问解答\ndate: 2019-11-25 00:01:08\ntags: Android\ncategories: Android\n---\n\n这篇文章是关于 Retrofit 使用的几个疑问解答！\n\n<!-- more -->\n\n## 问题一：Retrofit的 baseUrl 必须以 / (斜线)结尾吗？\n\nbaseUrl 如果为 `https://api.github.com` 则会自动转换为 `https://api.github.com/`；如果为 `https://api.github.com/repos` 没有 / 结尾，会抛异常。\n\n路径生成规则表格如下：\n\nBaseUrl  | Path对应的值 |最后Url |\n---|---|---\nhttp://host:port/a/b/ | /apath | http://host:port/apath\nhttp://host:port/a/b/ | apath | http://host:port/a/b/apath\nhttp://host:port/a/b/ | \thttp://host:port/aa/apath | http://host:port/aa/apath\n\n## 问题二：如何在请求时使用动态URL？\n\n可以使用拦截器和在单个请求上使用注解 `@Url` 来定义结点。例子如下：\n\n* 案例一：\n\n```java\nRetrofit retrofit = Retrofit.Builder()  \n    .baseUrl(\"https://your.api.url/\");\n    .build();\n\nUserService service = retrofit.create(UserService.class);  \nservice.profilePicture(\"https://s3.amazon.com/profile-picture/path\");\n\n// 最后请求地址\n// request url results in:\n// https://s3.amazon.com/profile-picture/path\n```\n\n由于通过 `@Url` 设置了完全不同的包含 scheme 的 host （https://s3.amazon.com），Okhttp 的 HttpUrl 会解析它为我们设置的 url，所以直接忽略 base url，使用我们传入带 scheme 的地址。\n\n* 案例二：\n\n```java\nRetrofit retrofit = Retrofit.Builder()  \n    .baseUrl(\"https://your.api.url/\");\n    .build();\n\nUserService service = retrofit.create(UserService.class);  \nservice.profilePicture(\"profile-picture/path\");\n\n// request url results in:\n// https://your.api.url/profile-picture/path\n```\n\n我们请求中传入的 `@Url` 没有指定 scheme 和 host，所以最后的请求会使用我们定义的 base url 和动态结点 url 联系起来，生成一个请求地址。*具体拼接规则，请看问题一图示表格！*\n\n* 案例三：\n\n```java\nRetrofit retrofit = Retrofit.Builder()  \n    .baseUrl(\"https://your.api.url/v2/\");\n    .build();\n\nUserService service = retrofit.create(UserService.class);  \nservice.profilePicture(\"/profile-picture/path\");\n\n// request url results in:\n// https://your.api.url/profile-picture/path\n```\n\n这个例子和第二个案例不同的是，我们在 base url 的 host 后面添加了 `v2/` 和结点 url 的前面多了一个 `/`。实际上这将导致添加到 base url 后面的 `v2/`被舍弃，host 直接连接结点的 url。*具体拼接规则，请看问题一图示表格！*\n\n## 问题三：如何在给 Retrofit 添加 header 参数？\n\n* 方法一：方法使用注解\n\n```java\npublic interface UserService {  \n    // @Headers(\"Cache-Control: max-age=640000\")\n    // @Headers({\"Accept: application/json\", \"User-Agent: Your-App-Name\"})\n    @GET(\"/tasks\")\n    Call<List<Task>> getTasks();\n}\n```\n\n在单个请求上添加多个 header，`@Headers`注解支持传递一个或者多个 header。\n\n* 方法二：使用拦截器\n\n```java\n\nOkHttpClient.Builder httpClient = new OkHttpClient.Builder();  \nhttpClient.addInterceptor(new Interceptor() {  \n    @Override\n    public Response intercept(Interceptor.Chain chain) throws IOException {\n        Request original = chain.request();\n        Request request = original.newBuilder()\n            .header(\"User-Agent\", \"Your-App-Name\")\n            .header(\"Accept\", \"application/vnd.yourapi.v1.full+json\")\n            .method(original.method(), original.body())\n            .build();\n \n        return chain.proceed(request);\n    }\n}\n \nOkHttpClient client = httpClient.build();  \nRetrofit retrofit = new Retrofit.Builder()  \n    .baseUrl(API_BASE_URL)\n    .addConverterFactory(GsonConverterFactory.create())\n    .client(client)\n    .build();\n```\n\n使用 OkHttp 的拦截器拦截请求，给请求添加 headers。\n\n* 方法三：函数参数使用注解，动态 Header\n\n```java\n\npublic interface UserService {  \n    @GET(\"/tasks\")\n    Call<List<Task>> getTasks(@Header(\"Content-Range\") String contentRange);\n}\n```\n\n给单个请求动态添加 header。\n\n> 其中方法一和方法三很相似，为什么还要提供方法三呢？举个例子，例如我只想给某个请求的 header 添加一个 key 为 `sso`，value 为用户登录 token 时，方法一就没有办法做到，在函数注解上无法使用表达式，而用方法三就很方便，通过参数传递进去就可以了！\n\n\n## 参考\n\n* [Retrofit2 的baseUrl 真的必须以 /（斜线） 结尾吗？](https://www.jianshu.com/p/d6b8b6bc6209)\n* [Retrofit2-如何在请求时使用动态URL](https://www.jianshu.com/p/4268e434150a)\n* [Retrofit 2 — How to Use Dynamic Urls for Requests](https://futurestud.io/tutorials/retrofit-2-how-to-use-dynamic-urls-for-requests)\n* [Github/以最简洁的 Api 让 Retrofit 同时支持多个 BaseUrl 以及动态改变 BaseUrl](https://github.com/JessYanCoding/RetrofitUrlManager)\n* [Retrofit添加header参数的几种方法](https://blog.csdn.net/zhuhai__yizhi/article/details/52956719)\n\n","slug":"Retrofit-几个疑问解答","published":1,"updated":"2020-01-14T03:35:49.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vf70018n2cb51tdh6ys","content":"<p>这篇文章是关于 Retrofit 使用的几个疑问解答！</p>\n<a id=\"more\"></a>\n<h2 id=\"问题一：Retrofit的-baseUrl-必须以-斜线-结尾吗？\"><a href=\"#问题一：Retrofit的-baseUrl-必须以-斜线-结尾吗？\" class=\"headerlink\" title=\"问题一：Retrofit的 baseUrl 必须以 / (斜线)结尾吗？\"></a>问题一：Retrofit的 baseUrl 必须以 / (斜线)结尾吗？</h2><p>baseUrl 如果为 <code>https://api.github.com</code> 则会自动转换为 <code>https://api.github.com/</code>；如果为 <code>https://api.github.com/repos</code> 没有 / 结尾，会抛异常。</p>\n<p>路径生成规则表格如下：</p>\n<table>\n<thead>\n<tr>\n<th>BaseUrl</th>\n<th>Path对应的值</th>\n<th>最后Url</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://host:port/a/b/\" target=\"_blank\" rel=\"noopener\">http://host:port/a/b/</a></td>\n<td>/apath</td>\n<td><a href=\"http://host:port/apath\" target=\"_blank\" rel=\"noopener\">http://host:port/apath</a></td>\n</tr>\n<tr>\n<td><a href=\"http://host:port/a/b/\" target=\"_blank\" rel=\"noopener\">http://host:port/a/b/</a></td>\n<td>apath</td>\n<td><a href=\"http://host:port/a/b/apath\" target=\"_blank\" rel=\"noopener\">http://host:port/a/b/apath</a></td>\n</tr>\n<tr>\n<td><a href=\"http://host:port/a/b/\" target=\"_blank\" rel=\"noopener\">http://host:port/a/b/</a></td>\n<td><a href=\"http://host:port/aa/apath\" target=\"_blank\" rel=\"noopener\">http://host:port/aa/apath</a></td>\n<td><a href=\"http://host:port/aa/apath\" target=\"_blank\" rel=\"noopener\">http://host:port/aa/apath</a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"问题二：如何在请求时使用动态URL？\"><a href=\"#问题二：如何在请求时使用动态URL？\" class=\"headerlink\" title=\"问题二：如何在请求时使用动态URL？\"></a>问题二：如何在请求时使用动态URL？</h2><p>可以使用拦截器和在单个请求上使用注解 <code>@Url</code> 来定义结点。例子如下：</p>\n<ul>\n<li>案例一：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = Retrofit.Builder()  </span><br><span class=\"line\">    .baseUrl(<span class=\"string\">\"https://your.api.url/\"</span>);</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">UserService service = retrofit.create(UserService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;  </span><br><span class=\"line\">service.profilePicture(<span class=\"string\">\"https://s3.amazon.com/profile-picture/path\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最后请求地址</span></span><br><span class=\"line\"><span class=\"comment\">// request url results in:</span></span><br><span class=\"line\"><span class=\"comment\">// https://s3.amazon.com/profile-picture/path</span></span><br></pre></td></tr></table></figure>\n<p>由于通过 <code>@Url</code> 设置了完全不同的包含 scheme 的 host （<a href=\"https://s3.amazon.com），Okhttp\" target=\"_blank\" rel=\"noopener\">https://s3.amazon.com），Okhttp</a> 的 HttpUrl 会解析它为我们设置的 url，所以直接忽略 base url，使用我们传入带 scheme 的地址。</p>\n<ul>\n<li>案例二：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = Retrofit.Builder()  </span><br><span class=\"line\">    .baseUrl(<span class=\"string\">\"https://your.api.url/\"</span>);</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">UserService service = retrofit.create(UserService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;  </span><br><span class=\"line\">service.profilePicture(<span class=\"string\">\"profile-picture/path\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// request url results in:</span></span><br><span class=\"line\"><span class=\"comment\">// https://your.api.url/profile-picture/path</span></span><br></pre></td></tr></table></figure>\n<p>我们请求中传入的 <code>@Url</code> 没有指定 scheme 和 host，所以最后的请求会使用我们定义的 base url 和动态结点 url 联系起来，生成一个请求地址。<em>具体拼接规则，请看问题一图示表格！</em></p>\n<ul>\n<li>案例三：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = Retrofit.Builder()  </span><br><span class=\"line\">    .baseUrl(<span class=\"string\">\"https://your.api.url/v2/\"</span>);</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">UserService service = retrofit.create(UserService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;  </span><br><span class=\"line\">service.profilePicture(<span class=\"string\">\"/profile-picture/path\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// request url results in:</span></span><br><span class=\"line\"><span class=\"comment\">// https://your.api.url/profile-picture/path</span></span><br></pre></td></tr></table></figure>\n<p>这个例子和第二个案例不同的是，我们在 base url 的 host 后面添加了 <code>v2/</code> 和结点 url 的前面多了一个 <code>/</code>。实际上这将导致添加到 base url 后面的 <code>v2/</code>被舍弃，host 直接连接结点的 url。<em>具体拼接规则，请看问题一图示表格！</em></p>\n<h2 id=\"问题三：如何在给-Retrofit-添加-header-参数？\"><a href=\"#问题三：如何在给-Retrofit-添加-header-参数？\" class=\"headerlink\" title=\"问题三：如何在给 Retrofit 添加 header 参数？\"></a>问题三：如何在给 Retrofit 添加 header 参数？</h2><ul>\n<li>方法一：方法使用注解</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// @Headers(\"Cache-Control: max-age=640000\")</span></span><br><span class=\"line\">    <span class=\"comment\">// @Headers(&#123;\"Accept: application/json\", \"User-Agent: Your-App-Name\"&#125;)</span></span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/tasks\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;Task&gt;&gt; getTasks();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在单个请求上添加多个 header，<code>@Headers</code>注解支持传递一个或者多个 header。</p>\n<ul>\n<li>方法二：使用拦截器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">OkHttpClient.Builder httpClient = <span class=\"keyword\">new</span> OkHttpClient.Builder();  </span><br><span class=\"line\">httpClient.addInterceptor(<span class=\"keyword\">new</span> Interceptor() &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Interceptor.Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Request original = chain.request();</span><br><span class=\"line\">        Request request = original.newBuilder()</span><br><span class=\"line\">            .header(<span class=\"string\">\"User-Agent\"</span>, <span class=\"string\">\"Your-App-Name\"</span>)</span><br><span class=\"line\">            .header(<span class=\"string\">\"Accept\"</span>, <span class=\"string\">\"application/vnd.yourapi.v1.full+json\"</span>)</span><br><span class=\"line\">            .method(original.method(), original.body())</span><br><span class=\"line\">            .build();</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> chain.proceed(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">OkHttpClient client = httpClient.build();  </span><br><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()  </span><br><span class=\"line\">    .baseUrl(API_BASE_URL)</span><br><span class=\"line\">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">    .client(client)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<p>使用 OkHttp 的拦截器拦截请求，给请求添加 headers。</p>\n<ul>\n<li>方法三：函数参数使用注解，动态 Header</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/tasks\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;Task&gt;&gt; getTasks(<span class=\"meta\">@Header</span>(<span class=\"string\">\"Content-Range\"</span>) String contentRange);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给单个请求动态添加 header。</p>\n<blockquote>\n<p>其中方法一和方法三很相似，为什么还要提供方法三呢？举个例子，例如我只想给某个请求的 header 添加一个 key 为 <code>sso</code>，value 为用户登录 token 时，方法一就没有办法做到，在函数注解上无法使用表达式，而用方法三就很方便，通过参数传递进去就可以了！</p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/d6b8b6bc6209\" target=\"_blank\" rel=\"noopener\">Retrofit2 的baseUrl 真的必须以 /（斜线） 结尾吗？</a></li>\n<li><a href=\"https://www.jianshu.com/p/4268e434150a\" target=\"_blank\" rel=\"noopener\">Retrofit2-如何在请求时使用动态URL</a></li>\n<li><a href=\"https://futurestud.io/tutorials/retrofit-2-how-to-use-dynamic-urls-for-requests\" target=\"_blank\" rel=\"noopener\">Retrofit 2 — How to Use Dynamic Urls for Requests</a></li>\n<li><a href=\"https://github.com/JessYanCoding/RetrofitUrlManager\" target=\"_blank\" rel=\"noopener\">Github/以最简洁的 Api 让 Retrofit 同时支持多个 BaseUrl 以及动态改变 BaseUrl</a></li>\n<li><a href=\"https://blog.csdn.net/zhuhai__yizhi/article/details/52956719\" target=\"_blank\" rel=\"noopener\">Retrofit添加header参数的几种方法</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>这篇文章是关于 Retrofit 使用的几个疑问解答！</p>","more":"<h2 id=\"问题一：Retrofit的-baseUrl-必须以-斜线-结尾吗？\"><a href=\"#问题一：Retrofit的-baseUrl-必须以-斜线-结尾吗？\" class=\"headerlink\" title=\"问题一：Retrofit的 baseUrl 必须以 / (斜线)结尾吗？\"></a>问题一：Retrofit的 baseUrl 必须以 / (斜线)结尾吗？</h2><p>baseUrl 如果为 <code>https://api.github.com</code> 则会自动转换为 <code>https://api.github.com/</code>；如果为 <code>https://api.github.com/repos</code> 没有 / 结尾，会抛异常。</p>\n<p>路径生成规则表格如下：</p>\n<table>\n<thead>\n<tr>\n<th>BaseUrl</th>\n<th>Path对应的值</th>\n<th>最后Url</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://host:port/a/b/\" target=\"_blank\" rel=\"noopener\">http://host:port/a/b/</a></td>\n<td>/apath</td>\n<td><a href=\"http://host:port/apath\" target=\"_blank\" rel=\"noopener\">http://host:port/apath</a></td>\n</tr>\n<tr>\n<td><a href=\"http://host:port/a/b/\" target=\"_blank\" rel=\"noopener\">http://host:port/a/b/</a></td>\n<td>apath</td>\n<td><a href=\"http://host:port/a/b/apath\" target=\"_blank\" rel=\"noopener\">http://host:port/a/b/apath</a></td>\n</tr>\n<tr>\n<td><a href=\"http://host:port/a/b/\" target=\"_blank\" rel=\"noopener\">http://host:port/a/b/</a></td>\n<td><a href=\"http://host:port/aa/apath\" target=\"_blank\" rel=\"noopener\">http://host:port/aa/apath</a></td>\n<td><a href=\"http://host:port/aa/apath\" target=\"_blank\" rel=\"noopener\">http://host:port/aa/apath</a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"问题二：如何在请求时使用动态URL？\"><a href=\"#问题二：如何在请求时使用动态URL？\" class=\"headerlink\" title=\"问题二：如何在请求时使用动态URL？\"></a>问题二：如何在请求时使用动态URL？</h2><p>可以使用拦截器和在单个请求上使用注解 <code>@Url</code> 来定义结点。例子如下：</p>\n<ul>\n<li>案例一：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = Retrofit.Builder()  </span><br><span class=\"line\">    .baseUrl(<span class=\"string\">\"https://your.api.url/\"</span>);</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">UserService service = retrofit.create(UserService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;  </span><br><span class=\"line\">service.profilePicture(<span class=\"string\">\"https://s3.amazon.com/profile-picture/path\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最后请求地址</span></span><br><span class=\"line\"><span class=\"comment\">// request url results in:</span></span><br><span class=\"line\"><span class=\"comment\">// https://s3.amazon.com/profile-picture/path</span></span><br></pre></td></tr></table></figure>\n<p>由于通过 <code>@Url</code> 设置了完全不同的包含 scheme 的 host （<a href=\"https://s3.amazon.com），Okhttp\" target=\"_blank\" rel=\"noopener\">https://s3.amazon.com），Okhttp</a> 的 HttpUrl 会解析它为我们设置的 url，所以直接忽略 base url，使用我们传入带 scheme 的地址。</p>\n<ul>\n<li>案例二：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = Retrofit.Builder()  </span><br><span class=\"line\">    .baseUrl(<span class=\"string\">\"https://your.api.url/\"</span>);</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">UserService service = retrofit.create(UserService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;  </span><br><span class=\"line\">service.profilePicture(<span class=\"string\">\"profile-picture/path\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// request url results in:</span></span><br><span class=\"line\"><span class=\"comment\">// https://your.api.url/profile-picture/path</span></span><br></pre></td></tr></table></figure>\n<p>我们请求中传入的 <code>@Url</code> 没有指定 scheme 和 host，所以最后的请求会使用我们定义的 base url 和动态结点 url 联系起来，生成一个请求地址。<em>具体拼接规则，请看问题一图示表格！</em></p>\n<ul>\n<li>案例三：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = Retrofit.Builder()  </span><br><span class=\"line\">    .baseUrl(<span class=\"string\">\"https://your.api.url/v2/\"</span>);</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">UserService service = retrofit.create(UserService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;  </span><br><span class=\"line\">service.profilePicture(<span class=\"string\">\"/profile-picture/path\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// request url results in:</span></span><br><span class=\"line\"><span class=\"comment\">// https://your.api.url/profile-picture/path</span></span><br></pre></td></tr></table></figure>\n<p>这个例子和第二个案例不同的是，我们在 base url 的 host 后面添加了 <code>v2/</code> 和结点 url 的前面多了一个 <code>/</code>。实际上这将导致添加到 base url 后面的 <code>v2/</code>被舍弃，host 直接连接结点的 url。<em>具体拼接规则，请看问题一图示表格！</em></p>\n<h2 id=\"问题三：如何在给-Retrofit-添加-header-参数？\"><a href=\"#问题三：如何在给-Retrofit-添加-header-参数？\" class=\"headerlink\" title=\"问题三：如何在给 Retrofit 添加 header 参数？\"></a>问题三：如何在给 Retrofit 添加 header 参数？</h2><ul>\n<li>方法一：方法使用注解</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// @Headers(\"Cache-Control: max-age=640000\")</span></span><br><span class=\"line\">    <span class=\"comment\">// @Headers(&#123;\"Accept: application/json\", \"User-Agent: Your-App-Name\"&#125;)</span></span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/tasks\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;Task&gt;&gt; getTasks();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在单个请求上添加多个 header，<code>@Headers</code>注解支持传递一个或者多个 header。</p>\n<ul>\n<li>方法二：使用拦截器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">OkHttpClient.Builder httpClient = <span class=\"keyword\">new</span> OkHttpClient.Builder();  </span><br><span class=\"line\">httpClient.addInterceptor(<span class=\"keyword\">new</span> Interceptor() &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Interceptor.Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Request original = chain.request();</span><br><span class=\"line\">        Request request = original.newBuilder()</span><br><span class=\"line\">            .header(<span class=\"string\">\"User-Agent\"</span>, <span class=\"string\">\"Your-App-Name\"</span>)</span><br><span class=\"line\">            .header(<span class=\"string\">\"Accept\"</span>, <span class=\"string\">\"application/vnd.yourapi.v1.full+json\"</span>)</span><br><span class=\"line\">            .method(original.method(), original.body())</span><br><span class=\"line\">            .build();</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> chain.proceed(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">OkHttpClient client = httpClient.build();  </span><br><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()  </span><br><span class=\"line\">    .baseUrl(API_BASE_URL)</span><br><span class=\"line\">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">    .client(client)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<p>使用 OkHttp 的拦截器拦截请求，给请求添加 headers。</p>\n<ul>\n<li>方法三：函数参数使用注解，动态 Header</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/tasks\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;Task&gt;&gt; getTasks(<span class=\"meta\">@Header</span>(<span class=\"string\">\"Content-Range\"</span>) String contentRange);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给单个请求动态添加 header。</p>\n<blockquote>\n<p>其中方法一和方法三很相似，为什么还要提供方法三呢？举个例子，例如我只想给某个请求的 header 添加一个 key 为 <code>sso</code>，value 为用户登录 token 时，方法一就没有办法做到，在函数注解上无法使用表达式，而用方法三就很方便，通过参数传递进去就可以了！</p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/d6b8b6bc6209\" target=\"_blank\" rel=\"noopener\">Retrofit2 的baseUrl 真的必须以 /（斜线） 结尾吗？</a></li>\n<li><a href=\"https://www.jianshu.com/p/4268e434150a\" target=\"_blank\" rel=\"noopener\">Retrofit2-如何在请求时使用动态URL</a></li>\n<li><a href=\"https://futurestud.io/tutorials/retrofit-2-how-to-use-dynamic-urls-for-requests\" target=\"_blank\" rel=\"noopener\">Retrofit 2 — How to Use Dynamic Urls for Requests</a></li>\n<li><a href=\"https://github.com/JessYanCoding/RetrofitUrlManager\" target=\"_blank\" rel=\"noopener\">Github/以最简洁的 Api 让 Retrofit 同时支持多个 BaseUrl 以及动态改变 BaseUrl</a></li>\n<li><a href=\"https://blog.csdn.net/zhuhai__yizhi/article/details/52956719\" target=\"_blank\" rel=\"noopener\">Retrofit添加header参数的几种方法</a></li>\n</ul>"},{"title":"Tmux 使用教程","date":"2019-12-30T15:31:55.000Z","_content":"\n相信很多人都在使用 tmux，但也可能有一些人不知道有 tmux 的存在，看看下图你就知道 tmux 是做什么的了。:）\n\n<!-- more -->\n\n![tmux-ohmyzsh](http://wanghaoxun.com/img/tmux-ohmyzsh.jpg)\n\n## 前言\n\n人最宝贵的是时间。要提高工作效率，就要熟练运用各种工具。tmux 是我日常工作中都要用到的，凡是看到朋友或公司同事用鼠标慢吞吞切换多个窗口，我都忍不住推荐并教会他们使用 tmux。好的工程师不在于年龄有多大，工作年限有多长，你会发现他们都有一个共同特点，就是很善于用工具，肯花时间去学习去配置自己每天用的工具（vim，tmux,shell 等）。他们能熟练地用快捷键在代码中游走，用快捷键熟练地切换各种窗口（比如本文要介绍的 tmux）。\n\n## 一、Tmux 是什么？\n\n![tmux-logo](http://wanghaoxun.com/img/tmux-logo.jpg)\n\nTmux 是一个非常有用的终端复用器（terminal multiplexer），一个用于在终端窗口中运行多个终端会话的工具。在 Tmux 中可以根据不同的工作任务创建不同的会话，每个会话又可以创建多个窗口来完成不同的工作，每个窗口又可以分割成很多小窗口。这些功能都是非常实用的。\n\n## 二、基本用法\n\n### 2.1 安装\n\nMacOS 中安装\n\n```\n$ brew install tmux\n```\n\n开启 oh-my-zsh tmux 插件，编辑 vim ~/.zshrc 文件，搜索找到 plugins，添加如下即可。\n\n```\nplugins=(\n  tmux\n)\n```\n### 2.2 启动与退出\n\n**安装完成后，键入 tmux 命令，就进入了 Tmux 窗口。**\n\n```\n$ tmux\n```\n\n上面命令会启动 tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。\n\n**按下 ctrl+d 或者显式输入 exit 命令，就可以退出 tmux 窗口。**\n\n```\n$ exit\n```\n\n### 2.3 前缀键\n\ntmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是 ctrl+b ，即先按下 ctrl+b ，快捷键才会生效。\n\n举例来说，帮助命令的快捷键是 ctrl+b ? 。它的用法是，在 tmux 窗口中，先按下 ctrl+b ，再按下 ? ，就会显示帮助信息。\n\n然后，按下 ESC 键或 q 键，就可以退出帮助。\n\n## 三、会话管理\n\n### 3.1 新建会话\n\n第一个启动的 tmux 窗口，编号是 0 ，第二个窗口的编号是 1 ，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。\n\n使用编号区分会话，不太直观，更好的方法是为会话起名。\n\n```\n$ tmux new -s <session-name>\n```\n\n上面命令新建一个指定名称的会话。\n\n### 3.2 分离会话\n\n在 tmux 窗口中，按下 ctrl+b d 或者输入 tmux detach 命令，就会将当前会话与窗口分离。\n\n```\n$ tmux detach\n```\n\n上面命令执行后，就会退出当前 tmux 窗口，但是会话和里面的进程仍然在后台运行。\n\ntmux ls 命令可以查看当前所有的 Tmux 会话。\n\n```\n$ tmux ls\n# or\n$ tmux list-session\n```\n### 3.3 接入会话\n\ntmux attach 命令用于重新接入某个已存在的会话。\n\n```\n# 使用会话编号\n$ tmux attach -t 0\n\n# 使用会话名称\n$ tmux attach -t <session-name>\n```\n### 3.4 杀死会话\n\ntmux kill-session 命令用于杀死某个会话。\n\n```\n# 使用会话编号\n$ tmux kill-session -t 0\n\n# 使用会话名称\n$ tmux kill-session -t <session-name>\n```\n\n### 3.5 切换会话\n\ntmux switch 命令用于切换会话。\n\n```\n# 使用会话编号\n$ tmux switch -t 0\n\n# 使用会话名称\n$ tmux switch -t <session-name>\n```\n\n### 3.6 重命名会话\n\ntmux rename-session 命令用于重命名会话。\n\n```\n$ tmux rename-session -t 0 <new-name>\n```\n\n上面命令将0号会话重命名。\n\n### 3.7 会话快捷键\n\n下面是一些会话相关的快捷键。\n\n```\nCtrl+b d\nCtrl+b s\nCtrl+b $\n```\n## 四、窗格快捷键\n\n下面是一些窗格操作的快捷键。\n\n* ctrl+b % ：划分左右两个窗格。\n* ctrl+b \" ：划分上下两个窗格。\n* ctrl+b <arrow key> ：光标切换到其他窗格。 <arrow key> 是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键 ↓ 。\n* ctrl+b ; ：光标切换到上一个窗格。\n* ctrl+b o ：光标切换到下一个窗格。\n* ctrl+b { ：当前窗格左移。\n* ctrl+b } ：当前窗格右移。\n* ctrl+b Ctrl+o ：当前窗格上移。\n* ctrl+b Alt+o ：当前窗格下移。\n* ctrl+b x ：关闭当前窗格。\n* ctrl+b ! ：将当前窗格拆分为一个独立窗口。\n* ctrl+b z ：当前窗格全屏显示，再使用一次会变回原来大小。\n* ctrl+b Ctrl+<arrow key> ：按箭头方向调整窗格大小。\n* ctrl+b q ：显示窗格编号。\n\n## 五、窗口管理\n\n除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。\n\n### 5.1 新建窗口\n\ntmux new-window 命令用来创建新窗口。\n\n```\n$ tmux new-window\n\n# 新建一个指定名称的窗口\n$ tmux new-window -n <window-name>\n```\n\n### 5.2 切换窗口\n\ntmux select-window 命令用来切换窗口。\n\n```\n# 切换到指定编号的窗口\n$ tmux select-window -t <window-number>\n\n# 切换到指定名称的窗口\n$ tmux select-window -t <window-name>\n```\n\n### 5.3 重命名窗口\n\ntmux rename-window 命令用于为当前窗口起名（或重命名）。\n\n```\n$ tmux rename-window <new-name>\n```\n\n### 5.4 窗口快捷键\n\n下面是一些窗口操作的快捷键。\n\n* ctrl+b c ：创建一个新窗口，状态栏会显示多个窗口的信息。\n* ctrl+b p ：切换到上一个窗口（按照状态栏上的顺序）。\n* ctrl+b n ：切换到下一个窗口。\n* ctrl+b <number> ：切换到指定编号的窗口，其中的 <number> 是状态栏上的窗口编号。\n* ctrl+b w ：从列表中选择窗口。\n* ctrl+b , ：窗口重命名。\n\n## 六、其他命令\n\n下面是一些其他命令。\n\n```\n# 列出所有快捷键，及其对应的 Tmux 命令\n$ tmux list-keys\n\n# 列出所有 Tmux 命令及其参数\n$ tmux list-commands\n\n# 列出当前所有 Tmux 会话的信息\n$ tmux info\n\n# 重新加载当前的 Tmux 配置\n$ tmux source-file ~/.tmux.conf\n```\n\n## Q&A\n\n* tmux 环境下 ls 目录颜色失效？\n\n如果要显示目录颜色，就得配置 LS_COLORS 或者 LSCOLORS，Mac 这种 freeBSD 系统采用的是后者，需要拷贝如下代码到 ~/.zshrc 文件中，\n\n```sh\n# LSCOLORS\nexport LSCOLORS=\"exfxcxdxbxexexabagacad\"\nalias ls='ls -G'\n```\n\nsource ~/.zshrc 重新刷新下配置，再执行就会发现已经出现颜色了！\n\n## 参考\n\n* [Tmux 使用笔记](https://www.tuicool.com/articles/FJvYJvv)\n* [Tmux 使用教程](https://www.tuicool.com/articles/JvqMNbQ)\n* [zsh中设置ls目录颜色](http://hushicai.github.io/2014/03/10/zsh-zhong-she-zhi-ls-mu-lu-yan-se.html)\n* [wanqu/tmux](https://wanqu.co/a/115/tmux/)\n\n\n","source":"_posts/Tmux-使用教程.md","raw":"---\ntitle: Tmux 使用教程\ndate: 2019-12-30 23:31:55\ntags: 工具\ncategories: 工具\n---\n\n相信很多人都在使用 tmux，但也可能有一些人不知道有 tmux 的存在，看看下图你就知道 tmux 是做什么的了。:）\n\n<!-- more -->\n\n![tmux-ohmyzsh](http://wanghaoxun.com/img/tmux-ohmyzsh.jpg)\n\n## 前言\n\n人最宝贵的是时间。要提高工作效率，就要熟练运用各种工具。tmux 是我日常工作中都要用到的，凡是看到朋友或公司同事用鼠标慢吞吞切换多个窗口，我都忍不住推荐并教会他们使用 tmux。好的工程师不在于年龄有多大，工作年限有多长，你会发现他们都有一个共同特点，就是很善于用工具，肯花时间去学习去配置自己每天用的工具（vim，tmux,shell 等）。他们能熟练地用快捷键在代码中游走，用快捷键熟练地切换各种窗口（比如本文要介绍的 tmux）。\n\n## 一、Tmux 是什么？\n\n![tmux-logo](http://wanghaoxun.com/img/tmux-logo.jpg)\n\nTmux 是一个非常有用的终端复用器（terminal multiplexer），一个用于在终端窗口中运行多个终端会话的工具。在 Tmux 中可以根据不同的工作任务创建不同的会话，每个会话又可以创建多个窗口来完成不同的工作，每个窗口又可以分割成很多小窗口。这些功能都是非常实用的。\n\n## 二、基本用法\n\n### 2.1 安装\n\nMacOS 中安装\n\n```\n$ brew install tmux\n```\n\n开启 oh-my-zsh tmux 插件，编辑 vim ~/.zshrc 文件，搜索找到 plugins，添加如下即可。\n\n```\nplugins=(\n  tmux\n)\n```\n### 2.2 启动与退出\n\n**安装完成后，键入 tmux 命令，就进入了 Tmux 窗口。**\n\n```\n$ tmux\n```\n\n上面命令会启动 tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。\n\n**按下 ctrl+d 或者显式输入 exit 命令，就可以退出 tmux 窗口。**\n\n```\n$ exit\n```\n\n### 2.3 前缀键\n\ntmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是 ctrl+b ，即先按下 ctrl+b ，快捷键才会生效。\n\n举例来说，帮助命令的快捷键是 ctrl+b ? 。它的用法是，在 tmux 窗口中，先按下 ctrl+b ，再按下 ? ，就会显示帮助信息。\n\n然后，按下 ESC 键或 q 键，就可以退出帮助。\n\n## 三、会话管理\n\n### 3.1 新建会话\n\n第一个启动的 tmux 窗口，编号是 0 ，第二个窗口的编号是 1 ，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。\n\n使用编号区分会话，不太直观，更好的方法是为会话起名。\n\n```\n$ tmux new -s <session-name>\n```\n\n上面命令新建一个指定名称的会话。\n\n### 3.2 分离会话\n\n在 tmux 窗口中，按下 ctrl+b d 或者输入 tmux detach 命令，就会将当前会话与窗口分离。\n\n```\n$ tmux detach\n```\n\n上面命令执行后，就会退出当前 tmux 窗口，但是会话和里面的进程仍然在后台运行。\n\ntmux ls 命令可以查看当前所有的 Tmux 会话。\n\n```\n$ tmux ls\n# or\n$ tmux list-session\n```\n### 3.3 接入会话\n\ntmux attach 命令用于重新接入某个已存在的会话。\n\n```\n# 使用会话编号\n$ tmux attach -t 0\n\n# 使用会话名称\n$ tmux attach -t <session-name>\n```\n### 3.4 杀死会话\n\ntmux kill-session 命令用于杀死某个会话。\n\n```\n# 使用会话编号\n$ tmux kill-session -t 0\n\n# 使用会话名称\n$ tmux kill-session -t <session-name>\n```\n\n### 3.5 切换会话\n\ntmux switch 命令用于切换会话。\n\n```\n# 使用会话编号\n$ tmux switch -t 0\n\n# 使用会话名称\n$ tmux switch -t <session-name>\n```\n\n### 3.6 重命名会话\n\ntmux rename-session 命令用于重命名会话。\n\n```\n$ tmux rename-session -t 0 <new-name>\n```\n\n上面命令将0号会话重命名。\n\n### 3.7 会话快捷键\n\n下面是一些会话相关的快捷键。\n\n```\nCtrl+b d\nCtrl+b s\nCtrl+b $\n```\n## 四、窗格快捷键\n\n下面是一些窗格操作的快捷键。\n\n* ctrl+b % ：划分左右两个窗格。\n* ctrl+b \" ：划分上下两个窗格。\n* ctrl+b <arrow key> ：光标切换到其他窗格。 <arrow key> 是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键 ↓ 。\n* ctrl+b ; ：光标切换到上一个窗格。\n* ctrl+b o ：光标切换到下一个窗格。\n* ctrl+b { ：当前窗格左移。\n* ctrl+b } ：当前窗格右移。\n* ctrl+b Ctrl+o ：当前窗格上移。\n* ctrl+b Alt+o ：当前窗格下移。\n* ctrl+b x ：关闭当前窗格。\n* ctrl+b ! ：将当前窗格拆分为一个独立窗口。\n* ctrl+b z ：当前窗格全屏显示，再使用一次会变回原来大小。\n* ctrl+b Ctrl+<arrow key> ：按箭头方向调整窗格大小。\n* ctrl+b q ：显示窗格编号。\n\n## 五、窗口管理\n\n除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。\n\n### 5.1 新建窗口\n\ntmux new-window 命令用来创建新窗口。\n\n```\n$ tmux new-window\n\n# 新建一个指定名称的窗口\n$ tmux new-window -n <window-name>\n```\n\n### 5.2 切换窗口\n\ntmux select-window 命令用来切换窗口。\n\n```\n# 切换到指定编号的窗口\n$ tmux select-window -t <window-number>\n\n# 切换到指定名称的窗口\n$ tmux select-window -t <window-name>\n```\n\n### 5.3 重命名窗口\n\ntmux rename-window 命令用于为当前窗口起名（或重命名）。\n\n```\n$ tmux rename-window <new-name>\n```\n\n### 5.4 窗口快捷键\n\n下面是一些窗口操作的快捷键。\n\n* ctrl+b c ：创建一个新窗口，状态栏会显示多个窗口的信息。\n* ctrl+b p ：切换到上一个窗口（按照状态栏上的顺序）。\n* ctrl+b n ：切换到下一个窗口。\n* ctrl+b <number> ：切换到指定编号的窗口，其中的 <number> 是状态栏上的窗口编号。\n* ctrl+b w ：从列表中选择窗口。\n* ctrl+b , ：窗口重命名。\n\n## 六、其他命令\n\n下面是一些其他命令。\n\n```\n# 列出所有快捷键，及其对应的 Tmux 命令\n$ tmux list-keys\n\n# 列出所有 Tmux 命令及其参数\n$ tmux list-commands\n\n# 列出当前所有 Tmux 会话的信息\n$ tmux info\n\n# 重新加载当前的 Tmux 配置\n$ tmux source-file ~/.tmux.conf\n```\n\n## Q&A\n\n* tmux 环境下 ls 目录颜色失效？\n\n如果要显示目录颜色，就得配置 LS_COLORS 或者 LSCOLORS，Mac 这种 freeBSD 系统采用的是后者，需要拷贝如下代码到 ~/.zshrc 文件中，\n\n```sh\n# LSCOLORS\nexport LSCOLORS=\"exfxcxdxbxexexabagacad\"\nalias ls='ls -G'\n```\n\nsource ~/.zshrc 重新刷新下配置，再执行就会发现已经出现颜色了！\n\n## 参考\n\n* [Tmux 使用笔记](https://www.tuicool.com/articles/FJvYJvv)\n* [Tmux 使用教程](https://www.tuicool.com/articles/JvqMNbQ)\n* [zsh中设置ls目录颜色](http://hushicai.github.io/2014/03/10/zsh-zhong-she-zhi-ls-mu-lu-yan-se.html)\n* [wanqu/tmux](https://wanqu.co/a/115/tmux/)\n\n\n","slug":"Tmux-使用教程","published":1,"updated":"2020-01-14T03:35:49.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vf8001an2cbar9cuafv","content":"<p>相信很多人都在使用 tmux，但也可能有一些人不知道有 tmux 的存在，看看下图你就知道 tmux 是做什么的了。:）</p>\n<a id=\"more\"></a>\n<p><img src=\"http://wanghaoxun.com/img/tmux-ohmyzsh.jpg\" alt=\"tmux-ohmyzsh\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>人最宝贵的是时间。要提高工作效率，就要熟练运用各种工具。tmux 是我日常工作中都要用到的，凡是看到朋友或公司同事用鼠标慢吞吞切换多个窗口，我都忍不住推荐并教会他们使用 tmux。好的工程师不在于年龄有多大，工作年限有多长，你会发现他们都有一个共同特点，就是很善于用工具，肯花时间去学习去配置自己每天用的工具（vim，tmux,shell 等）。他们能熟练地用快捷键在代码中游走，用快捷键熟练地切换各种窗口（比如本文要介绍的 tmux）。</p>\n<h2 id=\"一、Tmux-是什么？\"><a href=\"#一、Tmux-是什么？\" class=\"headerlink\" title=\"一、Tmux 是什么？\"></a>一、Tmux 是什么？</h2><p><img src=\"http://wanghaoxun.com/img/tmux-logo.jpg\" alt=\"tmux-logo\"></p>\n<p>Tmux 是一个非常有用的终端复用器（terminal multiplexer），一个用于在终端窗口中运行多个终端会话的工具。在 Tmux 中可以根据不同的工作任务创建不同的会话，每个会话又可以创建多个窗口来完成不同的工作，每个窗口又可以分割成很多小窗口。这些功能都是非常实用的。</p>\n<h2 id=\"二、基本用法\"><a href=\"#二、基本用法\" class=\"headerlink\" title=\"二、基本用法\"></a>二、基本用法</h2><h3 id=\"2-1-安装\"><a href=\"#2-1-安装\" class=\"headerlink\" title=\"2.1 安装\"></a>2.1 安装</h3><p>MacOS 中安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install tmux</span><br></pre></td></tr></table></figure>\n<p>开启 oh-my-zsh tmux 插件，编辑 vim ~/.zshrc 文件，搜索找到 plugins，添加如下即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins=(</span><br><span class=\"line\">  tmux</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-启动与退出\"><a href=\"#2-2-启动与退出\" class=\"headerlink\" title=\"2.2 启动与退出\"></a>2.2 启动与退出</h3><p><strong>安装完成后，键入 tmux 命令，就进入了 Tmux 窗口。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux</span><br></pre></td></tr></table></figure>\n<p>上面命令会启动 tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。</p>\n<p><strong>按下 ctrl+d 或者显式输入 exit 命令，就可以退出 tmux 窗口。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ exit</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-前缀键\"><a href=\"#2-3-前缀键\" class=\"headerlink\" title=\"2.3 前缀键\"></a>2.3 前缀键</h3><p>tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是 ctrl+b ，即先按下 ctrl+b ，快捷键才会生效。</p>\n<p>举例来说，帮助命令的快捷键是 ctrl+b ? 。它的用法是，在 tmux 窗口中，先按下 ctrl+b ，再按下 ? ，就会显示帮助信息。</p>\n<p>然后，按下 ESC 键或 q 键，就可以退出帮助。</p>\n<h2 id=\"三、会话管理\"><a href=\"#三、会话管理\" class=\"headerlink\" title=\"三、会话管理\"></a>三、会话管理</h2><h3 id=\"3-1-新建会话\"><a href=\"#3-1-新建会话\" class=\"headerlink\" title=\"3.1 新建会话\"></a>3.1 新建会话</h3><p>第一个启动的 tmux 窗口，编号是 0 ，第二个窗口的编号是 1 ，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p>\n<p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux new -s &lt;session-name&gt;</span><br></pre></td></tr></table></figure>\n<p>上面命令新建一个指定名称的会话。</p>\n<h3 id=\"3-2-分离会话\"><a href=\"#3-2-分离会话\" class=\"headerlink\" title=\"3.2 分离会话\"></a>3.2 分离会话</h3><p>在 tmux 窗口中，按下 ctrl+b d 或者输入 tmux detach 命令，就会将当前会话与窗口分离。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux detach</span><br></pre></td></tr></table></figure>\n<p>上面命令执行后，就会退出当前 tmux 窗口，但是会话和里面的进程仍然在后台运行。</p>\n<p>tmux ls 命令可以查看当前所有的 Tmux 会话。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux ls</span><br><span class=\"line\"># or</span><br><span class=\"line\">$ tmux list-session</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-接入会话\"><a href=\"#3-3-接入会话\" class=\"headerlink\" title=\"3.3 接入会话\"></a>3.3 接入会话</h3><p>tmux attach 命令用于重新接入某个已存在的会话。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用会话编号</span><br><span class=\"line\">$ tmux attach -t 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用会话名称</span><br><span class=\"line\">$ tmux attach -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-杀死会话\"><a href=\"#3-4-杀死会话\" class=\"headerlink\" title=\"3.4 杀死会话\"></a>3.4 杀死会话</h3><p>tmux kill-session 命令用于杀死某个会话。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用会话编号</span><br><span class=\"line\">$ tmux kill-session -t 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用会话名称</span><br><span class=\"line\">$ tmux kill-session -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-切换会话\"><a href=\"#3-5-切换会话\" class=\"headerlink\" title=\"3.5 切换会话\"></a>3.5 切换会话</h3><p>tmux switch 命令用于切换会话。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用会话编号</span><br><span class=\"line\">$ tmux switch -t 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用会话名称</span><br><span class=\"line\">$ tmux switch -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-重命名会话\"><a href=\"#3-6-重命名会话\" class=\"headerlink\" title=\"3.6 重命名会话\"></a>3.6 重命名会话</h3><p>tmux rename-session 命令用于重命名会话。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux rename-session -t 0 &lt;new-name&gt;</span><br></pre></td></tr></table></figure>\n<p>上面命令将0号会话重命名。</p>\n<h3 id=\"3-7-会话快捷键\"><a href=\"#3-7-会话快捷键\" class=\"headerlink\" title=\"3.7 会话快捷键\"></a>3.7 会话快捷键</h3><p>下面是一些会话相关的快捷键。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ctrl+b d</span><br><span class=\"line\">Ctrl+b s</span><br><span class=\"line\">Ctrl+b $</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、窗格快捷键\"><a href=\"#四、窗格快捷键\" class=\"headerlink\" title=\"四、窗格快捷键\"></a>四、窗格快捷键</h2><p>下面是一些窗格操作的快捷键。</p>\n<ul>\n<li>ctrl+b % ：划分左右两个窗格。</li>\n<li>ctrl+b “ ：划分上下两个窗格。</li>\n<li>ctrl+b <arrow key> ：光标切换到其他窗格。 <arrow key> 是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键 ↓ 。</arrow></arrow></li>\n<li>ctrl+b ; ：光标切换到上一个窗格。</li>\n<li>ctrl+b o ：光标切换到下一个窗格。</li>\n<li>ctrl+b { ：当前窗格左移。</li>\n<li>ctrl+b } ：当前窗格右移。</li>\n<li>ctrl+b Ctrl+o ：当前窗格上移。</li>\n<li>ctrl+b Alt+o ：当前窗格下移。</li>\n<li>ctrl+b x ：关闭当前窗格。</li>\n<li>ctrl+b ! ：将当前窗格拆分为一个独立窗口。</li>\n<li>ctrl+b z ：当前窗格全屏显示，再使用一次会变回原来大小。</li>\n<li>ctrl+b Ctrl+<arrow key> ：按箭头方向调整窗格大小。</arrow></li>\n<li>ctrl+b q ：显示窗格编号。</li>\n</ul>\n<h2 id=\"五、窗口管理\"><a href=\"#五、窗口管理\" class=\"headerlink\" title=\"五、窗口管理\"></a>五、窗口管理</h2><p>除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。</p>\n<h3 id=\"5-1-新建窗口\"><a href=\"#5-1-新建窗口\" class=\"headerlink\" title=\"5.1 新建窗口\"></a>5.1 新建窗口</h3><p>tmux new-window 命令用来创建新窗口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux new-window</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个指定名称的窗口</span><br><span class=\"line\">$ tmux new-window -n &lt;window-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-2-切换窗口\"><a href=\"#5-2-切换窗口\" class=\"headerlink\" title=\"5.2 切换窗口\"></a>5.2 切换窗口</h3><p>tmux select-window 命令用来切换窗口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 切换到指定编号的窗口</span><br><span class=\"line\">$ tmux select-window -t &lt;window-number&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到指定名称的窗口</span><br><span class=\"line\">$ tmux select-window -t &lt;window-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-3-重命名窗口\"><a href=\"#5-3-重命名窗口\" class=\"headerlink\" title=\"5.3 重命名窗口\"></a>5.3 重命名窗口</h3><p>tmux rename-window 命令用于为当前窗口起名（或重命名）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux rename-window &lt;new-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-4-窗口快捷键\"><a href=\"#5-4-窗口快捷键\" class=\"headerlink\" title=\"5.4 窗口快捷键\"></a>5.4 窗口快捷键</h3><p>下面是一些窗口操作的快捷键。</p>\n<ul>\n<li>ctrl+b c ：创建一个新窗口，状态栏会显示多个窗口的信息。</li>\n<li>ctrl+b p ：切换到上一个窗口（按照状态栏上的顺序）。</li>\n<li>ctrl+b n ：切换到下一个窗口。</li>\n<li>ctrl+b <number> ：切换到指定编号的窗口，其中的 <number> 是状态栏上的窗口编号。</number></number></li>\n<li>ctrl+b w ：从列表中选择窗口。</li>\n<li>ctrl+b , ：窗口重命名。</li>\n</ul>\n<h2 id=\"六、其他命令\"><a href=\"#六、其他命令\" class=\"headerlink\" title=\"六、其他命令\"></a>六、其他命令</h2><p>下面是一些其他命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出所有快捷键，及其对应的 Tmux 命令</span><br><span class=\"line\">$ tmux list-keys</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有 Tmux 命令及其参数</span><br><span class=\"line\">$ tmux list-commands</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出当前所有 Tmux 会话的信息</span><br><span class=\"line\">$ tmux info</span><br><span class=\"line\"></span><br><span class=\"line\"># 重新加载当前的 Tmux 配置</span><br><span class=\"line\">$ tmux source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ul>\n<li>tmux 环境下 ls 目录颜色失效？</li>\n</ul>\n<p>如果要显示目录颜色，就得配置 LS_COLORS 或者 LSCOLORS，Mac 这种 freeBSD 系统采用的是后者，需要拷贝如下代码到 ~/.zshrc 文件中，</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># LSCOLORS</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> LSCOLORS=<span class=\"string\">\"exfxcxdxbxexexabagacad\"</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> ls=<span class=\"string\">'ls -G'</span></span><br></pre></td></tr></table></figure>\n<p>source ~/.zshrc 重新刷新下配置，再执行就会发现已经出现颜色了！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.tuicool.com/articles/FJvYJvv\" target=\"_blank\" rel=\"noopener\">Tmux 使用笔记</a></li>\n<li><a href=\"https://www.tuicool.com/articles/JvqMNbQ\" target=\"_blank\" rel=\"noopener\">Tmux 使用教程</a></li>\n<li><a href=\"http://hushicai.github.io/2014/03/10/zsh-zhong-she-zhi-ls-mu-lu-yan-se.html\" target=\"_blank\" rel=\"noopener\">zsh中设置ls目录颜色</a></li>\n<li><a href=\"https://wanqu.co/a/115/tmux/\" target=\"_blank\" rel=\"noopener\">wanqu/tmux</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>相信很多人都在使用 tmux，但也可能有一些人不知道有 tmux 的存在，看看下图你就知道 tmux 是做什么的了。:）</p>","more":"<p><img src=\"http://wanghaoxun.com/img/tmux-ohmyzsh.jpg\" alt=\"tmux-ohmyzsh\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>人最宝贵的是时间。要提高工作效率，就要熟练运用各种工具。tmux 是我日常工作中都要用到的，凡是看到朋友或公司同事用鼠标慢吞吞切换多个窗口，我都忍不住推荐并教会他们使用 tmux。好的工程师不在于年龄有多大，工作年限有多长，你会发现他们都有一个共同特点，就是很善于用工具，肯花时间去学习去配置自己每天用的工具（vim，tmux,shell 等）。他们能熟练地用快捷键在代码中游走，用快捷键熟练地切换各种窗口（比如本文要介绍的 tmux）。</p>\n<h2 id=\"一、Tmux-是什么？\"><a href=\"#一、Tmux-是什么？\" class=\"headerlink\" title=\"一、Tmux 是什么？\"></a>一、Tmux 是什么？</h2><p><img src=\"http://wanghaoxun.com/img/tmux-logo.jpg\" alt=\"tmux-logo\"></p>\n<p>Tmux 是一个非常有用的终端复用器（terminal multiplexer），一个用于在终端窗口中运行多个终端会话的工具。在 Tmux 中可以根据不同的工作任务创建不同的会话，每个会话又可以创建多个窗口来完成不同的工作，每个窗口又可以分割成很多小窗口。这些功能都是非常实用的。</p>\n<h2 id=\"二、基本用法\"><a href=\"#二、基本用法\" class=\"headerlink\" title=\"二、基本用法\"></a>二、基本用法</h2><h3 id=\"2-1-安装\"><a href=\"#2-1-安装\" class=\"headerlink\" title=\"2.1 安装\"></a>2.1 安装</h3><p>MacOS 中安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install tmux</span><br></pre></td></tr></table></figure>\n<p>开启 oh-my-zsh tmux 插件，编辑 vim ~/.zshrc 文件，搜索找到 plugins，添加如下即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins=(</span><br><span class=\"line\">  tmux</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-启动与退出\"><a href=\"#2-2-启动与退出\" class=\"headerlink\" title=\"2.2 启动与退出\"></a>2.2 启动与退出</h3><p><strong>安装完成后，键入 tmux 命令，就进入了 Tmux 窗口。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux</span><br></pre></td></tr></table></figure>\n<p>上面命令会启动 tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。</p>\n<p><strong>按下 ctrl+d 或者显式输入 exit 命令，就可以退出 tmux 窗口。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ exit</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-前缀键\"><a href=\"#2-3-前缀键\" class=\"headerlink\" title=\"2.3 前缀键\"></a>2.3 前缀键</h3><p>tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是 ctrl+b ，即先按下 ctrl+b ，快捷键才会生效。</p>\n<p>举例来说，帮助命令的快捷键是 ctrl+b ? 。它的用法是，在 tmux 窗口中，先按下 ctrl+b ，再按下 ? ，就会显示帮助信息。</p>\n<p>然后，按下 ESC 键或 q 键，就可以退出帮助。</p>\n<h2 id=\"三、会话管理\"><a href=\"#三、会话管理\" class=\"headerlink\" title=\"三、会话管理\"></a>三、会话管理</h2><h3 id=\"3-1-新建会话\"><a href=\"#3-1-新建会话\" class=\"headerlink\" title=\"3.1 新建会话\"></a>3.1 新建会话</h3><p>第一个启动的 tmux 窗口，编号是 0 ，第二个窗口的编号是 1 ，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p>\n<p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux new -s &lt;session-name&gt;</span><br></pre></td></tr></table></figure>\n<p>上面命令新建一个指定名称的会话。</p>\n<h3 id=\"3-2-分离会话\"><a href=\"#3-2-分离会话\" class=\"headerlink\" title=\"3.2 分离会话\"></a>3.2 分离会话</h3><p>在 tmux 窗口中，按下 ctrl+b d 或者输入 tmux detach 命令，就会将当前会话与窗口分离。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux detach</span><br></pre></td></tr></table></figure>\n<p>上面命令执行后，就会退出当前 tmux 窗口，但是会话和里面的进程仍然在后台运行。</p>\n<p>tmux ls 命令可以查看当前所有的 Tmux 会话。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux ls</span><br><span class=\"line\"># or</span><br><span class=\"line\">$ tmux list-session</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-接入会话\"><a href=\"#3-3-接入会话\" class=\"headerlink\" title=\"3.3 接入会话\"></a>3.3 接入会话</h3><p>tmux attach 命令用于重新接入某个已存在的会话。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用会话编号</span><br><span class=\"line\">$ tmux attach -t 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用会话名称</span><br><span class=\"line\">$ tmux attach -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-杀死会话\"><a href=\"#3-4-杀死会话\" class=\"headerlink\" title=\"3.4 杀死会话\"></a>3.4 杀死会话</h3><p>tmux kill-session 命令用于杀死某个会话。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用会话编号</span><br><span class=\"line\">$ tmux kill-session -t 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用会话名称</span><br><span class=\"line\">$ tmux kill-session -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-切换会话\"><a href=\"#3-5-切换会话\" class=\"headerlink\" title=\"3.5 切换会话\"></a>3.5 切换会话</h3><p>tmux switch 命令用于切换会话。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用会话编号</span><br><span class=\"line\">$ tmux switch -t 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用会话名称</span><br><span class=\"line\">$ tmux switch -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-重命名会话\"><a href=\"#3-6-重命名会话\" class=\"headerlink\" title=\"3.6 重命名会话\"></a>3.6 重命名会话</h3><p>tmux rename-session 命令用于重命名会话。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux rename-session -t 0 &lt;new-name&gt;</span><br></pre></td></tr></table></figure>\n<p>上面命令将0号会话重命名。</p>\n<h3 id=\"3-7-会话快捷键\"><a href=\"#3-7-会话快捷键\" class=\"headerlink\" title=\"3.7 会话快捷键\"></a>3.7 会话快捷键</h3><p>下面是一些会话相关的快捷键。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ctrl+b d</span><br><span class=\"line\">Ctrl+b s</span><br><span class=\"line\">Ctrl+b $</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、窗格快捷键\"><a href=\"#四、窗格快捷键\" class=\"headerlink\" title=\"四、窗格快捷键\"></a>四、窗格快捷键</h2><p>下面是一些窗格操作的快捷键。</p>\n<ul>\n<li>ctrl+b % ：划分左右两个窗格。</li>\n<li>ctrl+b “ ：划分上下两个窗格。</li>\n<li>ctrl+b <arrow key> ：光标切换到其他窗格。 <arrow key> 是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键 ↓ 。</arrow></arrow></li>\n<li>ctrl+b ; ：光标切换到上一个窗格。</li>\n<li>ctrl+b o ：光标切换到下一个窗格。</li>\n<li>ctrl+b { ：当前窗格左移。</li>\n<li>ctrl+b } ：当前窗格右移。</li>\n<li>ctrl+b Ctrl+o ：当前窗格上移。</li>\n<li>ctrl+b Alt+o ：当前窗格下移。</li>\n<li>ctrl+b x ：关闭当前窗格。</li>\n<li>ctrl+b ! ：将当前窗格拆分为一个独立窗口。</li>\n<li>ctrl+b z ：当前窗格全屏显示，再使用一次会变回原来大小。</li>\n<li>ctrl+b Ctrl+<arrow key> ：按箭头方向调整窗格大小。</arrow></li>\n<li>ctrl+b q ：显示窗格编号。</li>\n</ul>\n<h2 id=\"五、窗口管理\"><a href=\"#五、窗口管理\" class=\"headerlink\" title=\"五、窗口管理\"></a>五、窗口管理</h2><p>除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。</p>\n<h3 id=\"5-1-新建窗口\"><a href=\"#5-1-新建窗口\" class=\"headerlink\" title=\"5.1 新建窗口\"></a>5.1 新建窗口</h3><p>tmux new-window 命令用来创建新窗口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux new-window</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个指定名称的窗口</span><br><span class=\"line\">$ tmux new-window -n &lt;window-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-2-切换窗口\"><a href=\"#5-2-切换窗口\" class=\"headerlink\" title=\"5.2 切换窗口\"></a>5.2 切换窗口</h3><p>tmux select-window 命令用来切换窗口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 切换到指定编号的窗口</span><br><span class=\"line\">$ tmux select-window -t &lt;window-number&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到指定名称的窗口</span><br><span class=\"line\">$ tmux select-window -t &lt;window-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-3-重命名窗口\"><a href=\"#5-3-重命名窗口\" class=\"headerlink\" title=\"5.3 重命名窗口\"></a>5.3 重命名窗口</h3><p>tmux rename-window 命令用于为当前窗口起名（或重命名）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tmux rename-window &lt;new-name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-4-窗口快捷键\"><a href=\"#5-4-窗口快捷键\" class=\"headerlink\" title=\"5.4 窗口快捷键\"></a>5.4 窗口快捷键</h3><p>下面是一些窗口操作的快捷键。</p>\n<ul>\n<li>ctrl+b c ：创建一个新窗口，状态栏会显示多个窗口的信息。</li>\n<li>ctrl+b p ：切换到上一个窗口（按照状态栏上的顺序）。</li>\n<li>ctrl+b n ：切换到下一个窗口。</li>\n<li>ctrl+b <number> ：切换到指定编号的窗口，其中的 <number> 是状态栏上的窗口编号。</number></number></li>\n<li>ctrl+b w ：从列表中选择窗口。</li>\n<li>ctrl+b , ：窗口重命名。</li>\n</ul>\n<h2 id=\"六、其他命令\"><a href=\"#六、其他命令\" class=\"headerlink\" title=\"六、其他命令\"></a>六、其他命令</h2><p>下面是一些其他命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出所有快捷键，及其对应的 Tmux 命令</span><br><span class=\"line\">$ tmux list-keys</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有 Tmux 命令及其参数</span><br><span class=\"line\">$ tmux list-commands</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出当前所有 Tmux 会话的信息</span><br><span class=\"line\">$ tmux info</span><br><span class=\"line\"></span><br><span class=\"line\"># 重新加载当前的 Tmux 配置</span><br><span class=\"line\">$ tmux source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ul>\n<li>tmux 环境下 ls 目录颜色失效？</li>\n</ul>\n<p>如果要显示目录颜色，就得配置 LS_COLORS 或者 LSCOLORS，Mac 这种 freeBSD 系统采用的是后者，需要拷贝如下代码到 ~/.zshrc 文件中，</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># LSCOLORS</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> LSCOLORS=<span class=\"string\">\"exfxcxdxbxexexabagacad\"</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> ls=<span class=\"string\">'ls -G'</span></span><br></pre></td></tr></table></figure>\n<p>source ~/.zshrc 重新刷新下配置，再执行就会发现已经出现颜色了！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.tuicool.com/articles/FJvYJvv\" target=\"_blank\" rel=\"noopener\">Tmux 使用笔记</a></li>\n<li><a href=\"https://www.tuicool.com/articles/JvqMNbQ\" target=\"_blank\" rel=\"noopener\">Tmux 使用教程</a></li>\n<li><a href=\"http://hushicai.github.io/2014/03/10/zsh-zhong-she-zhi-ls-mu-lu-yan-se.html\" target=\"_blank\" rel=\"noopener\">zsh中设置ls目录颜色</a></li>\n<li><a href=\"https://wanqu.co/a/115/tmux/\" target=\"_blank\" rel=\"noopener\">wanqu/tmux</a></li>\n</ul>"},{"title":"Vim 常用命令","date":"2019-10-07T02:22:07.000Z","_content":"\n本文介绍 Vim 常用操作命令及快捷键，算是入门级使用。\n\n<!-- more -->\n\n## 一、打开、保存、关闭文件\n\n* :w    保存文件\n* :w    vpser.net 保存至 vpser.net 文件\n* :q    退出编辑器，如果文件已修改请使用下面的命令\n* :q!   退出编辑器，且不保存\n* :wq   退出编辑器，且保存文件\n\n:w 要保存文件路径 可以保存文件到指定路径下\n\n## 二、移动\n\n### 2.1、字符间跳转 \n\n* j 下移一行\n* k 上移一行\n* h 左移一个字符\n* l 右移一个字符\n* 空格键 向右\n* Backspace 向左\n* Enter 移动到下一行首\n* `-` 移动到上一行首\n* shift + 6 跳转到行首\n* shift + 4 跳转到行尾\n\n### 2.2、单词间跳转\n\n* w：跳转至下一个单词或后一个单词的词首\n* e：跳转至当前或下一个单词的词尾\n* b：跳转至当前或上一个单词的词首\n* `#COMMAND` 由#指定一次跳转的单词数\n\n## 三、跳转\n\n* n+ 向下跳n行\n* n- 向上跳n行\n* nG 跳到行号为n的行\n* gg 跳转到文件头\n* shift + g 跳转到文件末尾\n* G 跳至文件的底部\n* :n 代表跳转到第n行，如:79 就跳转到第79行\n\n## 四、设置行号\n\n* :set nu 显示行号\n* :set nonu 取消显示行号\n\n## 五、翻屏\n\n* ctrl + f 下翻一屏\n* ctrl + b 上翻一屏\n* ctrl + d 下翻半屏\n* ctrl + u 上翻半屏\n* ctrl + e 向下滚动一行\n* ctrl + y 向上滚动一行\n\n## 六、插入\n\n* a 在当前光标位置的右边添加文本\n* i 在当前光标位置的左边添加文本\n* A 在当前行的末尾位置添加文本\n* I 在当前行的开始处添加文本(非空字符的行首)\n* O 在当前行的上面新建一行 OR shift + o\n* o 在当前行的下面新建一行\n* R 替换(覆盖)当前光标位置及后面的若干文本\n* J 合并光标所在行及下一行为一行(依然在命令模式)\n\n## 七、删除、恢复\n\n* x 删除当前字符\n* nx 删除从光标开始的n个字符\n* dd 删除当行\n* ndd 向下删除当前行在内的n行\n* dw 从光标当前的位置开始删除，直到删到单词最后\n* daw deletea a word 删除一整个单词\n* u 撤销上一步操作\n* ctrl + r 恢复上一步被撤销的操作\n* U 撤销对当前行的所有操作\n* df + 单个字符 可以快速删除当前光标到字符之间所有字符\n\n### 7.1、跨行多字符删除\n\n* v (visual)模式，jkhl 跨行选中字符\n* shift + 4/6 光标到行尾/首 \n* d 删除\n\n## 八、查找\n\n* 光标停留在单词字母上，输入 shift + * 可快速选中该单词，通过n或者N进行上一个或下一个的匹配\n* shift+4/6 行首/尾\n* shift+{/} 代码块首/尾\n\n## 九、复制/粘贴\n\n### 9.1、基本复制\n\n* yy 将当前行复制到缓冲区，也可以用 'ayy' 复制，a 为缓冲区，a 也可以替换为a到z的任意字母，可以完成多个复制任务\n* nyy 将当前行向下n行复制到缓冲区，也可以用 \"anyy 复制，\"a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务\n* yw 复制从光标开始到词尾的字符\n* nyw 复制从光标开始的 n 个单词\n* y^ 复制从光标到行首的内容\n* y$ 复制从光标到行尾的内容\n* p 粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用\"ap 进行粘贴\n* P 粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用\"aP 进行粘贴\n* v 进入待处理，yy 复制，p 粘贴\n* v 进入待处理，shift + 4 行尾 选中行内容进行复制；shift + 6 行首 选中行内容进行复制\n\n### 9.2、复制列\n\n1. ctrl+ v 按列选\n2. jk 选中多列\n3. 大A(shift+a)向后修改；shift+i（或者大写I）向前修改；d 删除列\n4. esc 退出\n\n### 9.3、全选\n\n1. ggvG 全选\n2. shift + v 或者 V 可以快速选中一行\n3. gv 回到之前选中的文本块\n\n### 9.4、选择一个单词\n\n快速选中一个单词，按 v 按 e 即可\n\n## 十、替换\n\n表达式`:[range]s/from/to/[flags]`\n\n* :s/old/new    用 new 替换行中首次出现的 old\n* :s/old/new/g  用 new 替换行中所有的 old\n* :n,m s/old/new/g   用 new 替换从 n 到 m 行里所有的 old\n* :%s/old/new/g  用 new 替换当前文件里所有的 old\n\n### 10.1、替换例子\n\n1. :1,10s/from/to/ 表示在第 1 到第 10 行（包含第1，第10行）之间搜索替换；\n2. :10s/from/to/ 表示只在第 10 行搜索替换；\n3. :%s/from/to/ 表示在所有行中搜索替换；\n4. 1,$s/from/to/ 同上\n\n## 十一、搜索\n\n* /vpser     //向光标下搜索 vpser 字符串，vpser 可以是正则表达式\n* ?vpser     //向光标上搜索 vpser 字符串\n* n         //向下搜索前一个搜素动作\n* N         //向上搜索前一个搜索动作\n* *(#)      //当光标停留在某个单词上时, 输入这条命令表示查找与该单词匹配的下(上)一个单词. 同样, 再输入 n 查找下一个匹配处, 输入 N 反方向查找.\n* g*(g#)        //此命令与上条命令相似, 只不过它不完全匹配光标所在处的单词, 而是匹配包含该单词的所有字符串.\n* ^search     要查找仅出现在行首的 search\n* search$    要查找仅出现在行尾的 search\n\n其中：在搜索单词后面紧跟 `\\c` 可以忽略大小写搜索。\n\n或者` :set ignorecase smartcase` 设置即可。\n\n## 十二、编辑其他文件\n\n* :e otherfilename   编辑文件名为 otherfilename 的文件\n\n## 十三、修改文件格式\n\n* :set fileformat=unix  将文件修改为 unix 格式，如 win 下面的文本文件在linux下会出现^M\n\n## 十四、查找帮助\n\n当你不知道怎么处理时，直接输入 help 可以看到帮助文档的起点，ZZ 是退出或者：q，不建议使用\n查找关于某个字母的命令 ：help x   查找关于 x 的命令。\n\n## 参考\n\n* [编辑器之神-VIM](https://segmentfault.com/a/1190000005011766)\n\n","source":"_posts/Vim-常用命令.md","raw":"---\ntitle: Vim 常用命令\ndate: 2019-10-07 10:22:07\ntags: Vim\ncategories: Vim\n---\n\n本文介绍 Vim 常用操作命令及快捷键，算是入门级使用。\n\n<!-- more -->\n\n## 一、打开、保存、关闭文件\n\n* :w    保存文件\n* :w    vpser.net 保存至 vpser.net 文件\n* :q    退出编辑器，如果文件已修改请使用下面的命令\n* :q!   退出编辑器，且不保存\n* :wq   退出编辑器，且保存文件\n\n:w 要保存文件路径 可以保存文件到指定路径下\n\n## 二、移动\n\n### 2.1、字符间跳转 \n\n* j 下移一行\n* k 上移一行\n* h 左移一个字符\n* l 右移一个字符\n* 空格键 向右\n* Backspace 向左\n* Enter 移动到下一行首\n* `-` 移动到上一行首\n* shift + 6 跳转到行首\n* shift + 4 跳转到行尾\n\n### 2.2、单词间跳转\n\n* w：跳转至下一个单词或后一个单词的词首\n* e：跳转至当前或下一个单词的词尾\n* b：跳转至当前或上一个单词的词首\n* `#COMMAND` 由#指定一次跳转的单词数\n\n## 三、跳转\n\n* n+ 向下跳n行\n* n- 向上跳n行\n* nG 跳到行号为n的行\n* gg 跳转到文件头\n* shift + g 跳转到文件末尾\n* G 跳至文件的底部\n* :n 代表跳转到第n行，如:79 就跳转到第79行\n\n## 四、设置行号\n\n* :set nu 显示行号\n* :set nonu 取消显示行号\n\n## 五、翻屏\n\n* ctrl + f 下翻一屏\n* ctrl + b 上翻一屏\n* ctrl + d 下翻半屏\n* ctrl + u 上翻半屏\n* ctrl + e 向下滚动一行\n* ctrl + y 向上滚动一行\n\n## 六、插入\n\n* a 在当前光标位置的右边添加文本\n* i 在当前光标位置的左边添加文本\n* A 在当前行的末尾位置添加文本\n* I 在当前行的开始处添加文本(非空字符的行首)\n* O 在当前行的上面新建一行 OR shift + o\n* o 在当前行的下面新建一行\n* R 替换(覆盖)当前光标位置及后面的若干文本\n* J 合并光标所在行及下一行为一行(依然在命令模式)\n\n## 七、删除、恢复\n\n* x 删除当前字符\n* nx 删除从光标开始的n个字符\n* dd 删除当行\n* ndd 向下删除当前行在内的n行\n* dw 从光标当前的位置开始删除，直到删到单词最后\n* daw deletea a word 删除一整个单词\n* u 撤销上一步操作\n* ctrl + r 恢复上一步被撤销的操作\n* U 撤销对当前行的所有操作\n* df + 单个字符 可以快速删除当前光标到字符之间所有字符\n\n### 7.1、跨行多字符删除\n\n* v (visual)模式，jkhl 跨行选中字符\n* shift + 4/6 光标到行尾/首 \n* d 删除\n\n## 八、查找\n\n* 光标停留在单词字母上，输入 shift + * 可快速选中该单词，通过n或者N进行上一个或下一个的匹配\n* shift+4/6 行首/尾\n* shift+{/} 代码块首/尾\n\n## 九、复制/粘贴\n\n### 9.1、基本复制\n\n* yy 将当前行复制到缓冲区，也可以用 'ayy' 复制，a 为缓冲区，a 也可以替换为a到z的任意字母，可以完成多个复制任务\n* nyy 将当前行向下n行复制到缓冲区，也可以用 \"anyy 复制，\"a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务\n* yw 复制从光标开始到词尾的字符\n* nyw 复制从光标开始的 n 个单词\n* y^ 复制从光标到行首的内容\n* y$ 复制从光标到行尾的内容\n* p 粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用\"ap 进行粘贴\n* P 粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用\"aP 进行粘贴\n* v 进入待处理，yy 复制，p 粘贴\n* v 进入待处理，shift + 4 行尾 选中行内容进行复制；shift + 6 行首 选中行内容进行复制\n\n### 9.2、复制列\n\n1. ctrl+ v 按列选\n2. jk 选中多列\n3. 大A(shift+a)向后修改；shift+i（或者大写I）向前修改；d 删除列\n4. esc 退出\n\n### 9.3、全选\n\n1. ggvG 全选\n2. shift + v 或者 V 可以快速选中一行\n3. gv 回到之前选中的文本块\n\n### 9.4、选择一个单词\n\n快速选中一个单词，按 v 按 e 即可\n\n## 十、替换\n\n表达式`:[range]s/from/to/[flags]`\n\n* :s/old/new    用 new 替换行中首次出现的 old\n* :s/old/new/g  用 new 替换行中所有的 old\n* :n,m s/old/new/g   用 new 替换从 n 到 m 行里所有的 old\n* :%s/old/new/g  用 new 替换当前文件里所有的 old\n\n### 10.1、替换例子\n\n1. :1,10s/from/to/ 表示在第 1 到第 10 行（包含第1，第10行）之间搜索替换；\n2. :10s/from/to/ 表示只在第 10 行搜索替换；\n3. :%s/from/to/ 表示在所有行中搜索替换；\n4. 1,$s/from/to/ 同上\n\n## 十一、搜索\n\n* /vpser     //向光标下搜索 vpser 字符串，vpser 可以是正则表达式\n* ?vpser     //向光标上搜索 vpser 字符串\n* n         //向下搜索前一个搜素动作\n* N         //向上搜索前一个搜索动作\n* *(#)      //当光标停留在某个单词上时, 输入这条命令表示查找与该单词匹配的下(上)一个单词. 同样, 再输入 n 查找下一个匹配处, 输入 N 反方向查找.\n* g*(g#)        //此命令与上条命令相似, 只不过它不完全匹配光标所在处的单词, 而是匹配包含该单词的所有字符串.\n* ^search     要查找仅出现在行首的 search\n* search$    要查找仅出现在行尾的 search\n\n其中：在搜索单词后面紧跟 `\\c` 可以忽略大小写搜索。\n\n或者` :set ignorecase smartcase` 设置即可。\n\n## 十二、编辑其他文件\n\n* :e otherfilename   编辑文件名为 otherfilename 的文件\n\n## 十三、修改文件格式\n\n* :set fileformat=unix  将文件修改为 unix 格式，如 win 下面的文本文件在linux下会出现^M\n\n## 十四、查找帮助\n\n当你不知道怎么处理时，直接输入 help 可以看到帮助文档的起点，ZZ 是退出或者：q，不建议使用\n查找关于某个字母的命令 ：help x   查找关于 x 的命令。\n\n## 参考\n\n* [编辑器之神-VIM](https://segmentfault.com/a/1190000005011766)\n\n","slug":"Vim-常用命令","published":1,"updated":"2020-01-14T03:35:49.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vfa001fn2cbeaegarbk","content":"<p>本文介绍 Vim 常用操作命令及快捷键，算是入门级使用。</p>\n<a id=\"more\"></a>\n<h2 id=\"一、打开、保存、关闭文件\"><a href=\"#一、打开、保存、关闭文件\" class=\"headerlink\" title=\"一、打开、保存、关闭文件\"></a>一、打开、保存、关闭文件</h2><ul>\n<li>:w    保存文件</li>\n<li>:w    vpser.net 保存至 vpser.net 文件</li>\n<li>:q    退出编辑器，如果文件已修改请使用下面的命令</li>\n<li>:q!   退出编辑器，且不保存</li>\n<li>:wq   退出编辑器，且保存文件</li>\n</ul>\n<p>:w 要保存文件路径 可以保存文件到指定路径下</p>\n<h2 id=\"二、移动\"><a href=\"#二、移动\" class=\"headerlink\" title=\"二、移动\"></a>二、移动</h2><h3 id=\"2-1、字符间跳转\"><a href=\"#2-1、字符间跳转\" class=\"headerlink\" title=\"2.1、字符间跳转\"></a>2.1、字符间跳转</h3><ul>\n<li>j 下移一行</li>\n<li>k 上移一行</li>\n<li>h 左移一个字符</li>\n<li>l 右移一个字符</li>\n<li>空格键 向右</li>\n<li>Backspace 向左</li>\n<li>Enter 移动到下一行首</li>\n<li><code>-</code> 移动到上一行首</li>\n<li>shift + 6 跳转到行首</li>\n<li>shift + 4 跳转到行尾</li>\n</ul>\n<h3 id=\"2-2、单词间跳转\"><a href=\"#2-2、单词间跳转\" class=\"headerlink\" title=\"2.2、单词间跳转\"></a>2.2、单词间跳转</h3><ul>\n<li>w：跳转至下一个单词或后一个单词的词首</li>\n<li>e：跳转至当前或下一个单词的词尾</li>\n<li>b：跳转至当前或上一个单词的词首</li>\n<li><code>#COMMAND</code> 由#指定一次跳转的单词数</li>\n</ul>\n<h2 id=\"三、跳转\"><a href=\"#三、跳转\" class=\"headerlink\" title=\"三、跳转\"></a>三、跳转</h2><ul>\n<li>n+ 向下跳n行</li>\n<li>n- 向上跳n行</li>\n<li>nG 跳到行号为n的行</li>\n<li>gg 跳转到文件头</li>\n<li>shift + g 跳转到文件末尾</li>\n<li>G 跳至文件的底部</li>\n<li>:n 代表跳转到第n行，如:79 就跳转到第79行</li>\n</ul>\n<h2 id=\"四、设置行号\"><a href=\"#四、设置行号\" class=\"headerlink\" title=\"四、设置行号\"></a>四、设置行号</h2><ul>\n<li>:set nu 显示行号</li>\n<li>:set nonu 取消显示行号</li>\n</ul>\n<h2 id=\"五、翻屏\"><a href=\"#五、翻屏\" class=\"headerlink\" title=\"五、翻屏\"></a>五、翻屏</h2><ul>\n<li>ctrl + f 下翻一屏</li>\n<li>ctrl + b 上翻一屏</li>\n<li>ctrl + d 下翻半屏</li>\n<li>ctrl + u 上翻半屏</li>\n<li>ctrl + e 向下滚动一行</li>\n<li>ctrl + y 向上滚动一行</li>\n</ul>\n<h2 id=\"六、插入\"><a href=\"#六、插入\" class=\"headerlink\" title=\"六、插入\"></a>六、插入</h2><ul>\n<li>a 在当前光标位置的右边添加文本</li>\n<li>i 在当前光标位置的左边添加文本</li>\n<li>A 在当前行的末尾位置添加文本</li>\n<li>I 在当前行的开始处添加文本(非空字符的行首)</li>\n<li>O 在当前行的上面新建一行 OR shift + o</li>\n<li>o 在当前行的下面新建一行</li>\n<li>R 替换(覆盖)当前光标位置及后面的若干文本</li>\n<li>J 合并光标所在行及下一行为一行(依然在命令模式)</li>\n</ul>\n<h2 id=\"七、删除、恢复\"><a href=\"#七、删除、恢复\" class=\"headerlink\" title=\"七、删除、恢复\"></a>七、删除、恢复</h2><ul>\n<li>x 删除当前字符</li>\n<li>nx 删除从光标开始的n个字符</li>\n<li>dd 删除当行</li>\n<li>ndd 向下删除当前行在内的n行</li>\n<li>dw 从光标当前的位置开始删除，直到删到单词最后</li>\n<li>daw deletea a word 删除一整个单词</li>\n<li>u 撤销上一步操作</li>\n<li>ctrl + r 恢复上一步被撤销的操作</li>\n<li>U 撤销对当前行的所有操作</li>\n<li>df + 单个字符 可以快速删除当前光标到字符之间所有字符</li>\n</ul>\n<h3 id=\"7-1、跨行多字符删除\"><a href=\"#7-1、跨行多字符删除\" class=\"headerlink\" title=\"7.1、跨行多字符删除\"></a>7.1、跨行多字符删除</h3><ul>\n<li>v (visual)模式，jkhl 跨行选中字符</li>\n<li>shift + 4/6 光标到行尾/首 </li>\n<li>d 删除</li>\n</ul>\n<h2 id=\"八、查找\"><a href=\"#八、查找\" class=\"headerlink\" title=\"八、查找\"></a>八、查找</h2><ul>\n<li>光标停留在单词字母上，输入 shift + * 可快速选中该单词，通过n或者N进行上一个或下一个的匹配</li>\n<li>shift+4/6 行首/尾</li>\n<li>shift+{/} 代码块首/尾</li>\n</ul>\n<h2 id=\"九、复制-粘贴\"><a href=\"#九、复制-粘贴\" class=\"headerlink\" title=\"九、复制/粘贴\"></a>九、复制/粘贴</h2><h3 id=\"9-1、基本复制\"><a href=\"#9-1、基本复制\" class=\"headerlink\" title=\"9.1、基本复制\"></a>9.1、基本复制</h3><ul>\n<li>yy 将当前行复制到缓冲区，也可以用 ‘ayy’ 复制，a 为缓冲区，a 也可以替换为a到z的任意字母，可以完成多个复制任务</li>\n<li>nyy 将当前行向下n行复制到缓冲区，也可以用 “anyy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务</li>\n<li>yw 复制从光标开始到词尾的字符</li>\n<li>nyw 复制从光标开始的 n 个单词</li>\n<li>y^ 复制从光标到行首的内容</li>\n<li>y$ 复制从光标到行尾的内容</li>\n<li>p 粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用”ap 进行粘贴</li>\n<li>P 粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用”aP 进行粘贴</li>\n<li>v 进入待处理，yy 复制，p 粘贴</li>\n<li>v 进入待处理，shift + 4 行尾 选中行内容进行复制；shift + 6 行首 选中行内容进行复制</li>\n</ul>\n<h3 id=\"9-2、复制列\"><a href=\"#9-2、复制列\" class=\"headerlink\" title=\"9.2、复制列\"></a>9.2、复制列</h3><ol>\n<li>ctrl+ v 按列选</li>\n<li>jk 选中多列</li>\n<li>大A(shift+a)向后修改；shift+i（或者大写I）向前修改；d 删除列</li>\n<li>esc 退出</li>\n</ol>\n<h3 id=\"9-3、全选\"><a href=\"#9-3、全选\" class=\"headerlink\" title=\"9.3、全选\"></a>9.3、全选</h3><ol>\n<li>ggvG 全选</li>\n<li>shift + v 或者 V 可以快速选中一行</li>\n<li>gv 回到之前选中的文本块</li>\n</ol>\n<h3 id=\"9-4、选择一个单词\"><a href=\"#9-4、选择一个单词\" class=\"headerlink\" title=\"9.4、选择一个单词\"></a>9.4、选择一个单词</h3><p>快速选中一个单词，按 v 按 e 即可</p>\n<h2 id=\"十、替换\"><a href=\"#十、替换\" class=\"headerlink\" title=\"十、替换\"></a>十、替换</h2><p>表达式<code>:[range]s/from/to/[flags]</code></p>\n<ul>\n<li>:s/old/new    用 new 替换行中首次出现的 old</li>\n<li>:s/old/new/g  用 new 替换行中所有的 old</li>\n<li>:n,m s/old/new/g   用 new 替换从 n 到 m 行里所有的 old</li>\n<li>:%s/old/new/g  用 new 替换当前文件里所有的 old</li>\n</ul>\n<h3 id=\"10-1、替换例子\"><a href=\"#10-1、替换例子\" class=\"headerlink\" title=\"10.1、替换例子\"></a>10.1、替换例子</h3><ol>\n<li>:1,10s/from/to/ 表示在第 1 到第 10 行（包含第1，第10行）之间搜索替换；</li>\n<li>:10s/from/to/ 表示只在第 10 行搜索替换；</li>\n<li>:%s/from/to/ 表示在所有行中搜索替换；</li>\n<li>1,$s/from/to/ 同上</li>\n</ol>\n<h2 id=\"十一、搜索\"><a href=\"#十一、搜索\" class=\"headerlink\" title=\"十一、搜索\"></a>十一、搜索</h2><ul>\n<li>/vpser     //向光标下搜索 vpser 字符串，vpser 可以是正则表达式</li>\n<li>?vpser     //向光标上搜索 vpser 字符串</li>\n<li>n         //向下搜索前一个搜素动作</li>\n<li>N         //向上搜索前一个搜索动作</li>\n<li>*(#)      //当光标停留在某个单词上时, 输入这条命令表示查找与该单词匹配的下(上)一个单词. 同样, 再输入 n 查找下一个匹配处, 输入 N 反方向查找.</li>\n<li>g*(g#)        //此命令与上条命令相似, 只不过它不完全匹配光标所在处的单词, 而是匹配包含该单词的所有字符串.</li>\n<li>^search     要查找仅出现在行首的 search</li>\n<li>search$    要查找仅出现在行尾的 search</li>\n</ul>\n<p>其中：在搜索单词后面紧跟 <code>\\c</code> 可以忽略大小写搜索。</p>\n<p>或者<code>:set ignorecase smartcase</code> 设置即可。</p>\n<h2 id=\"十二、编辑其他文件\"><a href=\"#十二、编辑其他文件\" class=\"headerlink\" title=\"十二、编辑其他文件\"></a>十二、编辑其他文件</h2><ul>\n<li>:e otherfilename   编辑文件名为 otherfilename 的文件</li>\n</ul>\n<h2 id=\"十三、修改文件格式\"><a href=\"#十三、修改文件格式\" class=\"headerlink\" title=\"十三、修改文件格式\"></a>十三、修改文件格式</h2><ul>\n<li>:set fileformat=unix  将文件修改为 unix 格式，如 win 下面的文本文件在linux下会出现^M</li>\n</ul>\n<h2 id=\"十四、查找帮助\"><a href=\"#十四、查找帮助\" class=\"headerlink\" title=\"十四、查找帮助\"></a>十四、查找帮助</h2><p>当你不知道怎么处理时，直接输入 help 可以看到帮助文档的起点，ZZ 是退出或者：q，不建议使用<br>查找关于某个字母的命令 ：help x   查找关于 x 的命令。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000005011766\" target=\"_blank\" rel=\"noopener\">编辑器之神-VIM</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文介绍 Vim 常用操作命令及快捷键，算是入门级使用。</p>","more":"<h2 id=\"一、打开、保存、关闭文件\"><a href=\"#一、打开、保存、关闭文件\" class=\"headerlink\" title=\"一、打开、保存、关闭文件\"></a>一、打开、保存、关闭文件</h2><ul>\n<li>:w    保存文件</li>\n<li>:w    vpser.net 保存至 vpser.net 文件</li>\n<li>:q    退出编辑器，如果文件已修改请使用下面的命令</li>\n<li>:q!   退出编辑器，且不保存</li>\n<li>:wq   退出编辑器，且保存文件</li>\n</ul>\n<p>:w 要保存文件路径 可以保存文件到指定路径下</p>\n<h2 id=\"二、移动\"><a href=\"#二、移动\" class=\"headerlink\" title=\"二、移动\"></a>二、移动</h2><h3 id=\"2-1、字符间跳转\"><a href=\"#2-1、字符间跳转\" class=\"headerlink\" title=\"2.1、字符间跳转\"></a>2.1、字符间跳转</h3><ul>\n<li>j 下移一行</li>\n<li>k 上移一行</li>\n<li>h 左移一个字符</li>\n<li>l 右移一个字符</li>\n<li>空格键 向右</li>\n<li>Backspace 向左</li>\n<li>Enter 移动到下一行首</li>\n<li><code>-</code> 移动到上一行首</li>\n<li>shift + 6 跳转到行首</li>\n<li>shift + 4 跳转到行尾</li>\n</ul>\n<h3 id=\"2-2、单词间跳转\"><a href=\"#2-2、单词间跳转\" class=\"headerlink\" title=\"2.2、单词间跳转\"></a>2.2、单词间跳转</h3><ul>\n<li>w：跳转至下一个单词或后一个单词的词首</li>\n<li>e：跳转至当前或下一个单词的词尾</li>\n<li>b：跳转至当前或上一个单词的词首</li>\n<li><code>#COMMAND</code> 由#指定一次跳转的单词数</li>\n</ul>\n<h2 id=\"三、跳转\"><a href=\"#三、跳转\" class=\"headerlink\" title=\"三、跳转\"></a>三、跳转</h2><ul>\n<li>n+ 向下跳n行</li>\n<li>n- 向上跳n行</li>\n<li>nG 跳到行号为n的行</li>\n<li>gg 跳转到文件头</li>\n<li>shift + g 跳转到文件末尾</li>\n<li>G 跳至文件的底部</li>\n<li>:n 代表跳转到第n行，如:79 就跳转到第79行</li>\n</ul>\n<h2 id=\"四、设置行号\"><a href=\"#四、设置行号\" class=\"headerlink\" title=\"四、设置行号\"></a>四、设置行号</h2><ul>\n<li>:set nu 显示行号</li>\n<li>:set nonu 取消显示行号</li>\n</ul>\n<h2 id=\"五、翻屏\"><a href=\"#五、翻屏\" class=\"headerlink\" title=\"五、翻屏\"></a>五、翻屏</h2><ul>\n<li>ctrl + f 下翻一屏</li>\n<li>ctrl + b 上翻一屏</li>\n<li>ctrl + d 下翻半屏</li>\n<li>ctrl + u 上翻半屏</li>\n<li>ctrl + e 向下滚动一行</li>\n<li>ctrl + y 向上滚动一行</li>\n</ul>\n<h2 id=\"六、插入\"><a href=\"#六、插入\" class=\"headerlink\" title=\"六、插入\"></a>六、插入</h2><ul>\n<li>a 在当前光标位置的右边添加文本</li>\n<li>i 在当前光标位置的左边添加文本</li>\n<li>A 在当前行的末尾位置添加文本</li>\n<li>I 在当前行的开始处添加文本(非空字符的行首)</li>\n<li>O 在当前行的上面新建一行 OR shift + o</li>\n<li>o 在当前行的下面新建一行</li>\n<li>R 替换(覆盖)当前光标位置及后面的若干文本</li>\n<li>J 合并光标所在行及下一行为一行(依然在命令模式)</li>\n</ul>\n<h2 id=\"七、删除、恢复\"><a href=\"#七、删除、恢复\" class=\"headerlink\" title=\"七、删除、恢复\"></a>七、删除、恢复</h2><ul>\n<li>x 删除当前字符</li>\n<li>nx 删除从光标开始的n个字符</li>\n<li>dd 删除当行</li>\n<li>ndd 向下删除当前行在内的n行</li>\n<li>dw 从光标当前的位置开始删除，直到删到单词最后</li>\n<li>daw deletea a word 删除一整个单词</li>\n<li>u 撤销上一步操作</li>\n<li>ctrl + r 恢复上一步被撤销的操作</li>\n<li>U 撤销对当前行的所有操作</li>\n<li>df + 单个字符 可以快速删除当前光标到字符之间所有字符</li>\n</ul>\n<h3 id=\"7-1、跨行多字符删除\"><a href=\"#7-1、跨行多字符删除\" class=\"headerlink\" title=\"7.1、跨行多字符删除\"></a>7.1、跨行多字符删除</h3><ul>\n<li>v (visual)模式，jkhl 跨行选中字符</li>\n<li>shift + 4/6 光标到行尾/首 </li>\n<li>d 删除</li>\n</ul>\n<h2 id=\"八、查找\"><a href=\"#八、查找\" class=\"headerlink\" title=\"八、查找\"></a>八、查找</h2><ul>\n<li>光标停留在单词字母上，输入 shift + * 可快速选中该单词，通过n或者N进行上一个或下一个的匹配</li>\n<li>shift+4/6 行首/尾</li>\n<li>shift+{/} 代码块首/尾</li>\n</ul>\n<h2 id=\"九、复制-粘贴\"><a href=\"#九、复制-粘贴\" class=\"headerlink\" title=\"九、复制/粘贴\"></a>九、复制/粘贴</h2><h3 id=\"9-1、基本复制\"><a href=\"#9-1、基本复制\" class=\"headerlink\" title=\"9.1、基本复制\"></a>9.1、基本复制</h3><ul>\n<li>yy 将当前行复制到缓冲区，也可以用 ‘ayy’ 复制，a 为缓冲区，a 也可以替换为a到z的任意字母，可以完成多个复制任务</li>\n<li>nyy 将当前行向下n行复制到缓冲区，也可以用 “anyy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务</li>\n<li>yw 复制从光标开始到词尾的字符</li>\n<li>nyw 复制从光标开始的 n 个单词</li>\n<li>y^ 复制从光标到行首的内容</li>\n<li>y$ 复制从光标到行尾的内容</li>\n<li>p 粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用”ap 进行粘贴</li>\n<li>P 粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用”aP 进行粘贴</li>\n<li>v 进入待处理，yy 复制，p 粘贴</li>\n<li>v 进入待处理，shift + 4 行尾 选中行内容进行复制；shift + 6 行首 选中行内容进行复制</li>\n</ul>\n<h3 id=\"9-2、复制列\"><a href=\"#9-2、复制列\" class=\"headerlink\" title=\"9.2、复制列\"></a>9.2、复制列</h3><ol>\n<li>ctrl+ v 按列选</li>\n<li>jk 选中多列</li>\n<li>大A(shift+a)向后修改；shift+i（或者大写I）向前修改；d 删除列</li>\n<li>esc 退出</li>\n</ol>\n<h3 id=\"9-3、全选\"><a href=\"#9-3、全选\" class=\"headerlink\" title=\"9.3、全选\"></a>9.3、全选</h3><ol>\n<li>ggvG 全选</li>\n<li>shift + v 或者 V 可以快速选中一行</li>\n<li>gv 回到之前选中的文本块</li>\n</ol>\n<h3 id=\"9-4、选择一个单词\"><a href=\"#9-4、选择一个单词\" class=\"headerlink\" title=\"9.4、选择一个单词\"></a>9.4、选择一个单词</h3><p>快速选中一个单词，按 v 按 e 即可</p>\n<h2 id=\"十、替换\"><a href=\"#十、替换\" class=\"headerlink\" title=\"十、替换\"></a>十、替换</h2><p>表达式<code>:[range]s/from/to/[flags]</code></p>\n<ul>\n<li>:s/old/new    用 new 替换行中首次出现的 old</li>\n<li>:s/old/new/g  用 new 替换行中所有的 old</li>\n<li>:n,m s/old/new/g   用 new 替换从 n 到 m 行里所有的 old</li>\n<li>:%s/old/new/g  用 new 替换当前文件里所有的 old</li>\n</ul>\n<h3 id=\"10-1、替换例子\"><a href=\"#10-1、替换例子\" class=\"headerlink\" title=\"10.1、替换例子\"></a>10.1、替换例子</h3><ol>\n<li>:1,10s/from/to/ 表示在第 1 到第 10 行（包含第1，第10行）之间搜索替换；</li>\n<li>:10s/from/to/ 表示只在第 10 行搜索替换；</li>\n<li>:%s/from/to/ 表示在所有行中搜索替换；</li>\n<li>1,$s/from/to/ 同上</li>\n</ol>\n<h2 id=\"十一、搜索\"><a href=\"#十一、搜索\" class=\"headerlink\" title=\"十一、搜索\"></a>十一、搜索</h2><ul>\n<li>/vpser     //向光标下搜索 vpser 字符串，vpser 可以是正则表达式</li>\n<li>?vpser     //向光标上搜索 vpser 字符串</li>\n<li>n         //向下搜索前一个搜素动作</li>\n<li>N         //向上搜索前一个搜索动作</li>\n<li>*(#)      //当光标停留在某个单词上时, 输入这条命令表示查找与该单词匹配的下(上)一个单词. 同样, 再输入 n 查找下一个匹配处, 输入 N 反方向查找.</li>\n<li>g*(g#)        //此命令与上条命令相似, 只不过它不完全匹配光标所在处的单词, 而是匹配包含该单词的所有字符串.</li>\n<li>^search     要查找仅出现在行首的 search</li>\n<li>search$    要查找仅出现在行尾的 search</li>\n</ul>\n<p>其中：在搜索单词后面紧跟 <code>\\c</code> 可以忽略大小写搜索。</p>\n<p>或者<code>:set ignorecase smartcase</code> 设置即可。</p>\n<h2 id=\"十二、编辑其他文件\"><a href=\"#十二、编辑其他文件\" class=\"headerlink\" title=\"十二、编辑其他文件\"></a>十二、编辑其他文件</h2><ul>\n<li>:e otherfilename   编辑文件名为 otherfilename 的文件</li>\n</ul>\n<h2 id=\"十三、修改文件格式\"><a href=\"#十三、修改文件格式\" class=\"headerlink\" title=\"十三、修改文件格式\"></a>十三、修改文件格式</h2><ul>\n<li>:set fileformat=unix  将文件修改为 unix 格式，如 win 下面的文本文件在linux下会出现^M</li>\n</ul>\n<h2 id=\"十四、查找帮助\"><a href=\"#十四、查找帮助\" class=\"headerlink\" title=\"十四、查找帮助\"></a>十四、查找帮助</h2><p>当你不知道怎么处理时，直接输入 help 可以看到帮助文档的起点，ZZ 是退出或者：q，不建议使用<br>查找关于某个字母的命令 ：help x   查找关于 x 的命令。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000005011766\" target=\"_blank\" rel=\"noopener\">编辑器之神-VIM</a></li>\n</ul>"},{"title":"一些常见专业词汇的正确写法","date":"2018-12-08T13:45:13.000Z","_content":"\n在日常简历和技术文档中，时常能看到一些同学把专业术语写错。这些小细节外行人可能不会注意，但是身为开发人员需要留心下，不然有可能闹笑话。程序员常用词汇正确写法，请 GET 以下！：）\n\n<!-- more -->\n\n* Java（错误：JAVA、java）\n* Objective-C（错误：OC、oc、objective-c）\n* Xcode（错误：xcode、XCODE、XCode）\n* Linux（错误：linux、LINUX）\n* App/应用（错误：APP、软件、程序）\n* Android（错误：android、安卓）\n* iOS（错误：ios、IOS）\n* iPhone（错误：IPHONE、iphone）\n* App Store（中间有空格，错误：AppStore、appstore）\n* Runtime（错误：runtime）\n* HTML（错误：Html、html）\n* CSS（错误：Css、css）\n* JavaScript（错误：javascript、Javascript、js、JS）\n* Git（错误：git、GIT）\n* Eclipse（错误：eclipse）\n* Android Studio（错误：android studio）\n* MySQL（错误：mysql）\n* Node.js（错误：node、Node、NodeJS、nodejs）\n* SQLite（错误：sqlite）\n\n\n","source":"_posts/一些常见专业词汇的正确写法.md","raw":"---\ntitle: 一些常见专业词汇的正确写法\ndate: 2018-12-08 21:45:13\ntags: 技术规范\ncategories: 技术规范\n---\n\n在日常简历和技术文档中，时常能看到一些同学把专业术语写错。这些小细节外行人可能不会注意，但是身为开发人员需要留心下，不然有可能闹笑话。程序员常用词汇正确写法，请 GET 以下！：）\n\n<!-- more -->\n\n* Java（错误：JAVA、java）\n* Objective-C（错误：OC、oc、objective-c）\n* Xcode（错误：xcode、XCODE、XCode）\n* Linux（错误：linux、LINUX）\n* App/应用（错误：APP、软件、程序）\n* Android（错误：android、安卓）\n* iOS（错误：ios、IOS）\n* iPhone（错误：IPHONE、iphone）\n* App Store（中间有空格，错误：AppStore、appstore）\n* Runtime（错误：runtime）\n* HTML（错误：Html、html）\n* CSS（错误：Css、css）\n* JavaScript（错误：javascript、Javascript、js、JS）\n* Git（错误：git、GIT）\n* Eclipse（错误：eclipse）\n* Android Studio（错误：android studio）\n* MySQL（错误：mysql）\n* Node.js（错误：node、Node、NodeJS、nodejs）\n* SQLite（错误：sqlite）\n\n\n","slug":"一些常见专业词汇的正确写法","published":1,"updated":"2020-01-14T03:35:49.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vfb001in2cbrmoo0swu","content":"<p>在日常简历和技术文档中，时常能看到一些同学把专业术语写错。这些小细节外行人可能不会注意，但是身为开发人员需要留心下，不然有可能闹笑话。程序员常用词汇正确写法，请 GET 以下！：）</p>\n<a id=\"more\"></a>\n<ul>\n<li>Java（错误：JAVA、java）</li>\n<li>Objective-C（错误：OC、oc、objective-c）</li>\n<li>Xcode（错误：xcode、XCODE、XCode）</li>\n<li>Linux（错误：linux、LINUX）</li>\n<li>App/应用（错误：APP、软件、程序）</li>\n<li>Android（错误：android、安卓）</li>\n<li>iOS（错误：ios、IOS）</li>\n<li>iPhone（错误：IPHONE、iphone）</li>\n<li>App Store（中间有空格，错误：AppStore、appstore）</li>\n<li>Runtime（错误：runtime）</li>\n<li>HTML（错误：Html、html）</li>\n<li>CSS（错误：Css、css）</li>\n<li>JavaScript（错误：javascript、Javascript、js、JS）</li>\n<li>Git（错误：git、GIT）</li>\n<li>Eclipse（错误：eclipse）</li>\n<li>Android Studio（错误：android studio）</li>\n<li>MySQL（错误：mysql）</li>\n<li>Node.js（错误：node、Node、NodeJS、nodejs）</li>\n<li>SQLite（错误：sqlite）</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在日常简历和技术文档中，时常能看到一些同学把专业术语写错。这些小细节外行人可能不会注意，但是身为开发人员需要留心下，不然有可能闹笑话。程序员常用词汇正确写法，请 GET 以下！：）</p>","more":"<ul>\n<li>Java（错误：JAVA、java）</li>\n<li>Objective-C（错误：OC、oc、objective-c）</li>\n<li>Xcode（错误：xcode、XCODE、XCode）</li>\n<li>Linux（错误：linux、LINUX）</li>\n<li>App/应用（错误：APP、软件、程序）</li>\n<li>Android（错误：android、安卓）</li>\n<li>iOS（错误：ios、IOS）</li>\n<li>iPhone（错误：IPHONE、iphone）</li>\n<li>App Store（中间有空格，错误：AppStore、appstore）</li>\n<li>Runtime（错误：runtime）</li>\n<li>HTML（错误：Html、html）</li>\n<li>CSS（错误：Css、css）</li>\n<li>JavaScript（错误：javascript、Javascript、js、JS）</li>\n<li>Git（错误：git、GIT）</li>\n<li>Eclipse（错误：eclipse）</li>\n<li>Android Studio（错误：android studio）</li>\n<li>MySQL（错误：mysql）</li>\n<li>Node.js（错误：node、Node、NodeJS、nodejs）</li>\n<li>SQLite（错误：sqlite）</li>\n</ul>"},{"title":"关于自己博客的介绍","date":"2018-10-07T06:03:44.000Z","_content":"\n本文内容包含自己博客使用的 GitHub 仓库介绍及基于 Hexo 框架搭建的过程。博客地址：http://nelsonblog.me\n\n<!-- more -->\n\n本博客对应 GitHub 仓库地址：https://github.com/haoxunwang/haoxunwang.github.io\n\n<img src=\"http://wanghaoxun.com/img/Github-io-mine.jpg\"/>\n\n## 仓库说明：\n\n1. 博客仓库使用 hexo 分支来保存基于 hexo 框架的源文件；hexo 生成的静态博客 html 文件默认放在 master 分支上；\n2. 如果要更新博客主题，需要把主题拷贝至 theme 文件夹下；\n3. hexo 分支源文件没有保存 node_modules 文件夹，使用时需要执行 `npm install` 命令来拉取 hexo 框架依赖；\n\n具体可参考[这篇博客](https://www.jianshu.com/p/0b1fccce74e0)设置！\n\n## 目录结构\n\n* node_modules: hexo 需要的模块，需要 git 忽略，可以本地执行`npm install`获取\n* themes 主题文件夹，如果需要更新主题，可以拷贝主题到这里即可）\n* sources 博文 md 文件\n* public 框架生成的静态网页（git 忽略）\n* package.json 记录 hexo 需要的包信息\n* _config.yml 全局配置文件\n* .gitignore git 忽略配置\n\n## hexo 命令\n\n* hexo s --debug 可以在本地部署blog，localhost:4000即可，--debug是输出调试日志\n* hexo g 生成html文件等\n* hexo d 部署文章到 github.io，因为本地已经关联了github的账号，具体设置在 hexo 分支的 _config.yml 全局配置文件里\n* hexo new \"xx\" xx是文章title，具体的tag和category可以在MD文件中设置\n\n## 博客发布\n\n流程：\n\n1. 在仓库 hexo 分支上使用命令创建文章 `hexo new \"xx\"`\n2. hexo s --debug 本地预览调试\n3. hexo g 生成 html 静态网页\n4. hexo d 快捷部署到 github \n\n## 安装 Hexo \n\n* 安装 Node \n\nhexo 使用 Node.js 编写，需要先安装 node，具体可以参考 [使用 nvm 管理不同版本的 node 与 npm](http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/)。\n\n详细步骤：\n\n1. 终端执行 `curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash` 命令安装来 nvm，其中 v0.35.1 是版本号，最新版本命令去这里获取 [Github/nvm](https://github.com/nvm-sh/nvm#install-script)；\n2. 添加如下配置到 `~/.bash_profile`文件里，再执行 `source ~/.bash_profile` 命令 重新刷新下配置；\n    ```\n    export NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] && printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\"\n    [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm\n    ```\n3. 安装 Node\n\n    执行`nvm install 13.3.0`安装 Node，13.3.0 为版本号，最新版本号查看[这里](https://nodejs.org/en/)；\n\n* 安装 Hexo \n\n使用 node nmp 包管理器来安装依赖模块\n\n```\n// 安装 hexo \nnpm install hexo-cli -g\n\n// 在自己博客文件夹下执行\nhexo init \n\n// 安装依赖\nnpm install \n\n// 写博客/发布等等...\nhexo new \"xx\" 创建文章\nhexo generate 本地生成静态网页\nhexo server 本地发布\n```\n\n## 错误\n\n* npm install 报各种 permissions denied\n\nhexo 框架使用 Node.js 编写，本地环境需要安装 Node.js，具体安装请参考[官网](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally)，官方推荐用 nvm 管理器来安装，不推荐使用 `brew install node`，因为 node 的包管理器-npm 后面安装其他依赖时，会报各种 permissions 错误！ nvm 安装 node 可以参考 [使用 nvm 管理不同版本的 node 与 npm](http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/)。\n\n* npm install 报错\n\n使用 nvm 安装 node 之后，npm install 其他依赖时还会报权限错误，可以忽略，不影响使用！\n\n\n## 参考\n\nhexo \n\n* [Github-hexojs/hexo](https://github.com/hexojs/hexo)\n* [利用Hexo在多台电脑上提交和更新github pages博客](https://www.jianshu.com/p/0b1fccce74e0)\n* [Hexo+Github+Next+GoDaddy搭建博客](http://lzhblog.site/2019/07/13/Hexo-Github-Next-GoDaddy%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/)\n\n\nNode 安装\n\n* [使用 nvm 管理不同版本的 node 与 npm](http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/)\n* [mac上安装npm](https://www.jianshu.com/p/39b4339a9b60)\n\n错误\n\n* [npm 在安装的时候提示 没有权限操作的解决办法 Error: EACCES: permission denied](https://segmentfault.com/a/1190000018660227)\n* [hexo s 404 页面不存在](https://github.com/hexojs/hexo/issues/1384)\n\n\n\n\n","source":"_posts/关于自己博客仓库的介绍.md","raw":"---\ntitle: 关于自己博客的介绍\ndate: 2018-10-07 14:03:44\ntags: Hexo\ncategories: Hexo\n---\n\n本文内容包含自己博客使用的 GitHub 仓库介绍及基于 Hexo 框架搭建的过程。博客地址：http://nelsonblog.me\n\n<!-- more -->\n\n本博客对应 GitHub 仓库地址：https://github.com/haoxunwang/haoxunwang.github.io\n\n<img src=\"http://wanghaoxun.com/img/Github-io-mine.jpg\"/>\n\n## 仓库说明：\n\n1. 博客仓库使用 hexo 分支来保存基于 hexo 框架的源文件；hexo 生成的静态博客 html 文件默认放在 master 分支上；\n2. 如果要更新博客主题，需要把主题拷贝至 theme 文件夹下；\n3. hexo 分支源文件没有保存 node_modules 文件夹，使用时需要执行 `npm install` 命令来拉取 hexo 框架依赖；\n\n具体可参考[这篇博客](https://www.jianshu.com/p/0b1fccce74e0)设置！\n\n## 目录结构\n\n* node_modules: hexo 需要的模块，需要 git 忽略，可以本地执行`npm install`获取\n* themes 主题文件夹，如果需要更新主题，可以拷贝主题到这里即可）\n* sources 博文 md 文件\n* public 框架生成的静态网页（git 忽略）\n* package.json 记录 hexo 需要的包信息\n* _config.yml 全局配置文件\n* .gitignore git 忽略配置\n\n## hexo 命令\n\n* hexo s --debug 可以在本地部署blog，localhost:4000即可，--debug是输出调试日志\n* hexo g 生成html文件等\n* hexo d 部署文章到 github.io，因为本地已经关联了github的账号，具体设置在 hexo 分支的 _config.yml 全局配置文件里\n* hexo new \"xx\" xx是文章title，具体的tag和category可以在MD文件中设置\n\n## 博客发布\n\n流程：\n\n1. 在仓库 hexo 分支上使用命令创建文章 `hexo new \"xx\"`\n2. hexo s --debug 本地预览调试\n3. hexo g 生成 html 静态网页\n4. hexo d 快捷部署到 github \n\n## 安装 Hexo \n\n* 安装 Node \n\nhexo 使用 Node.js 编写，需要先安装 node，具体可以参考 [使用 nvm 管理不同版本的 node 与 npm](http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/)。\n\n详细步骤：\n\n1. 终端执行 `curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash` 命令安装来 nvm，其中 v0.35.1 是版本号，最新版本命令去这里获取 [Github/nvm](https://github.com/nvm-sh/nvm#install-script)；\n2. 添加如下配置到 `~/.bash_profile`文件里，再执行 `source ~/.bash_profile` 命令 重新刷新下配置；\n    ```\n    export NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] && printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\"\n    [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm\n    ```\n3. 安装 Node\n\n    执行`nvm install 13.3.0`安装 Node，13.3.0 为版本号，最新版本号查看[这里](https://nodejs.org/en/)；\n\n* 安装 Hexo \n\n使用 node nmp 包管理器来安装依赖模块\n\n```\n// 安装 hexo \nnpm install hexo-cli -g\n\n// 在自己博客文件夹下执行\nhexo init \n\n// 安装依赖\nnpm install \n\n// 写博客/发布等等...\nhexo new \"xx\" 创建文章\nhexo generate 本地生成静态网页\nhexo server 本地发布\n```\n\n## 错误\n\n* npm install 报各种 permissions denied\n\nhexo 框架使用 Node.js 编写，本地环境需要安装 Node.js，具体安装请参考[官网](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally)，官方推荐用 nvm 管理器来安装，不推荐使用 `brew install node`，因为 node 的包管理器-npm 后面安装其他依赖时，会报各种 permissions 错误！ nvm 安装 node 可以参考 [使用 nvm 管理不同版本的 node 与 npm](http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/)。\n\n* npm install 报错\n\n使用 nvm 安装 node 之后，npm install 其他依赖时还会报权限错误，可以忽略，不影响使用！\n\n\n## 参考\n\nhexo \n\n* [Github-hexojs/hexo](https://github.com/hexojs/hexo)\n* [利用Hexo在多台电脑上提交和更新github pages博客](https://www.jianshu.com/p/0b1fccce74e0)\n* [Hexo+Github+Next+GoDaddy搭建博客](http://lzhblog.site/2019/07/13/Hexo-Github-Next-GoDaddy%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/)\n\n\nNode 安装\n\n* [使用 nvm 管理不同版本的 node 与 npm](http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/)\n* [mac上安装npm](https://www.jianshu.com/p/39b4339a9b60)\n\n错误\n\n* [npm 在安装的时候提示 没有权限操作的解决办法 Error: EACCES: permission denied](https://segmentfault.com/a/1190000018660227)\n* [hexo s 404 页面不存在](https://github.com/hexojs/hexo/issues/1384)\n\n\n\n\n","slug":"关于自己博客仓库的介绍","published":1,"updated":"2020-01-14T03:35:49.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vfd001mn2cbzvjefftd","content":"<p>本文内容包含自己博客使用的 GitHub 仓库介绍及基于 Hexo 框架搭建的过程。博客地址：<a href=\"http://nelsonblog.me\" target=\"_blank\" rel=\"noopener\">http://nelsonblog.me</a></p>\n<a id=\"more\"></a>\n<p>本博客对应 GitHub 仓库地址：<a href=\"https://github.com/haoxunwang/haoxunwang.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/haoxunwang/haoxunwang.github.io</a></p>\n<p><img src=\"http://wanghaoxun.com/img/Github-io-mine.jpg\"></p>\n<h2 id=\"仓库说明：\"><a href=\"#仓库说明：\" class=\"headerlink\" title=\"仓库说明：\"></a>仓库说明：</h2><ol>\n<li>博客仓库使用 hexo 分支来保存基于 hexo 框架的源文件；hexo 生成的静态博客 html 文件默认放在 master 分支上；</li>\n<li>如果要更新博客主题，需要把主题拷贝至 theme 文件夹下；</li>\n<li>hexo 分支源文件没有保存 node_modules 文件夹，使用时需要执行 <code>npm install</code> 命令来拉取 hexo 框架依赖；</li>\n</ol>\n<p>具体可参考<a href=\"https://www.jianshu.com/p/0b1fccce74e0\" target=\"_blank\" rel=\"noopener\">这篇博客</a>设置！</p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><ul>\n<li>node_modules: hexo 需要的模块，需要 git 忽略，可以本地执行<code>npm install</code>获取</li>\n<li>themes 主题文件夹，如果需要更新主题，可以拷贝主题到这里即可）</li>\n<li>sources 博文 md 文件</li>\n<li>public 框架生成的静态网页（git 忽略）</li>\n<li>package.json 记录 hexo 需要的包信息</li>\n<li>_config.yml 全局配置文件</li>\n<li>.gitignore git 忽略配置</li>\n</ul>\n<h2 id=\"hexo-命令\"><a href=\"#hexo-命令\" class=\"headerlink\" title=\"hexo 命令\"></a>hexo 命令</h2><ul>\n<li>hexo s –debug 可以在本地部署blog，localhost:4000即可，–debug是输出调试日志</li>\n<li>hexo g 生成html文件等</li>\n<li>hexo d 部署文章到 github.io，因为本地已经关联了github的账号，具体设置在 hexo 分支的 _config.yml 全局配置文件里</li>\n<li>hexo new “xx” xx是文章title，具体的tag和category可以在MD文件中设置</li>\n</ul>\n<h2 id=\"博客发布\"><a href=\"#博客发布\" class=\"headerlink\" title=\"博客发布\"></a>博客发布</h2><p>流程：</p>\n<ol>\n<li>在仓库 hexo 分支上使用命令创建文章 <code>hexo new &quot;xx&quot;</code></li>\n<li>hexo s –debug 本地预览调试</li>\n<li>hexo g 生成 html 静态网页</li>\n<li>hexo d 快捷部署到 github </li>\n</ol>\n<h2 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h2><ul>\n<li>安装 Node </li>\n</ul>\n<p>hexo 使用 Node.js 编写，需要先安装 node，具体可以参考 <a href=\"http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/\" target=\"_blank\" rel=\"noopener\">使用 nvm 管理不同版本的 node 与 npm</a>。</p>\n<p>详细步骤：</p>\n<ol>\n<li>终端执行 <code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash</code> 命令安装来 nvm，其中 v0.35.1 是版本号，最新版本命令去这里获取 <a href=\"https://github.com/nvm-sh/nvm#install-script\" target=\"_blank\" rel=\"noopener\">Github/nvm</a>；</li>\n<li><p>添加如下配置到 <code>~/.bash_profile</code>文件里，再执行 <code>source ~/.bash_profile</code> 命令 重新刷新下配置；</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export NVM_DIR=&quot;$([ -z &quot;$&#123;XDG_CONFIG_HOME-&#125;&quot; ] &amp;&amp; printf %s &quot;$&#123;HOME&#125;/.nvm&quot; || printf %s &quot;$&#123;XDG_CONFIG_HOME&#125;/nvm&quot;)&quot;</span><br><span class=\"line\">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装 Node</p>\n<p> 执行<code>nvm install 13.3.0</code>安装 Node，13.3.0 为版本号，最新版本号查看<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">这里</a>；</p>\n</li>\n</ol>\n<ul>\n<li>安装 Hexo </li>\n</ul>\n<p>使用 node nmp 包管理器来安装依赖模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 安装 hexo </span><br><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\"></span><br><span class=\"line\">// 在自己博客文件夹下执行</span><br><span class=\"line\">hexo init </span><br><span class=\"line\"></span><br><span class=\"line\">// 安装依赖</span><br><span class=\"line\">npm install </span><br><span class=\"line\"></span><br><span class=\"line\">// 写博客/发布等等...</span><br><span class=\"line\">hexo new &quot;xx&quot; 创建文章</span><br><span class=\"line\">hexo generate 本地生成静态网页</span><br><span class=\"line\">hexo server 本地发布</span><br></pre></td></tr></table></figure>\n<h2 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h2><ul>\n<li>npm install 报各种 permissions denied</li>\n</ul>\n<p>hexo 框架使用 Node.js 编写，本地环境需要安装 Node.js，具体安装请参考<a href=\"https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally\" target=\"_blank\" rel=\"noopener\">官网</a>，官方推荐用 nvm 管理器来安装，不推荐使用 <code>brew install node</code>，因为 node 的包管理器-npm 后面安装其他依赖时，会报各种 permissions 错误！ nvm 安装 node 可以参考 <a href=\"http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/\" target=\"_blank\" rel=\"noopener\">使用 nvm 管理不同版本的 node 与 npm</a>。</p>\n<ul>\n<li>npm install 报错</li>\n</ul>\n<p>使用 nvm 安装 node 之后，npm install 其他依赖时还会报权限错误，可以忽略，不影响使用！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>hexo </p>\n<ul>\n<li><a href=\"https://github.com/hexojs/hexo\" target=\"_blank\" rel=\"noopener\">Github-hexojs/hexo</a></li>\n<li><a href=\"https://www.jianshu.com/p/0b1fccce74e0\" target=\"_blank\" rel=\"noopener\">利用Hexo在多台电脑上提交和更新github pages博客</a></li>\n<li><a href=\"http://lzhblog.site/2019/07/13/Hexo-Github-Next-GoDaddy%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\" target=\"_blank\" rel=\"noopener\">Hexo+Github+Next+GoDaddy搭建博客</a></li>\n</ul>\n<p>Node 安装</p>\n<ul>\n<li><a href=\"http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/\" target=\"_blank\" rel=\"noopener\">使用 nvm 管理不同版本的 node 与 npm</a></li>\n<li><a href=\"https://www.jianshu.com/p/39b4339a9b60\" target=\"_blank\" rel=\"noopener\">mac上安装npm</a></li>\n</ul>\n<p>错误</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000018660227\" target=\"_blank\" rel=\"noopener\">npm 在安装的时候提示 没有权限操作的解决办法 Error: EACCES: permission denied</a></li>\n<li><a href=\"https://github.com/hexojs/hexo/issues/1384\" target=\"_blank\" rel=\"noopener\">hexo s 404 页面不存在</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文内容包含自己博客使用的 GitHub 仓库介绍及基于 Hexo 框架搭建的过程。博客地址：<a href=\"http://nelsonblog.me\" target=\"_blank\" rel=\"noopener\">http://nelsonblog.me</a></p>","more":"<p>本博客对应 GitHub 仓库地址：<a href=\"https://github.com/haoxunwang/haoxunwang.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/haoxunwang/haoxunwang.github.io</a></p>\n<p><img src=\"http://wanghaoxun.com/img/Github-io-mine.jpg\"></p>\n<h2 id=\"仓库说明：\"><a href=\"#仓库说明：\" class=\"headerlink\" title=\"仓库说明：\"></a>仓库说明：</h2><ol>\n<li>博客仓库使用 hexo 分支来保存基于 hexo 框架的源文件；hexo 生成的静态博客 html 文件默认放在 master 分支上；</li>\n<li>如果要更新博客主题，需要把主题拷贝至 theme 文件夹下；</li>\n<li>hexo 分支源文件没有保存 node_modules 文件夹，使用时需要执行 <code>npm install</code> 命令来拉取 hexo 框架依赖；</li>\n</ol>\n<p>具体可参考<a href=\"https://www.jianshu.com/p/0b1fccce74e0\" target=\"_blank\" rel=\"noopener\">这篇博客</a>设置！</p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><ul>\n<li>node_modules: hexo 需要的模块，需要 git 忽略，可以本地执行<code>npm install</code>获取</li>\n<li>themes 主题文件夹，如果需要更新主题，可以拷贝主题到这里即可）</li>\n<li>sources 博文 md 文件</li>\n<li>public 框架生成的静态网页（git 忽略）</li>\n<li>package.json 记录 hexo 需要的包信息</li>\n<li>_config.yml 全局配置文件</li>\n<li>.gitignore git 忽略配置</li>\n</ul>\n<h2 id=\"hexo-命令\"><a href=\"#hexo-命令\" class=\"headerlink\" title=\"hexo 命令\"></a>hexo 命令</h2><ul>\n<li>hexo s –debug 可以在本地部署blog，localhost:4000即可，–debug是输出调试日志</li>\n<li>hexo g 生成html文件等</li>\n<li>hexo d 部署文章到 github.io，因为本地已经关联了github的账号，具体设置在 hexo 分支的 _config.yml 全局配置文件里</li>\n<li>hexo new “xx” xx是文章title，具体的tag和category可以在MD文件中设置</li>\n</ul>\n<h2 id=\"博客发布\"><a href=\"#博客发布\" class=\"headerlink\" title=\"博客发布\"></a>博客发布</h2><p>流程：</p>\n<ol>\n<li>在仓库 hexo 分支上使用命令创建文章 <code>hexo new &quot;xx&quot;</code></li>\n<li>hexo s –debug 本地预览调试</li>\n<li>hexo g 生成 html 静态网页</li>\n<li>hexo d 快捷部署到 github </li>\n</ol>\n<h2 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h2><ul>\n<li>安装 Node </li>\n</ul>\n<p>hexo 使用 Node.js 编写，需要先安装 node，具体可以参考 <a href=\"http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/\" target=\"_blank\" rel=\"noopener\">使用 nvm 管理不同版本的 node 与 npm</a>。</p>\n<p>详细步骤：</p>\n<ol>\n<li>终端执行 <code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash</code> 命令安装来 nvm，其中 v0.35.1 是版本号，最新版本命令去这里获取 <a href=\"https://github.com/nvm-sh/nvm#install-script\" target=\"_blank\" rel=\"noopener\">Github/nvm</a>；</li>\n<li><p>添加如下配置到 <code>~/.bash_profile</code>文件里，再执行 <code>source ~/.bash_profile</code> 命令 重新刷新下配置；</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export NVM_DIR=&quot;$([ -z &quot;$&#123;XDG_CONFIG_HOME-&#125;&quot; ] &amp;&amp; printf %s &quot;$&#123;HOME&#125;/.nvm&quot; || printf %s &quot;$&#123;XDG_CONFIG_HOME&#125;/nvm&quot;)&quot;</span><br><span class=\"line\">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装 Node</p>\n<p> 执行<code>nvm install 13.3.0</code>安装 Node，13.3.0 为版本号，最新版本号查看<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">这里</a>；</p>\n</li>\n</ol>\n<ul>\n<li>安装 Hexo </li>\n</ul>\n<p>使用 node nmp 包管理器来安装依赖模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 安装 hexo </span><br><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\"></span><br><span class=\"line\">// 在自己博客文件夹下执行</span><br><span class=\"line\">hexo init </span><br><span class=\"line\"></span><br><span class=\"line\">// 安装依赖</span><br><span class=\"line\">npm install </span><br><span class=\"line\"></span><br><span class=\"line\">// 写博客/发布等等...</span><br><span class=\"line\">hexo new &quot;xx&quot; 创建文章</span><br><span class=\"line\">hexo generate 本地生成静态网页</span><br><span class=\"line\">hexo server 本地发布</span><br></pre></td></tr></table></figure>\n<h2 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h2><ul>\n<li>npm install 报各种 permissions denied</li>\n</ul>\n<p>hexo 框架使用 Node.js 编写，本地环境需要安装 Node.js，具体安装请参考<a href=\"https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally\" target=\"_blank\" rel=\"noopener\">官网</a>，官方推荐用 nvm 管理器来安装，不推荐使用 <code>brew install node</code>，因为 node 的包管理器-npm 后面安装其他依赖时，会报各种 permissions 错误！ nvm 安装 node 可以参考 <a href=\"http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/\" target=\"_blank\" rel=\"noopener\">使用 nvm 管理不同版本的 node 与 npm</a>。</p>\n<ul>\n<li>npm install 报错</li>\n</ul>\n<p>使用 nvm 安装 node 之后，npm install 其他依赖时还会报权限错误，可以忽略，不影响使用！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>hexo </p>\n<ul>\n<li><a href=\"https://github.com/hexojs/hexo\" target=\"_blank\" rel=\"noopener\">Github-hexojs/hexo</a></li>\n<li><a href=\"https://www.jianshu.com/p/0b1fccce74e0\" target=\"_blank\" rel=\"noopener\">利用Hexo在多台电脑上提交和更新github pages博客</a></li>\n<li><a href=\"http://lzhblog.site/2019/07/13/Hexo-Github-Next-GoDaddy%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\" target=\"_blank\" rel=\"noopener\">Hexo+Github+Next+GoDaddy搭建博客</a></li>\n</ul>\n<p>Node 安装</p>\n<ul>\n<li><a href=\"http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/\" target=\"_blank\" rel=\"noopener\">使用 nvm 管理不同版本的 node 与 npm</a></li>\n<li><a href=\"https://www.jianshu.com/p/39b4339a9b60\" target=\"_blank\" rel=\"noopener\">mac上安装npm</a></li>\n</ul>\n<p>错误</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000018660227\" target=\"_blank\" rel=\"noopener\">npm 在安装的时候提示 没有权限操作的解决办法 Error: EACCES: permission denied</a></li>\n<li><a href=\"https://github.com/hexojs/hexo/issues/1384\" target=\"_blank\" rel=\"noopener\">hexo s 404 页面不存在</a></li>\n</ul>"},{"title":"如何打败拖延症","date":"2017-04-02T15:41:12.000Z","_content":"\n**拖延症**：一种没有任何理由毁掉你自己人生的行为。\n[Wait But Why](http://waitbutwhy.com/)（一个专注于写专题长文的博客网站，风格简洁，插图的火柴人有趣又吸引人。作者及其富有洞察力，用他们特有的幽默文风吸引了全世界各地的读者）的创始人Tim Urban在TED的演讲中，用一本正经的幽默方式分析了拖延症者的心理机制。\n\n![拖延症](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_1.jpg)\n\n<!-- more -->\n\n## 拖延症分析\n\n### 拖延症患者脑中有一只及时行乐猴（instant gratific monkey），一个理性决策者和一只惊慌怪兽（the panic monster）\n![](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_2.jpg)\n\n- *及时行乐猴只关注两点：简单（easy）和开心（fun）*\n![](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_3.jpg)\n\n- *理性决策者，可以从大局出发，进行长期规划，他使人类有能力做到其他动物无法做到的事情*\n![](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_4.jpg)\n\n有时简单的事情有一定的合理性，休假、吃饭等等，有时候两者也会有重合区域，但有些时候，从长远的角度来看，一些更困难不开心的事情才是更合理的，所以及时行乐猴和理性决策者就出现了冲突，及时行乐猴与理性决策者争夺指挥权\n![](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_5.jpg)\n\n及时行乐猴夺得指挥权，指挥拖延症患者做了本不该进行的休闲活动。这会让他们内疚、恐惧、焦虑和自我憎恨，这些都是拖延症患者常有的情绪。\n\n- *每个拖延症患者都有一个一直关注着他的人——惊慌怪兽*\n\n![惊慌怪兽](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_8.jpg)\n\n惊慌怪兽在Deadline到来或者有当众出丑的危险时或者出现职业灾难或者其他恐怖情况时突然醒来，并且最重要的是，他是及时行乐猴唯一害怕的东西。\n惊慌怪兽觉醒，吓跑了猴子，终于理性决策者重新掌握了方向盘。\n\n以上，是拖延症的一种情况——有着Deadline的拖延症，其实，拖延症分为两种，而另一种是没有deadline的拖延症，比如看望家人，锻炼身体，保持健康，维系感情等。没有deadline的拖延症是不会出现惊慌怪兽，因此，这种长期的拖延使人们感觉到害怕。有时候梦想可能不是没有实现，而是还没有开始。\n\n## 试图解决拖延症\n拖延症这种病的发生并不是毫无理由的。想要解决它，光是“自律“或者”改掉坏xx惯“这种没用的字眼都是不够的。问题的源头深深植根于他们的犯病套路中，所以要想改掉拖延症，就必须改掉他们每天的套路。\n在试图改变拖延症患者的套路之前，我们首先要搞明白，拖延症患者最终的康复目标。正确的做事xx惯到底应该是什么样子的，而拖延症患者都是在哪里遇到问题了呢？\n\n### 计划\n\n拖延症患者最喜欢计划了！为什么？很简单，因为计划不需要你去真正的做什么事情，而做事就是拖延症患者的死。\n但是在拖延症患者做计划的时候，他们喜欢用一种模糊而且不考虑现实和细节的方式来计划，所以他们的计划最后导致他们什么都做不成。拖延症患者的计划就是行动者的噩梦：\n计划里都是模糊不清、吓人的任务和事业。\n![](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_6.jpg)\n\n**问题**\n\n* 拖延症患者非常喜欢用那些“紧急任务”来当作借口，把重要的任务一直往后拖\n* 一个模糊的任务含糊不清，模棱两可，你既不知道应该从哪里下手，也不知道有了问题应该去哪里寻求答案\n\n**解决**\n\n* 完成一件事，开始：计划，有效计划越长越好，并且要有优先级\n* 基本上所有庞大的事业，都可以被分解为一个核心的步骤，也就是房子的砖块。所以最后事情都归结于着小小的砖块\n\n现在你已经学会了如何进行有效的计划，那么就让我们开始考虑如何继续”行动“：\n\n### 行动\n\n并不是拖延症患者不喜欢“行动”这个概念。他们看着自己日历上面搬砖的计划，心里想着“太好了，一定很有意思”。他们这么想，完全是因为他们在心中描绘未来完成任务的情景时，完全忘记了把即时行乐猴这个元素加入他们的考虑之中。拖延症患者的未来愿景中似乎从来都没有猴子。\n但是当日历上需要搬砖垒砖的时刻真正到来了，拖延症患者就开始做他们最擅长的事情了——把控制权拱手交给猴子，然后让猴子把一切都玩坏。\n\n**解决**\n\n* ”关键入口“是你正式开始着手于任务\n* 你需要第一件需要做的事情就是，你必须穿过“关键入口”\n* 要坚强，如果你能够成功把猴子拖进黑暗森林，你就消磨了它的一部分意志\n* 在执行任务的时候一旦有了进展，你的成就感和自尊心都会得到增强\n\n努力穿越临界点是一件很难的事，但是更难的事却是及时行乐猴有一个很短的记忆周期。就算你周一工作非常成功，到了周二或者周三，猴子就什么都忘了，又开始阻拦你进入黑暗森林。\n这就是为什么坚持是成功最关键的因素。每摆放一块砖头，你就经历了一次内心的挣扎，——直到最后，每天的重复才让获得了对自己和这个世界的掌控。\n所以这就是战胜拖延症的必经之路。但是如果拖延症患者读了这个文章就不治而愈，那么拖延症也就不会是这么大的问题了。只有一个可以战胜拖延症的实实在在的办法：\n\n**你需要向自己证明，你可以做到。**\n\n你需要向自己证明自己可以做到，而不是告诉自己明天自己大概可以完成任务。直到你向自己证明了这一点，你永远都不相信自己有能力做到更好，有能力改变自己。\n\n死守日历线，有合理的小计划，行动起来！！！\n\n![生命日历](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_7.jpg)\n\n---\n\n> Tim Urban shared about the delay on the TED.\n\n一起欣赏Tim Urban这段幽默风趣的演讲(Tim Urban in TED)：\n<iframe height=398 width=510 src=\"http://omdtn071e.bkt.clouddn.com/%E6%8B%96%E5%BB%B6%E7%97%87.mp4\" align=\"middle\" frameborder=0 allowfullscreen></iframe>\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/如何打败拖延症.md","raw":"---\ntitle: 如何打败拖延症\ndate: 2017-04-02 23:41:12\ntags: Life\ncategories: Life\n---\n\n**拖延症**：一种没有任何理由毁掉你自己人生的行为。\n[Wait But Why](http://waitbutwhy.com/)（一个专注于写专题长文的博客网站，风格简洁，插图的火柴人有趣又吸引人。作者及其富有洞察力，用他们特有的幽默文风吸引了全世界各地的读者）的创始人Tim Urban在TED的演讲中，用一本正经的幽默方式分析了拖延症者的心理机制。\n\n![拖延症](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_1.jpg)\n\n<!-- more -->\n\n## 拖延症分析\n\n### 拖延症患者脑中有一只及时行乐猴（instant gratific monkey），一个理性决策者和一只惊慌怪兽（the panic monster）\n![](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_2.jpg)\n\n- *及时行乐猴只关注两点：简单（easy）和开心（fun）*\n![](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_3.jpg)\n\n- *理性决策者，可以从大局出发，进行长期规划，他使人类有能力做到其他动物无法做到的事情*\n![](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_4.jpg)\n\n有时简单的事情有一定的合理性，休假、吃饭等等，有时候两者也会有重合区域，但有些时候，从长远的角度来看，一些更困难不开心的事情才是更合理的，所以及时行乐猴和理性决策者就出现了冲突，及时行乐猴与理性决策者争夺指挥权\n![](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_5.jpg)\n\n及时行乐猴夺得指挥权，指挥拖延症患者做了本不该进行的休闲活动。这会让他们内疚、恐惧、焦虑和自我憎恨，这些都是拖延症患者常有的情绪。\n\n- *每个拖延症患者都有一个一直关注着他的人——惊慌怪兽*\n\n![惊慌怪兽](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_8.jpg)\n\n惊慌怪兽在Deadline到来或者有当众出丑的危险时或者出现职业灾难或者其他恐怖情况时突然醒来，并且最重要的是，他是及时行乐猴唯一害怕的东西。\n惊慌怪兽觉醒，吓跑了猴子，终于理性决策者重新掌握了方向盘。\n\n以上，是拖延症的一种情况——有着Deadline的拖延症，其实，拖延症分为两种，而另一种是没有deadline的拖延症，比如看望家人，锻炼身体，保持健康，维系感情等。没有deadline的拖延症是不会出现惊慌怪兽，因此，这种长期的拖延使人们感觉到害怕。有时候梦想可能不是没有实现，而是还没有开始。\n\n## 试图解决拖延症\n拖延症这种病的发生并不是毫无理由的。想要解决它，光是“自律“或者”改掉坏xx惯“这种没用的字眼都是不够的。问题的源头深深植根于他们的犯病套路中，所以要想改掉拖延症，就必须改掉他们每天的套路。\n在试图改变拖延症患者的套路之前，我们首先要搞明白，拖延症患者最终的康复目标。正确的做事xx惯到底应该是什么样子的，而拖延症患者都是在哪里遇到问题了呢？\n\n### 计划\n\n拖延症患者最喜欢计划了！为什么？很简单，因为计划不需要你去真正的做什么事情，而做事就是拖延症患者的死。\n但是在拖延症患者做计划的时候，他们喜欢用一种模糊而且不考虑现实和细节的方式来计划，所以他们的计划最后导致他们什么都做不成。拖延症患者的计划就是行动者的噩梦：\n计划里都是模糊不清、吓人的任务和事业。\n![](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_6.jpg)\n\n**问题**\n\n* 拖延症患者非常喜欢用那些“紧急任务”来当作借口，把重要的任务一直往后拖\n* 一个模糊的任务含糊不清，模棱两可，你既不知道应该从哪里下手，也不知道有了问题应该去哪里寻求答案\n\n**解决**\n\n* 完成一件事，开始：计划，有效计划越长越好，并且要有优先级\n* 基本上所有庞大的事业，都可以被分解为一个核心的步骤，也就是房子的砖块。所以最后事情都归结于着小小的砖块\n\n现在你已经学会了如何进行有效的计划，那么就让我们开始考虑如何继续”行动“：\n\n### 行动\n\n并不是拖延症患者不喜欢“行动”这个概念。他们看着自己日历上面搬砖的计划，心里想着“太好了，一定很有意思”。他们这么想，完全是因为他们在心中描绘未来完成任务的情景时，完全忘记了把即时行乐猴这个元素加入他们的考虑之中。拖延症患者的未来愿景中似乎从来都没有猴子。\n但是当日历上需要搬砖垒砖的时刻真正到来了，拖延症患者就开始做他们最擅长的事情了——把控制权拱手交给猴子，然后让猴子把一切都玩坏。\n\n**解决**\n\n* ”关键入口“是你正式开始着手于任务\n* 你需要第一件需要做的事情就是，你必须穿过“关键入口”\n* 要坚强，如果你能够成功把猴子拖进黑暗森林，你就消磨了它的一部分意志\n* 在执行任务的时候一旦有了进展，你的成就感和自尊心都会得到增强\n\n努力穿越临界点是一件很难的事，但是更难的事却是及时行乐猴有一个很短的记忆周期。就算你周一工作非常成功，到了周二或者周三，猴子就什么都忘了，又开始阻拦你进入黑暗森林。\n这就是为什么坚持是成功最关键的因素。每摆放一块砖头，你就经历了一次内心的挣扎，——直到最后，每天的重复才让获得了对自己和这个世界的掌控。\n所以这就是战胜拖延症的必经之路。但是如果拖延症患者读了这个文章就不治而愈，那么拖延症也就不会是这么大的问题了。只有一个可以战胜拖延症的实实在在的办法：\n\n**你需要向自己证明，你可以做到。**\n\n你需要向自己证明自己可以做到，而不是告诉自己明天自己大概可以完成任务。直到你向自己证明了这一点，你永远都不相信自己有能力做到更好，有能力改变自己。\n\n死守日历线，有合理的小计划，行动起来！！！\n\n![生命日历](http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_7.jpg)\n\n---\n\n> Tim Urban shared about the delay on the TED.\n\n一起欣赏Tim Urban这段幽默风趣的演讲(Tim Urban in TED)：\n<iframe height=398 width=510 src=\"http://omdtn071e.bkt.clouddn.com/%E6%8B%96%E5%BB%B6%E7%97%87.mp4\" align=\"middle\" frameborder=0 allowfullscreen></iframe>\n\n\n\n\n\n\n\n\n\n\n\n","slug":"如何打败拖延症","published":1,"updated":"2020-01-14T03:35:49.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vfe001pn2cb01k5wf8m","content":"<p><strong>拖延症</strong>：一种没有任何理由毁掉你自己人生的行为。<br><a href=\"http://waitbutwhy.com/\" target=\"_blank\" rel=\"noopener\">Wait But Why</a>（一个专注于写专题长文的博客网站，风格简洁，插图的火柴人有趣又吸引人。作者及其富有洞察力，用他们特有的幽默文风吸引了全世界各地的读者）的创始人Tim Urban在TED的演讲中，用一本正经的幽默方式分析了拖延症者的心理机制。</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_1.jpg\" alt=\"拖延症\"></p>\n<a id=\"more\"></a>\n<h2 id=\"拖延症分析\"><a href=\"#拖延症分析\" class=\"headerlink\" title=\"拖延症分析\"></a>拖延症分析</h2><h3 id=\"拖延症患者脑中有一只及时行乐猴（instant-gratific-monkey），一个理性决策者和一只惊慌怪兽（the-panic-monster）\"><a href=\"#拖延症患者脑中有一只及时行乐猴（instant-gratific-monkey），一个理性决策者和一只惊慌怪兽（the-panic-monster）\" class=\"headerlink\" title=\"拖延症患者脑中有一只及时行乐猴（instant gratific monkey），一个理性决策者和一只惊慌怪兽（the panic monster）\"></a>拖延症患者脑中有一只及时行乐猴（instant gratific monkey），一个理性决策者和一只惊慌怪兽（the panic monster）</h3><p><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_2.jpg\" alt></p>\n<ul>\n<li><p><em>及时行乐猴只关注两点：简单（easy）和开心（fun）</em><br><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_3.jpg\" alt></p>\n</li>\n<li><p><em>理性决策者，可以从大局出发，进行长期规划，他使人类有能力做到其他动物无法做到的事情</em><br><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_4.jpg\" alt></p>\n</li>\n</ul>\n<p>有时简单的事情有一定的合理性，休假、吃饭等等，有时候两者也会有重合区域，但有些时候，从长远的角度来看，一些更困难不开心的事情才是更合理的，所以及时行乐猴和理性决策者就出现了冲突，及时行乐猴与理性决策者争夺指挥权<br><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_5.jpg\" alt></p>\n<p>及时行乐猴夺得指挥权，指挥拖延症患者做了本不该进行的休闲活动。这会让他们内疚、恐惧、焦虑和自我憎恨，这些都是拖延症患者常有的情绪。</p>\n<ul>\n<li><em>每个拖延症患者都有一个一直关注着他的人——惊慌怪兽</em></li>\n</ul>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_8.jpg\" alt=\"惊慌怪兽\"></p>\n<p>惊慌怪兽在Deadline到来或者有当众出丑的危险时或者出现职业灾难或者其他恐怖情况时突然醒来，并且最重要的是，他是及时行乐猴唯一害怕的东西。<br>惊慌怪兽觉醒，吓跑了猴子，终于理性决策者重新掌握了方向盘。</p>\n<p>以上，是拖延症的一种情况——有着Deadline的拖延症，其实，拖延症分为两种，而另一种是没有deadline的拖延症，比如看望家人，锻炼身体，保持健康，维系感情等。没有deadline的拖延症是不会出现惊慌怪兽，因此，这种长期的拖延使人们感觉到害怕。有时候梦想可能不是没有实现，而是还没有开始。</p>\n<h2 id=\"试图解决拖延症\"><a href=\"#试图解决拖延症\" class=\"headerlink\" title=\"试图解决拖延症\"></a>试图解决拖延症</h2><p>拖延症这种病的发生并不是毫无理由的。想要解决它，光是“自律“或者”改掉坏xx惯“这种没用的字眼都是不够的。问题的源头深深植根于他们的犯病套路中，所以要想改掉拖延症，就必须改掉他们每天的套路。<br>在试图改变拖延症患者的套路之前，我们首先要搞明白，拖延症患者最终的康复目标。正确的做事xx惯到底应该是什么样子的，而拖延症患者都是在哪里遇到问题了呢？</p>\n<h3 id=\"计划\"><a href=\"#计划\" class=\"headerlink\" title=\"计划\"></a>计划</h3><p>拖延症患者最喜欢计划了！为什么？很简单，因为计划不需要你去真正的做什么事情，而做事就是拖延症患者的死。<br>但是在拖延症患者做计划的时候，他们喜欢用一种模糊而且不考虑现实和细节的方式来计划，所以他们的计划最后导致他们什么都做不成。拖延症患者的计划就是行动者的噩梦：<br>计划里都是模糊不清、吓人的任务和事业。<br><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_6.jpg\" alt></p>\n<p><strong>问题</strong></p>\n<ul>\n<li>拖延症患者非常喜欢用那些“紧急任务”来当作借口，把重要的任务一直往后拖</li>\n<li>一个模糊的任务含糊不清，模棱两可，你既不知道应该从哪里下手，也不知道有了问题应该去哪里寻求答案</li>\n</ul>\n<p><strong>解决</strong></p>\n<ul>\n<li>完成一件事，开始：计划，有效计划越长越好，并且要有优先级</li>\n<li>基本上所有庞大的事业，都可以被分解为一个核心的步骤，也就是房子的砖块。所以最后事情都归结于着小小的砖块</li>\n</ul>\n<p>现在你已经学会了如何进行有效的计划，那么就让我们开始考虑如何继续”行动“：</p>\n<h3 id=\"行动\"><a href=\"#行动\" class=\"headerlink\" title=\"行动\"></a>行动</h3><p>并不是拖延症患者不喜欢“行动”这个概念。他们看着自己日历上面搬砖的计划，心里想着“太好了，一定很有意思”。他们这么想，完全是因为他们在心中描绘未来完成任务的情景时，完全忘记了把即时行乐猴这个元素加入他们的考虑之中。拖延症患者的未来愿景中似乎从来都没有猴子。<br>但是当日历上需要搬砖垒砖的时刻真正到来了，拖延症患者就开始做他们最擅长的事情了——把控制权拱手交给猴子，然后让猴子把一切都玩坏。</p>\n<p><strong>解决</strong></p>\n<ul>\n<li>”关键入口“是你正式开始着手于任务</li>\n<li>你需要第一件需要做的事情就是，你必须穿过“关键入口”</li>\n<li>要坚强，如果你能够成功把猴子拖进黑暗森林，你就消磨了它的一部分意志</li>\n<li>在执行任务的时候一旦有了进展，你的成就感和自尊心都会得到增强</li>\n</ul>\n<p>努力穿越临界点是一件很难的事，但是更难的事却是及时行乐猴有一个很短的记忆周期。就算你周一工作非常成功，到了周二或者周三，猴子就什么都忘了，又开始阻拦你进入黑暗森林。<br>这就是为什么坚持是成功最关键的因素。每摆放一块砖头，你就经历了一次内心的挣扎，——直到最后，每天的重复才让获得了对自己和这个世界的掌控。<br>所以这就是战胜拖延症的必经之路。但是如果拖延症患者读了这个文章就不治而愈，那么拖延症也就不会是这么大的问题了。只有一个可以战胜拖延症的实实在在的办法：</p>\n<p><strong>你需要向自己证明，你可以做到。</strong></p>\n<p>你需要向自己证明自己可以做到，而不是告诉自己明天自己大概可以完成任务。直到你向自己证明了这一点，你永远都不相信自己有能力做到更好，有能力改变自己。</p>\n<p>死守日历线，有合理的小计划，行动起来！！！</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_7.jpg\" alt=\"生命日历\"></p>\n<hr>\n<blockquote>\n<p>Tim Urban shared about the delay on the TED.</p>\n</blockquote>\n<p>一起欣赏Tim Urban这段幽默风趣的演讲(Tim Urban in TED)：</p>\n<iframe height=\"398\" width=\"510\" src=\"http://omdtn071e.bkt.clouddn.com/%E6%8B%96%E5%BB%B6%E7%97%87.mp4\" align=\"middle\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p><strong>拖延症</strong>：一种没有任何理由毁掉你自己人生的行为。<br><a href=\"http://waitbutwhy.com/\" target=\"_blank\" rel=\"noopener\">Wait But Why</a>（一个专注于写专题长文的博客网站，风格简洁，插图的火柴人有趣又吸引人。作者及其富有洞察力，用他们特有的幽默文风吸引了全世界各地的读者）的创始人Tim Urban在TED的演讲中，用一本正经的幽默方式分析了拖延症者的心理机制。</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_1.jpg\" alt=\"拖延症\"></p>","more":"<h2 id=\"拖延症分析\"><a href=\"#拖延症分析\" class=\"headerlink\" title=\"拖延症分析\"></a>拖延症分析</h2><h3 id=\"拖延症患者脑中有一只及时行乐猴（instant-gratific-monkey），一个理性决策者和一只惊慌怪兽（the-panic-monster）\"><a href=\"#拖延症患者脑中有一只及时行乐猴（instant-gratific-monkey），一个理性决策者和一只惊慌怪兽（the-panic-monster）\" class=\"headerlink\" title=\"拖延症患者脑中有一只及时行乐猴（instant gratific monkey），一个理性决策者和一只惊慌怪兽（the panic monster）\"></a>拖延症患者脑中有一只及时行乐猴（instant gratific monkey），一个理性决策者和一只惊慌怪兽（the panic monster）</h3><p><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_2.jpg\" alt></p>\n<ul>\n<li><p><em>及时行乐猴只关注两点：简单（easy）和开心（fun）</em><br><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_3.jpg\" alt></p>\n</li>\n<li><p><em>理性决策者，可以从大局出发，进行长期规划，他使人类有能力做到其他动物无法做到的事情</em><br><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_4.jpg\" alt></p>\n</li>\n</ul>\n<p>有时简单的事情有一定的合理性，休假、吃饭等等，有时候两者也会有重合区域，但有些时候，从长远的角度来看，一些更困难不开心的事情才是更合理的，所以及时行乐猴和理性决策者就出现了冲突，及时行乐猴与理性决策者争夺指挥权<br><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_5.jpg\" alt></p>\n<p>及时行乐猴夺得指挥权，指挥拖延症患者做了本不该进行的休闲活动。这会让他们内疚、恐惧、焦虑和自我憎恨，这些都是拖延症患者常有的情绪。</p>\n<ul>\n<li><em>每个拖延症患者都有一个一直关注着他的人——惊慌怪兽</em></li>\n</ul>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_8.jpg\" alt=\"惊慌怪兽\"></p>\n<p>惊慌怪兽在Deadline到来或者有当众出丑的危险时或者出现职业灾难或者其他恐怖情况时突然醒来，并且最重要的是，他是及时行乐猴唯一害怕的东西。<br>惊慌怪兽觉醒，吓跑了猴子，终于理性决策者重新掌握了方向盘。</p>\n<p>以上，是拖延症的一种情况——有着Deadline的拖延症，其实，拖延症分为两种，而另一种是没有deadline的拖延症，比如看望家人，锻炼身体，保持健康，维系感情等。没有deadline的拖延症是不会出现惊慌怪兽，因此，这种长期的拖延使人们感觉到害怕。有时候梦想可能不是没有实现，而是还没有开始。</p>\n<h2 id=\"试图解决拖延症\"><a href=\"#试图解决拖延症\" class=\"headerlink\" title=\"试图解决拖延症\"></a>试图解决拖延症</h2><p>拖延症这种病的发生并不是毫无理由的。想要解决它，光是“自律“或者”改掉坏xx惯“这种没用的字眼都是不够的。问题的源头深深植根于他们的犯病套路中，所以要想改掉拖延症，就必须改掉他们每天的套路。<br>在试图改变拖延症患者的套路之前，我们首先要搞明白，拖延症患者最终的康复目标。正确的做事xx惯到底应该是什么样子的，而拖延症患者都是在哪里遇到问题了呢？</p>\n<h3 id=\"计划\"><a href=\"#计划\" class=\"headerlink\" title=\"计划\"></a>计划</h3><p>拖延症患者最喜欢计划了！为什么？很简单，因为计划不需要你去真正的做什么事情，而做事就是拖延症患者的死。<br>但是在拖延症患者做计划的时候，他们喜欢用一种模糊而且不考虑现实和细节的方式来计划，所以他们的计划最后导致他们什么都做不成。拖延症患者的计划就是行动者的噩梦：<br>计划里都是模糊不清、吓人的任务和事业。<br><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_6.jpg\" alt></p>\n<p><strong>问题</strong></p>\n<ul>\n<li>拖延症患者非常喜欢用那些“紧急任务”来当作借口，把重要的任务一直往后拖</li>\n<li>一个模糊的任务含糊不清，模棱两可，你既不知道应该从哪里下手，也不知道有了问题应该去哪里寻求答案</li>\n</ul>\n<p><strong>解决</strong></p>\n<ul>\n<li>完成一件事，开始：计划，有效计划越长越好，并且要有优先级</li>\n<li>基本上所有庞大的事业，都可以被分解为一个核心的步骤，也就是房子的砖块。所以最后事情都归结于着小小的砖块</li>\n</ul>\n<p>现在你已经学会了如何进行有效的计划，那么就让我们开始考虑如何继续”行动“：</p>\n<h3 id=\"行动\"><a href=\"#行动\" class=\"headerlink\" title=\"行动\"></a>行动</h3><p>并不是拖延症患者不喜欢“行动”这个概念。他们看着自己日历上面搬砖的计划，心里想着“太好了，一定很有意思”。他们这么想，完全是因为他们在心中描绘未来完成任务的情景时，完全忘记了把即时行乐猴这个元素加入他们的考虑之中。拖延症患者的未来愿景中似乎从来都没有猴子。<br>但是当日历上需要搬砖垒砖的时刻真正到来了，拖延症患者就开始做他们最擅长的事情了——把控制权拱手交给猴子，然后让猴子把一切都玩坏。</p>\n<p><strong>解决</strong></p>\n<ul>\n<li>”关键入口“是你正式开始着手于任务</li>\n<li>你需要第一件需要做的事情就是，你必须穿过“关键入口”</li>\n<li>要坚强，如果你能够成功把猴子拖进黑暗森林，你就消磨了它的一部分意志</li>\n<li>在执行任务的时候一旦有了进展，你的成就感和自尊心都会得到增强</li>\n</ul>\n<p>努力穿越临界点是一件很难的事，但是更难的事却是及时行乐猴有一个很短的记忆周期。就算你周一工作非常成功，到了周二或者周三，猴子就什么都忘了，又开始阻拦你进入黑暗森林。<br>这就是为什么坚持是成功最关键的因素。每摆放一块砖头，你就经历了一次内心的挣扎，——直到最后，每天的重复才让获得了对自己和这个世界的掌控。<br>所以这就是战胜拖延症的必经之路。但是如果拖延症患者读了这个文章就不治而愈，那么拖延症也就不会是这么大的问题了。只有一个可以战胜拖延症的实实在在的办法：</p>\n<p><strong>你需要向自己证明，你可以做到。</strong></p>\n<p>你需要向自己证明自己可以做到，而不是告诉自己明天自己大概可以完成任务。直到你向自己证明了这一点，你永远都不相信自己有能力做到更好，有能力改变自己。</p>\n<p>死守日历线，有合理的小计划，行动起来！！！</p>\n<p><img src=\"http://omdtn071e.bkt.clouddn.com/%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87_7.jpg\" alt=\"生命日历\"></p>\n<hr>\n<blockquote>\n<p>Tim Urban shared about the delay on the TED.</p>\n</blockquote>\n<p>一起欣赏Tim Urban这段幽默风趣的演讲(Tim Urban in TED)：</p>\n<iframe height=\"398\" width=\"510\" src=\"http://omdtn071e.bkt.clouddn.com/%E6%8B%96%E5%BB%B6%E7%97%87.mp4\" align=\"middle\" frameborder=\"0\" allowfullscreen></iframe>"},{"title":"性能优化之Matrix","date":"2019-10-14T03:14:01.000Z","_content":"\n本文讲解微信团队开源的 Android 性能优化检测工具-[Matrix](https://github.com/Tencent/matrix) 中 TracePlugin 原理，分析检测慢函数、卡顿的过程 。\n\n<!-- more -->\n\n## 原理\n\n### Trace Plugin 代码框架\n\nTrace Canary通过字节码插桩的方式在编译期预埋了方法进入、方法退出的埋点。运行期，慢函数检测、FPS检测、卡顿检测、启动检测使用这些埋点信息排查具体哪个函数导致的异常。\n\n#### 编译期\n\n函数埋点思路：\n\n代理编译期间的任务 transformClassesWithDexTask，将全局 class 文件作为输入，利用 ASM 工具，修改字节码的方式，在编译期修改所有 class 文件中的函数字节码，对所有函数前后进行打点插桩。\n\n<img src=\"matrix_tracecanary_arch.jpg\" title=\"matrix-tracecanary总框架\"  width=\"80%\" height=\"50%\" />\n\n（图示1）matrix tracecanary总框架\n\n<img src=\"matrix_compile_flow.jpg\" title=\"matrix-编译期方法代码插装分析\"  width=\"80%\" height=\"50%\" />\n\n（图示2）matrix 编译期方法代码插装分析\n\n代码插桩的整体流程如上图。在打包过程中，hook生成Dex的Task任务，添加方法插桩的逻辑。hook点是在Proguard之后，Class已经被混淆了，所以需要考虑类混淆的问题。\n\n插桩代码逻辑大致分为三步：\n\n* hook原有的Task，执行自己的MatrixTraceTransform，并在最后执行原逻辑\n* 在方法插桩之前先要读取ClassMapping文件，获取混淆前方法、混淆后方法的映射关系并存储在MappingCollector中。\n* 之后遍历所有Dir、Jar中的Class文件，实际代码执行的时候遍历了两次。\n\n第一次遍历Class，获取所有待插桩的Method信息，并将信息输出到methodMap文件中；\n第二次遍历Class，利用ASM执行Method插桩逻辑。\n\n#### 运行期\n\n基于编译期函数插装的逻辑，在运行期，检测到某个方法异常时，会上报一个 methodId，后端通过下图的 methodId 到 method name 的映射关系，追查到有问题的方法。\n\n![matrix-methodmapping文件.jpg](matrix_methodmapping.jpg)\n\n（图示3）matrix methodmapping文件\n\n### API\n\n* FrameTracer\n\n计算掉帧率，生成 json 报告上报\n\n* UIThreadMonitor \n\nui 主线程监控 回调 doFrame(focusedActivityName, long frameCostMs) 每一帧总耗时，供 FrameTracer 来计算掉帧率（frameCostMs/frameIntervalMs 16.6667 + 1），\n\n* Choregrapher.getInstance()\n\n监控相邻两次 Vsync 事件通知的时间差\n\n* LooperMonitor \n\nimplements MessageQueue.IdleHandler 监控空闲事件\n\n### FPS 帧率检测\n\nclicfg_matrix_trace_fps_time_slice 表示检测总时长，由IDynamicConfig#getInt() 设置即可\n\n\n### 慢函数\n\n* 原理：\n\n上部分讲述了编译器，会在每个方法的执行前后添加 `AppMethodBeat.i(int methodId)`和`AppMethodBeat.o(int methodId)`的方法调用，methodId 是在编译期生成的，在运行期是一个写死的常量。通过编译期的这个操作，就能感知到具体每个方法的进入、退出操作。\n\n```java\n   /**\n     * hook method when it's called in.\n     *\n     * @param methodId\n     */\n    public static void i(int methodId) {\n\n       ...\n\n        if (Thread.currentThread().getId() == sMainThread.getId()) {\n            if (assertIn) {\n                android.util.Log.e(TAG, \"ERROR!!! AppMethodBeat.i Recursive calls!!!\");\n                return;\n            }\n            assertIn = true;\n            if (sIndex < Constants.BUFFER_SIZE) {\n                mergeData(methodId, sIndex, true);\n            } else {\n                sIndex = -1;\n            }\n            ++sIndex;\n            assertIn = false;\n        }\n    }\n\n    /**\n     * hook method when it's called out.\n     *\n     * @param methodId\n     */\n    public static void o(int methodId) {\n\n        ...\n        \n        if (Thread.currentThread().getId() == sMainThread.getId()) {\n            if (sIndex < Constants.BUFFER_SIZE) {\n                mergeData(methodId, sIndex, false);\n            } else {\n                sIndex = -1;\n            }\n            ++sIndex;\n        }\n    }\n\n```\n\n* 检测过程\n\n代码统计了当应用处于前台时，在主线程执行方法的进入、退出，这些信息存储在 AppMethodBeat 的 sBuffer「数组 long[100 * 10000]」 中。当主线程有疑似慢函数存在时，读取 Buffer 的数据，分析可能的慢函数，并上报 json 数据到后端，后端将 methodId 转换为具体的方法声明。\n\n* 发生场景\n    1. 掉帧场景\n    2. 类似 ANR 长时间主线程阻塞 UI 绘制的场景\n\n其中，掉帧场景，内部 FrameBeat 类实现了 Choreographer.FrameCallback，可以感知每一帧的绘制时间，通过前后两帧的时间差判断是否有慢函数发生；\n\n主线程长时间阻塞 UI 绘制的场景，LazyScheduler 内有一个 HandlerThread，调用 LazyScheduler.setup 方法向 HandlerThread 的 MQ 发送一个延时5s的消息，若没有发生类似 ANR 的场景，在每一帧的 doFrame 回调中取消这个消息，同时发送一个新的延时 5s 的消息（正常情况下消息是得不到执行的），若发生类似 ANR 的情况，doFrame 没有被回调，这个延时 5s 的消息得到执行，将回调到 onTimeExpire 方法。\n\n* 生成映射文件\n\n目前生成函数堆栈映射文件在工程的 `app/build/outputs/mapping/debug/methodMapping.txt`，如下格式\n\n* 分析结果\n\n<img src=\"xrk_matrix_analyse_result.png\" title=\"慢函数示例\"  width=\"30%\" height=\"50%\" />\n\n```java\n\n123570,1,com.google.zxing.client.activity.MipcaActivityCapture onWindowFocusChanged (Z)V\n...\n\n* 第一个数字表示分配方法的Id，-1表示插桩为activity加入的onWindowFocusChanged方法。其他方法从1开始计数\n* 第二个数字表示方法权限修饰符，常见的值为ACC_PUBLIC = 1; ACC_PRIVATE = 2;ACC_PROTECTED = 4; ACC_STATIC = 8等等。1即表示public方法\n* 第三个参数标识类名 包名+类名；方法名 onWindowFocusChanged；参数及返回值类型Z表示参数为boolean类型，V表示返回值为空\n\n```\n\n### 卡顿\n\n* 原因\n\n主线程执行繁重的UI绘制、大量的计算或IO等耗时操作\n\n* 方案\n\n业内主要框架的主要思想是，监控主线程执行耗时，当超过阈值时，dump出当前主线程的执行堆栈，通过堆栈分析找到卡顿原因。\n\n* 监控原理\n    \n    1. 依赖主线程 Looper，监控每次 dispatchMessage 的执行耗时。（BlockCanary）\n    2. 依赖 Choreographer 模块，监控相邻两次 Vsync 事件通知的时间差。（ArgusAPM、LogMonitor）\n\n* 生成结果\n\n<img src=\"xrk_matrix_fps_result.png\" title=\"帧率检测\"  width=\"30%\" height=\"50%\" />\n\n```java \n* scene 表示场景，使用 Activity + Fragment 类名作为唯一标志\n* dropLevel 是表示掉帧情况-掉帧次数，衡量帧率掉帧的水平\n* dropSum 总共掉帧的帧数\n* fps 表示当前帧率\n\n掉帧计算 final int droppedCount = (int) ((frameNanos - lastFrameNanos) / REFRESH_RATE_MS);\n\n```\n\n* 常见卡顿场景\n\n    * 布局嵌套层次太深，可以使用 merge、viewStub、include 来优化\n    * onDraw() 里面循环创建了大量临时变量，频繁触发 GC\n    * 主线程等待优先级子线程问题（锁同步问题）\n    * 主线程执行耗时操作，阻塞主线程执行（同步读写文件，DB 操作）\n\n## Q&A\n\n* 如何监听app 是否退到后台？\n\n通过 Application.ActivityLifecycleCallbacks 接口向全局 app 注册监听，当有 onActivityStarted(activity) 时，主动标记前台为 true，当 onActivityStopped(activity) 时，先判断当前 activity 堆栈里是否有被 paused 的页面，如果没有，则表示已退到后台。\n\n* FPS 检测时，如何判断当前是在 drawing？\n\n* stack 慢函数堆栈如何分析？\n\n可以参考 [Matrix issue #104 stack 如何分析](https://github.com/Tencent/matrix/issues/104)，或者 [hotfix/0.4.x sample-android](https://github.com/Tencent/matrix/blob/hotfix%2F0.4.x/samples/sample-android/app/src/main/java/sample/tencent/matrix/issue/IssuesListActivity.java)\n\n## 参考\n\nWeChat-Matrix\n\n* [Tencent/matrix](https://github.com/Tencent/matrix)\n* [Matrxi Release Versions](https://github.com/Tencent/matrix/releases)\n* [Matrix for Android 文档](https://github.com/Tencent/matrix#matrix_android_cn)\n* [Matrix Android TraceCanary\n](https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary)\n* [堆栈字段说明](https://github.com/Tencent/matrix/wiki/Matrix-Android--data-format)\n* [慢函数的堆栈如何解读，现在是一堆数字](https://github.com/Tencent/matrix/issues/57)\n* [matrix/home wiki](https://github.com/Tencent/matrix/wiki#%E5%B8%A7%E7%8E%87)\n* [腾讯Bugly/广研Android卡顿监控系统](http://www.10tiao.com/html/330/201801/2653579565/1.html)\n* [Github/QPM-聚美性能检测](https://github.com/ZhuoKeTeam/QPM?from=timeline)\n* [(分析到位！) Matrix源码分析————Trace Canary](https://www.qingtingip.com/h_227199.html)\n\nMatrix Stack\n\n* [Matrix-Issue/stack 如何分析](https://github.com/Tencent/matrix/issues/104)\n* [matrix的耗时方法日志解析-jar 工具](https://github.com/qhy2013/matrix_evil_method_stack_parser)\n* \n\n其它 APM\n\n* [Github/QPM](https://github.com/ZhuoKeTeam/QPM?from=timeline)\n\nChoreographer\n\n* [Android Choreographer 源码分析](https://www.jianshu.com/p/996bca12eb1d)\n\n悬浮窗\n\n* [FloatWindow 悬浮窗](https://github.com/duqian291902259/Android-FloatWindow)\n\n进程优先级\n\n* [Android adb 查看进程优先级](https://blog.csdn.net/QQxiaoqiang1573/article/details/79988752)\n* [/proc/stat解析](http://gityuan.com/2017/08/12/proc_stat/)\n* [花式读取Android CPU使用率](http://www.voidcn.com/article/p-oesjkqaq-bnv.html)\n* [Android 查看进程ID（PID）比较进程优先级](https://blog.csdn.net/Zz110753/article/details/70048811)\n\nAndroid是如何管理内存的？\n\n* [管理应用的内存](http://hukai.me/android-training-course-in-chinese/performance/memory.html)\n* [Android漫游记(1)---内存映射镜像(memory maps)](https://blog.csdn.net/lifeshow/article/details/29174457)\n* [Android性能优化之内存篇](http://hukai.me/android-performance-memory/)\n\nAndroid Davik vs Java JVM？\n\n* [一篇文章告诉你Dalvik 和JVM的区别](https://juejin.im/post/59b7fa8cf265da066d3323bb)\n* [Java JVM 中 堆，栈，方法区 详解](https://blog.csdn.net/zhangqiluGrubby/article/details/59110906)\n\n性能实践\n\n* [Andriod性能优化之列表卡顿——以“简书”APP为例](https://www.jianshu.com/p/336362b23c30)\n* [Activity界面显示全解析](https://blog.csdn.net/zhaokaiqiang1992/article/details/49681321)\n* [Android官方翻译-Android性能优化](http://hukai.me/android-training-course-in-chinese/performance/memory.html)\n* [Android UI性能优化 检测应用中的UI卡顿](https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650822205&idx=1&sn=6b8e78bc1d71eb79a199667cf132acf7&chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&mpshare=1)\n* [Android应用性能优化实践](https://mp.weixin.qq.com/s?__biz=MzA4MzEwOTkyMQ==&mid=405927192&idx=1&sn=71db45156530a20136b88851df3ef3e1&scene=4#wechat_redirect)\n* [性能优化汇总](https://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&mid=203692693&idx=1&sn=ecf0166abdb22d28463d4facd5de473b&scene=23&srcid=0215Ia7vlFqGw2lWtgZbcWBy#rd)\n\nGradle\n\n* [深入理解 Android（一）：Gradle 详解](https://www.infoq.cn/article/android-in-depth-gradle/?utm_source=infoq&utm_campaign=user_page&utm_medium=link)\n\n","source":"_posts/性能优化之Matrix.md","raw":"---\ntitle: 性能优化之Matrix\ndate: 2019-10-14 11:14:01\ntags: Android\ncategories: [Android, 性能优化]\n---\n\n本文讲解微信团队开源的 Android 性能优化检测工具-[Matrix](https://github.com/Tencent/matrix) 中 TracePlugin 原理，分析检测慢函数、卡顿的过程 。\n\n<!-- more -->\n\n## 原理\n\n### Trace Plugin 代码框架\n\nTrace Canary通过字节码插桩的方式在编译期预埋了方法进入、方法退出的埋点。运行期，慢函数检测、FPS检测、卡顿检测、启动检测使用这些埋点信息排查具体哪个函数导致的异常。\n\n#### 编译期\n\n函数埋点思路：\n\n代理编译期间的任务 transformClassesWithDexTask，将全局 class 文件作为输入，利用 ASM 工具，修改字节码的方式，在编译期修改所有 class 文件中的函数字节码，对所有函数前后进行打点插桩。\n\n<img src=\"matrix_tracecanary_arch.jpg\" title=\"matrix-tracecanary总框架\"  width=\"80%\" height=\"50%\" />\n\n（图示1）matrix tracecanary总框架\n\n<img src=\"matrix_compile_flow.jpg\" title=\"matrix-编译期方法代码插装分析\"  width=\"80%\" height=\"50%\" />\n\n（图示2）matrix 编译期方法代码插装分析\n\n代码插桩的整体流程如上图。在打包过程中，hook生成Dex的Task任务，添加方法插桩的逻辑。hook点是在Proguard之后，Class已经被混淆了，所以需要考虑类混淆的问题。\n\n插桩代码逻辑大致分为三步：\n\n* hook原有的Task，执行自己的MatrixTraceTransform，并在最后执行原逻辑\n* 在方法插桩之前先要读取ClassMapping文件，获取混淆前方法、混淆后方法的映射关系并存储在MappingCollector中。\n* 之后遍历所有Dir、Jar中的Class文件，实际代码执行的时候遍历了两次。\n\n第一次遍历Class，获取所有待插桩的Method信息，并将信息输出到methodMap文件中；\n第二次遍历Class，利用ASM执行Method插桩逻辑。\n\n#### 运行期\n\n基于编译期函数插装的逻辑，在运行期，检测到某个方法异常时，会上报一个 methodId，后端通过下图的 methodId 到 method name 的映射关系，追查到有问题的方法。\n\n![matrix-methodmapping文件.jpg](matrix_methodmapping.jpg)\n\n（图示3）matrix methodmapping文件\n\n### API\n\n* FrameTracer\n\n计算掉帧率，生成 json 报告上报\n\n* UIThreadMonitor \n\nui 主线程监控 回调 doFrame(focusedActivityName, long frameCostMs) 每一帧总耗时，供 FrameTracer 来计算掉帧率（frameCostMs/frameIntervalMs 16.6667 + 1），\n\n* Choregrapher.getInstance()\n\n监控相邻两次 Vsync 事件通知的时间差\n\n* LooperMonitor \n\nimplements MessageQueue.IdleHandler 监控空闲事件\n\n### FPS 帧率检测\n\nclicfg_matrix_trace_fps_time_slice 表示检测总时长，由IDynamicConfig#getInt() 设置即可\n\n\n### 慢函数\n\n* 原理：\n\n上部分讲述了编译器，会在每个方法的执行前后添加 `AppMethodBeat.i(int methodId)`和`AppMethodBeat.o(int methodId)`的方法调用，methodId 是在编译期生成的，在运行期是一个写死的常量。通过编译期的这个操作，就能感知到具体每个方法的进入、退出操作。\n\n```java\n   /**\n     * hook method when it's called in.\n     *\n     * @param methodId\n     */\n    public static void i(int methodId) {\n\n       ...\n\n        if (Thread.currentThread().getId() == sMainThread.getId()) {\n            if (assertIn) {\n                android.util.Log.e(TAG, \"ERROR!!! AppMethodBeat.i Recursive calls!!!\");\n                return;\n            }\n            assertIn = true;\n            if (sIndex < Constants.BUFFER_SIZE) {\n                mergeData(methodId, sIndex, true);\n            } else {\n                sIndex = -1;\n            }\n            ++sIndex;\n            assertIn = false;\n        }\n    }\n\n    /**\n     * hook method when it's called out.\n     *\n     * @param methodId\n     */\n    public static void o(int methodId) {\n\n        ...\n        \n        if (Thread.currentThread().getId() == sMainThread.getId()) {\n            if (sIndex < Constants.BUFFER_SIZE) {\n                mergeData(methodId, sIndex, false);\n            } else {\n                sIndex = -1;\n            }\n            ++sIndex;\n        }\n    }\n\n```\n\n* 检测过程\n\n代码统计了当应用处于前台时，在主线程执行方法的进入、退出，这些信息存储在 AppMethodBeat 的 sBuffer「数组 long[100 * 10000]」 中。当主线程有疑似慢函数存在时，读取 Buffer 的数据，分析可能的慢函数，并上报 json 数据到后端，后端将 methodId 转换为具体的方法声明。\n\n* 发生场景\n    1. 掉帧场景\n    2. 类似 ANR 长时间主线程阻塞 UI 绘制的场景\n\n其中，掉帧场景，内部 FrameBeat 类实现了 Choreographer.FrameCallback，可以感知每一帧的绘制时间，通过前后两帧的时间差判断是否有慢函数发生；\n\n主线程长时间阻塞 UI 绘制的场景，LazyScheduler 内有一个 HandlerThread，调用 LazyScheduler.setup 方法向 HandlerThread 的 MQ 发送一个延时5s的消息，若没有发生类似 ANR 的场景，在每一帧的 doFrame 回调中取消这个消息，同时发送一个新的延时 5s 的消息（正常情况下消息是得不到执行的），若发生类似 ANR 的情况，doFrame 没有被回调，这个延时 5s 的消息得到执行，将回调到 onTimeExpire 方法。\n\n* 生成映射文件\n\n目前生成函数堆栈映射文件在工程的 `app/build/outputs/mapping/debug/methodMapping.txt`，如下格式\n\n* 分析结果\n\n<img src=\"xrk_matrix_analyse_result.png\" title=\"慢函数示例\"  width=\"30%\" height=\"50%\" />\n\n```java\n\n123570,1,com.google.zxing.client.activity.MipcaActivityCapture onWindowFocusChanged (Z)V\n...\n\n* 第一个数字表示分配方法的Id，-1表示插桩为activity加入的onWindowFocusChanged方法。其他方法从1开始计数\n* 第二个数字表示方法权限修饰符，常见的值为ACC_PUBLIC = 1; ACC_PRIVATE = 2;ACC_PROTECTED = 4; ACC_STATIC = 8等等。1即表示public方法\n* 第三个参数标识类名 包名+类名；方法名 onWindowFocusChanged；参数及返回值类型Z表示参数为boolean类型，V表示返回值为空\n\n```\n\n### 卡顿\n\n* 原因\n\n主线程执行繁重的UI绘制、大量的计算或IO等耗时操作\n\n* 方案\n\n业内主要框架的主要思想是，监控主线程执行耗时，当超过阈值时，dump出当前主线程的执行堆栈，通过堆栈分析找到卡顿原因。\n\n* 监控原理\n    \n    1. 依赖主线程 Looper，监控每次 dispatchMessage 的执行耗时。（BlockCanary）\n    2. 依赖 Choreographer 模块，监控相邻两次 Vsync 事件通知的时间差。（ArgusAPM、LogMonitor）\n\n* 生成结果\n\n<img src=\"xrk_matrix_fps_result.png\" title=\"帧率检测\"  width=\"30%\" height=\"50%\" />\n\n```java \n* scene 表示场景，使用 Activity + Fragment 类名作为唯一标志\n* dropLevel 是表示掉帧情况-掉帧次数，衡量帧率掉帧的水平\n* dropSum 总共掉帧的帧数\n* fps 表示当前帧率\n\n掉帧计算 final int droppedCount = (int) ((frameNanos - lastFrameNanos) / REFRESH_RATE_MS);\n\n```\n\n* 常见卡顿场景\n\n    * 布局嵌套层次太深，可以使用 merge、viewStub、include 来优化\n    * onDraw() 里面循环创建了大量临时变量，频繁触发 GC\n    * 主线程等待优先级子线程问题（锁同步问题）\n    * 主线程执行耗时操作，阻塞主线程执行（同步读写文件，DB 操作）\n\n## Q&A\n\n* 如何监听app 是否退到后台？\n\n通过 Application.ActivityLifecycleCallbacks 接口向全局 app 注册监听，当有 onActivityStarted(activity) 时，主动标记前台为 true，当 onActivityStopped(activity) 时，先判断当前 activity 堆栈里是否有被 paused 的页面，如果没有，则表示已退到后台。\n\n* FPS 检测时，如何判断当前是在 drawing？\n\n* stack 慢函数堆栈如何分析？\n\n可以参考 [Matrix issue #104 stack 如何分析](https://github.com/Tencent/matrix/issues/104)，或者 [hotfix/0.4.x sample-android](https://github.com/Tencent/matrix/blob/hotfix%2F0.4.x/samples/sample-android/app/src/main/java/sample/tencent/matrix/issue/IssuesListActivity.java)\n\n## 参考\n\nWeChat-Matrix\n\n* [Tencent/matrix](https://github.com/Tencent/matrix)\n* [Matrxi Release Versions](https://github.com/Tencent/matrix/releases)\n* [Matrix for Android 文档](https://github.com/Tencent/matrix#matrix_android_cn)\n* [Matrix Android TraceCanary\n](https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary)\n* [堆栈字段说明](https://github.com/Tencent/matrix/wiki/Matrix-Android--data-format)\n* [慢函数的堆栈如何解读，现在是一堆数字](https://github.com/Tencent/matrix/issues/57)\n* [matrix/home wiki](https://github.com/Tencent/matrix/wiki#%E5%B8%A7%E7%8E%87)\n* [腾讯Bugly/广研Android卡顿监控系统](http://www.10tiao.com/html/330/201801/2653579565/1.html)\n* [Github/QPM-聚美性能检测](https://github.com/ZhuoKeTeam/QPM?from=timeline)\n* [(分析到位！) Matrix源码分析————Trace Canary](https://www.qingtingip.com/h_227199.html)\n\nMatrix Stack\n\n* [Matrix-Issue/stack 如何分析](https://github.com/Tencent/matrix/issues/104)\n* [matrix的耗时方法日志解析-jar 工具](https://github.com/qhy2013/matrix_evil_method_stack_parser)\n* \n\n其它 APM\n\n* [Github/QPM](https://github.com/ZhuoKeTeam/QPM?from=timeline)\n\nChoreographer\n\n* [Android Choreographer 源码分析](https://www.jianshu.com/p/996bca12eb1d)\n\n悬浮窗\n\n* [FloatWindow 悬浮窗](https://github.com/duqian291902259/Android-FloatWindow)\n\n进程优先级\n\n* [Android adb 查看进程优先级](https://blog.csdn.net/QQxiaoqiang1573/article/details/79988752)\n* [/proc/stat解析](http://gityuan.com/2017/08/12/proc_stat/)\n* [花式读取Android CPU使用率](http://www.voidcn.com/article/p-oesjkqaq-bnv.html)\n* [Android 查看进程ID（PID）比较进程优先级](https://blog.csdn.net/Zz110753/article/details/70048811)\n\nAndroid是如何管理内存的？\n\n* [管理应用的内存](http://hukai.me/android-training-course-in-chinese/performance/memory.html)\n* [Android漫游记(1)---内存映射镜像(memory maps)](https://blog.csdn.net/lifeshow/article/details/29174457)\n* [Android性能优化之内存篇](http://hukai.me/android-performance-memory/)\n\nAndroid Davik vs Java JVM？\n\n* [一篇文章告诉你Dalvik 和JVM的区别](https://juejin.im/post/59b7fa8cf265da066d3323bb)\n* [Java JVM 中 堆，栈，方法区 详解](https://blog.csdn.net/zhangqiluGrubby/article/details/59110906)\n\n性能实践\n\n* [Andriod性能优化之列表卡顿——以“简书”APP为例](https://www.jianshu.com/p/336362b23c30)\n* [Activity界面显示全解析](https://blog.csdn.net/zhaokaiqiang1992/article/details/49681321)\n* [Android官方翻译-Android性能优化](http://hukai.me/android-training-course-in-chinese/performance/memory.html)\n* [Android UI性能优化 检测应用中的UI卡顿](https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650822205&idx=1&sn=6b8e78bc1d71eb79a199667cf132acf7&chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&mpshare=1)\n* [Android应用性能优化实践](https://mp.weixin.qq.com/s?__biz=MzA4MzEwOTkyMQ==&mid=405927192&idx=1&sn=71db45156530a20136b88851df3ef3e1&scene=4#wechat_redirect)\n* [性能优化汇总](https://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&mid=203692693&idx=1&sn=ecf0166abdb22d28463d4facd5de473b&scene=23&srcid=0215Ia7vlFqGw2lWtgZbcWBy#rd)\n\nGradle\n\n* [深入理解 Android（一）：Gradle 详解](https://www.infoq.cn/article/android-in-depth-gradle/?utm_source=infoq&utm_campaign=user_page&utm_medium=link)\n\n","slug":"性能优化之Matrix","published":1,"updated":"2020-01-14T03:51:20.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vfh001tn2cbxf18d4k7","content":"<p>本文讲解微信团队开源的 Android 性能优化检测工具-<a href=\"https://github.com/Tencent/matrix\" target=\"_blank\" rel=\"noopener\">Matrix</a> 中 TracePlugin 原理，分析检测慢函数、卡顿的过程 。</p>\n<a id=\"more\"></a>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"Trace-Plugin-代码框架\"><a href=\"#Trace-Plugin-代码框架\" class=\"headerlink\" title=\"Trace Plugin 代码框架\"></a>Trace Plugin 代码框架</h3><p>Trace Canary通过字节码插桩的方式在编译期预埋了方法进入、方法退出的埋点。运行期，慢函数检测、FPS检测、卡顿检测、启动检测使用这些埋点信息排查具体哪个函数导致的异常。</p>\n<h4 id=\"编译期\"><a href=\"#编译期\" class=\"headerlink\" title=\"编译期\"></a>编译期</h4><p>函数埋点思路：</p>\n<p>代理编译期间的任务 transformClassesWithDexTask，将全局 class 文件作为输入，利用 ASM 工具，修改字节码的方式，在编译期修改所有 class 文件中的函数字节码，对所有函数前后进行打点插桩。</p>\n<p><img src=\"matrix_tracecanary_arch.jpg\" title=\"matrix-tracecanary总框架\" width=\"80%\" height=\"50%\"></p>\n<p>（图示1）matrix tracecanary总框架</p>\n<p><img src=\"matrix_compile_flow.jpg\" title=\"matrix-编译期方法代码插装分析\" width=\"80%\" height=\"50%\"></p>\n<p>（图示2）matrix 编译期方法代码插装分析</p>\n<p>代码插桩的整体流程如上图。在打包过程中，hook生成Dex的Task任务，添加方法插桩的逻辑。hook点是在Proguard之后，Class已经被混淆了，所以需要考虑类混淆的问题。</p>\n<p>插桩代码逻辑大致分为三步：</p>\n<ul>\n<li>hook原有的Task，执行自己的MatrixTraceTransform，并在最后执行原逻辑</li>\n<li>在方法插桩之前先要读取ClassMapping文件，获取混淆前方法、混淆后方法的映射关系并存储在MappingCollector中。</li>\n<li>之后遍历所有Dir、Jar中的Class文件，实际代码执行的时候遍历了两次。</li>\n</ul>\n<p>第一次遍历Class，获取所有待插桩的Method信息，并将信息输出到methodMap文件中；<br>第二次遍历Class，利用ASM执行Method插桩逻辑。</p>\n<h4 id=\"运行期\"><a href=\"#运行期\" class=\"headerlink\" title=\"运行期\"></a>运行期</h4><p>基于编译期函数插装的逻辑，在运行期，检测到某个方法异常时，会上报一个 methodId，后端通过下图的 methodId 到 method name 的映射关系，追查到有问题的方法。</p>\n<p><img src=\"matrix_methodmapping.jpg\" alt=\"matrix-methodmapping文件.jpg\"></p>\n<p>（图示3）matrix methodmapping文件</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>FrameTracer</li>\n</ul>\n<p>计算掉帧率，生成 json 报告上报</p>\n<ul>\n<li>UIThreadMonitor </li>\n</ul>\n<p>ui 主线程监控 回调 doFrame(focusedActivityName, long frameCostMs) 每一帧总耗时，供 FrameTracer 来计算掉帧率（frameCostMs/frameIntervalMs 16.6667 + 1），</p>\n<ul>\n<li>Choregrapher.getInstance()</li>\n</ul>\n<p>监控相邻两次 Vsync 事件通知的时间差</p>\n<ul>\n<li>LooperMonitor </li>\n</ul>\n<p>implements MessageQueue.IdleHandler 监控空闲事件</p>\n<h3 id=\"FPS-帧率检测\"><a href=\"#FPS-帧率检测\" class=\"headerlink\" title=\"FPS 帧率检测\"></a>FPS 帧率检测</h3><p>clicfg_matrix_trace_fps_time_slice 表示检测总时长，由IDynamicConfig#getInt() 设置即可</p>\n<h3 id=\"慢函数\"><a href=\"#慢函数\" class=\"headerlink\" title=\"慢函数\"></a>慢函数</h3><ul>\n<li>原理：</li>\n</ul>\n<p>上部分讲述了编译器，会在每个方法的执行前后添加 <code>AppMethodBeat.i(int methodId)</code>和<code>AppMethodBeat.o(int methodId)</code>的方法调用，methodId 是在编译期生成的，在运行期是一个写死的常量。通过编译期的这个操作，就能感知到具体每个方法的进入、退出操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * hook method when it's called in.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> methodId</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">i</span><span class=\"params\">(<span class=\"keyword\">int</span> methodId)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (Thread.currentThread().getId() == sMainThread.getId()) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (assertIn) &#123;</span><br><span class=\"line\">             android.util.Log.e(TAG, <span class=\"string\">\"ERROR!!! AppMethodBeat.i Recursive calls!!!\"</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         assertIn = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (sIndex &lt; Constants.BUFFER_SIZE) &#123;</span><br><span class=\"line\">             mergeData(methodId, sIndex, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             sIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         ++sIndex;</span><br><span class=\"line\">         assertIn = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * hook method when it's called out.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> methodId</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">o</span><span class=\"params\">(<span class=\"keyword\">int</span> methodId)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     ...</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (Thread.currentThread().getId() == sMainThread.getId()) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (sIndex &lt; Constants.BUFFER_SIZE) &#123;</span><br><span class=\"line\">             mergeData(methodId, sIndex, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             sIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         ++sIndex;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>检测过程</li>\n</ul>\n<p>代码统计了当应用处于前台时，在主线程执行方法的进入、退出，这些信息存储在 AppMethodBeat 的 sBuffer「数组 long[100 * 10000]」 中。当主线程有疑似慢函数存在时，读取 Buffer 的数据，分析可能的慢函数，并上报 json 数据到后端，后端将 methodId 转换为具体的方法声明。</p>\n<ul>\n<li>发生场景<ol>\n<li>掉帧场景</li>\n<li>类似 ANR 长时间主线程阻塞 UI 绘制的场景</li>\n</ol>\n</li>\n</ul>\n<p>其中，掉帧场景，内部 FrameBeat 类实现了 Choreographer.FrameCallback，可以感知每一帧的绘制时间，通过前后两帧的时间差判断是否有慢函数发生；</p>\n<p>主线程长时间阻塞 UI 绘制的场景，LazyScheduler 内有一个 HandlerThread，调用 LazyScheduler.setup 方法向 HandlerThread 的 MQ 发送一个延时5s的消息，若没有发生类似 ANR 的场景，在每一帧的 doFrame 回调中取消这个消息，同时发送一个新的延时 5s 的消息（正常情况下消息是得不到执行的），若发生类似 ANR 的情况，doFrame 没有被回调，这个延时 5s 的消息得到执行，将回调到 onTimeExpire 方法。</p>\n<ul>\n<li>生成映射文件</li>\n</ul>\n<p>目前生成函数堆栈映射文件在工程的 <code>app/build/outputs/mapping/debug/methodMapping.txt</code>，如下格式</p>\n<ul>\n<li>分析结果</li>\n</ul>\n<p><img src=\"xrk_matrix_analyse_result.png\" title=\"慢函数示例\" width=\"30%\" height=\"50%\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">123570</span>,<span class=\"number\">1</span>,com.google.zxing.client.activity.<span class=\"function\">MipcaActivityCapture <span class=\"title\">onWindowFocusChanged</span> <span class=\"params\">(Z)</span>V</span></span><br><span class=\"line\"><span class=\"function\">...</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">* 第一个数字表示分配方法的Id，-1表示插桩为activity加入的onWindowFocusChanged方法。其他方法从1开始计数</span></span><br><span class=\"line\"><span class=\"function\">* 第二个数字表示方法权限修饰符，常见的值为ACC_PUBLIC </span>= <span class=\"number\">1</span>; ACC_PRIVATE = <span class=\"number\">2</span>;ACC_PROTECTED = <span class=\"number\">4</span>; ACC_STATIC = <span class=\"number\">8</span>等等。<span class=\"number\">1</span>即表示<span class=\"keyword\">public</span>方法</span><br><span class=\"line\">* 第三个参数标识类名 包名+类名；方法名 onWindowFocusChanged；参数及返回值类型Z表示参数为<span class=\"keyword\">boolean</span>类型，V表示返回值为空</span><br></pre></td></tr></table></figure>\n<h3 id=\"卡顿\"><a href=\"#卡顿\" class=\"headerlink\" title=\"卡顿\"></a>卡顿</h3><ul>\n<li>原因</li>\n</ul>\n<p>主线程执行繁重的UI绘制、大量的计算或IO等耗时操作</p>\n<ul>\n<li>方案</li>\n</ul>\n<p>业内主要框架的主要思想是，监控主线程执行耗时，当超过阈值时，dump出当前主线程的执行堆栈，通过堆栈分析找到卡顿原因。</p>\n<ul>\n<li><p>监控原理</p>\n<ol>\n<li>依赖主线程 Looper，监控每次 dispatchMessage 的执行耗时。（BlockCanary）</li>\n<li>依赖 Choreographer 模块，监控相邻两次 Vsync 事件通知的时间差。（ArgusAPM、LogMonitor）</li>\n</ol>\n</li>\n<li><p>生成结果</p>\n</li>\n</ul>\n<p><img src=\"xrk_matrix_fps_result.png\" title=\"帧率检测\" width=\"30%\" height=\"50%\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* scene 表示场景，使用 Activity + Fragment 类名作为唯一标志</span><br><span class=\"line\">* dropLevel 是表示掉帧情况-掉帧次数，衡量帧率掉帧的水平</span><br><span class=\"line\">* dropSum 总共掉帧的帧数</span><br><span class=\"line\">* fps 表示当前帧率</span><br><span class=\"line\"></span><br><span class=\"line\">掉帧计算 <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> droppedCount = (<span class=\"keyword\">int</span>) ((frameNanos - lastFrameNanos) / REFRESH_RATE_MS);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>常见卡顿场景</p>\n<ul>\n<li>布局嵌套层次太深，可以使用 merge、viewStub、include 来优化</li>\n<li>onDraw() 里面循环创建了大量临时变量，频繁触发 GC</li>\n<li>主线程等待优先级子线程问题（锁同步问题）</li>\n<li>主线程执行耗时操作，阻塞主线程执行（同步读写文件，DB 操作）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ul>\n<li>如何监听app 是否退到后台？</li>\n</ul>\n<p>通过 Application.ActivityLifecycleCallbacks 接口向全局 app 注册监听，当有 onActivityStarted(activity) 时，主动标记前台为 true，当 onActivityStopped(activity) 时，先判断当前 activity 堆栈里是否有被 paused 的页面，如果没有，则表示已退到后台。</p>\n<ul>\n<li><p>FPS 检测时，如何判断当前是在 drawing？</p>\n</li>\n<li><p>stack 慢函数堆栈如何分析？</p>\n</li>\n</ul>\n<p>可以参考 <a href=\"https://github.com/Tencent/matrix/issues/104\" target=\"_blank\" rel=\"noopener\">Matrix issue #104 stack 如何分析</a>，或者 <a href=\"https://github.com/Tencent/matrix/blob/hotfix%2F0.4.x/samples/sample-android/app/src/main/java/sample/tencent/matrix/issue/IssuesListActivity.java\" target=\"_blank\" rel=\"noopener\">hotfix/0.4.x sample-android</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>WeChat-Matrix</p>\n<ul>\n<li><a href=\"https://github.com/Tencent/matrix\" target=\"_blank\" rel=\"noopener\">Tencent/matrix</a></li>\n<li><a href=\"https://github.com/Tencent/matrix/releases\" target=\"_blank\" rel=\"noopener\">Matrxi Release Versions</a></li>\n<li><a href=\"https://github.com/Tencent/matrix#matrix_android_cn\" target=\"_blank\" rel=\"noopener\">Matrix for Android 文档</a></li>\n<li><a href=\"https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary\" target=\"_blank\" rel=\"noopener\">Matrix Android TraceCanary\n</a></li>\n<li><a href=\"https://github.com/Tencent/matrix/wiki/Matrix-Android--data-format\" target=\"_blank\" rel=\"noopener\">堆栈字段说明</a></li>\n<li><a href=\"https://github.com/Tencent/matrix/issues/57\" target=\"_blank\" rel=\"noopener\">慢函数的堆栈如何解读，现在是一堆数字</a></li>\n<li><a href=\"https://github.com/Tencent/matrix/wiki#%E5%B8%A7%E7%8E%87\" target=\"_blank\" rel=\"noopener\">matrix/home wiki</a></li>\n<li><a href=\"http://www.10tiao.com/html/330/201801/2653579565/1.html\" target=\"_blank\" rel=\"noopener\">腾讯Bugly/广研Android卡顿监控系统</a></li>\n<li><a href=\"https://github.com/ZhuoKeTeam/QPM?from=timeline\" target=\"_blank\" rel=\"noopener\">Github/QPM-聚美性能检测</a></li>\n<li><a href=\"https://www.qingtingip.com/h_227199.html\" target=\"_blank\" rel=\"noopener\">(分析到位！) Matrix源码分析————Trace Canary</a></li>\n</ul>\n<p>Matrix Stack</p>\n<ul>\n<li><a href=\"https://github.com/Tencent/matrix/issues/104\" target=\"_blank\" rel=\"noopener\">Matrix-Issue/stack 如何分析</a></li>\n<li><a href=\"https://github.com/qhy2013/matrix_evil_method_stack_parser\" target=\"_blank\" rel=\"noopener\">matrix的耗时方法日志解析-jar 工具</a></li>\n<li></li>\n</ul>\n<p>其它 APM</p>\n<ul>\n<li><a href=\"https://github.com/ZhuoKeTeam/QPM?from=timeline\" target=\"_blank\" rel=\"noopener\">Github/QPM</a></li>\n</ul>\n<p>Choreographer</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/996bca12eb1d\" target=\"_blank\" rel=\"noopener\">Android Choreographer 源码分析</a></li>\n</ul>\n<p>悬浮窗</p>\n<ul>\n<li><a href=\"https://github.com/duqian291902259/Android-FloatWindow\" target=\"_blank\" rel=\"noopener\">FloatWindow 悬浮窗</a></li>\n</ul>\n<p>进程优先级</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/QQxiaoqiang1573/article/details/79988752\" target=\"_blank\" rel=\"noopener\">Android adb 查看进程优先级</a></li>\n<li><a href=\"http://gityuan.com/2017/08/12/proc_stat/\" target=\"_blank\" rel=\"noopener\">/proc/stat解析</a></li>\n<li><a href=\"http://www.voidcn.com/article/p-oesjkqaq-bnv.html\" target=\"_blank\" rel=\"noopener\">花式读取Android CPU使用率</a></li>\n<li><a href=\"https://blog.csdn.net/Zz110753/article/details/70048811\" target=\"_blank\" rel=\"noopener\">Android 查看进程ID（PID）比较进程优先级</a></li>\n</ul>\n<p>Android是如何管理内存的？</p>\n<ul>\n<li><a href=\"http://hukai.me/android-training-course-in-chinese/performance/memory.html\" target=\"_blank\" rel=\"noopener\">管理应用的内存</a></li>\n<li><a href=\"https://blog.csdn.net/lifeshow/article/details/29174457\" target=\"_blank\" rel=\"noopener\">Android漫游记(1)—内存映射镜像(memory maps)</a></li>\n<li><a href=\"http://hukai.me/android-performance-memory/\" target=\"_blank\" rel=\"noopener\">Android性能优化之内存篇</a></li>\n</ul>\n<p>Android Davik vs Java JVM？</p>\n<ul>\n<li><a href=\"https://juejin.im/post/59b7fa8cf265da066d3323bb\" target=\"_blank\" rel=\"noopener\">一篇文章告诉你Dalvik 和JVM的区别</a></li>\n<li><a href=\"https://blog.csdn.net/zhangqiluGrubby/article/details/59110906\" target=\"_blank\" rel=\"noopener\">Java JVM 中 堆，栈，方法区 详解</a></li>\n</ul>\n<p>性能实践</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/336362b23c30\" target=\"_blank\" rel=\"noopener\">Andriod性能优化之列表卡顿——以“简书”APP为例</a></li>\n<li><a href=\"https://blog.csdn.net/zhaokaiqiang1992/article/details/49681321\" target=\"_blank\" rel=\"noopener\">Activity界面显示全解析</a></li>\n<li><a href=\"http://hukai.me/android-training-course-in-chinese/performance/memory.html\" target=\"_blank\" rel=\"noopener\">Android官方翻译-Android性能优化</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822205&amp;idx=1&amp;sn=6b8e78bc1d71eb79a199667cf132acf7&amp;chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&amp;mpshare=1\" target=\"_blank\" rel=\"noopener\">Android UI性能优化 检测应用中的UI卡顿</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzA4MzEwOTkyMQ==&amp;mid=405927192&amp;idx=1&amp;sn=71db45156530a20136b88851df3ef3e1&amp;scene=4#wechat_redirect\" target=\"_blank\" rel=\"noopener\">Android应用性能优化实践</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=203692693&amp;idx=1&amp;sn=ecf0166abdb22d28463d4facd5de473b&amp;scene=23&amp;srcid=0215Ia7vlFqGw2lWtgZbcWBy#rd\" target=\"_blank\" rel=\"noopener\">性能优化汇总</a></li>\n</ul>\n<p>Gradle</p>\n<ul>\n<li><a href=\"https://www.infoq.cn/article/android-in-depth-gradle/?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link\" target=\"_blank\" rel=\"noopener\">深入理解 Android（一）：Gradle 详解</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文讲解微信团队开源的 Android 性能优化检测工具-<a href=\"https://github.com/Tencent/matrix\" target=\"_blank\" rel=\"noopener\">Matrix</a> 中 TracePlugin 原理，分析检测慢函数、卡顿的过程 。</p>","more":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"Trace-Plugin-代码框架\"><a href=\"#Trace-Plugin-代码框架\" class=\"headerlink\" title=\"Trace Plugin 代码框架\"></a>Trace Plugin 代码框架</h3><p>Trace Canary通过字节码插桩的方式在编译期预埋了方法进入、方法退出的埋点。运行期，慢函数检测、FPS检测、卡顿检测、启动检测使用这些埋点信息排查具体哪个函数导致的异常。</p>\n<h4 id=\"编译期\"><a href=\"#编译期\" class=\"headerlink\" title=\"编译期\"></a>编译期</h4><p>函数埋点思路：</p>\n<p>代理编译期间的任务 transformClassesWithDexTask，将全局 class 文件作为输入，利用 ASM 工具，修改字节码的方式，在编译期修改所有 class 文件中的函数字节码，对所有函数前后进行打点插桩。</p>\n<p><img src=\"matrix_tracecanary_arch.jpg\" title=\"matrix-tracecanary总框架\" width=\"80%\" height=\"50%\"></p>\n<p>（图示1）matrix tracecanary总框架</p>\n<p><img src=\"matrix_compile_flow.jpg\" title=\"matrix-编译期方法代码插装分析\" width=\"80%\" height=\"50%\"></p>\n<p>（图示2）matrix 编译期方法代码插装分析</p>\n<p>代码插桩的整体流程如上图。在打包过程中，hook生成Dex的Task任务，添加方法插桩的逻辑。hook点是在Proguard之后，Class已经被混淆了，所以需要考虑类混淆的问题。</p>\n<p>插桩代码逻辑大致分为三步：</p>\n<ul>\n<li>hook原有的Task，执行自己的MatrixTraceTransform，并在最后执行原逻辑</li>\n<li>在方法插桩之前先要读取ClassMapping文件，获取混淆前方法、混淆后方法的映射关系并存储在MappingCollector中。</li>\n<li>之后遍历所有Dir、Jar中的Class文件，实际代码执行的时候遍历了两次。</li>\n</ul>\n<p>第一次遍历Class，获取所有待插桩的Method信息，并将信息输出到methodMap文件中；<br>第二次遍历Class，利用ASM执行Method插桩逻辑。</p>\n<h4 id=\"运行期\"><a href=\"#运行期\" class=\"headerlink\" title=\"运行期\"></a>运行期</h4><p>基于编译期函数插装的逻辑，在运行期，检测到某个方法异常时，会上报一个 methodId，后端通过下图的 methodId 到 method name 的映射关系，追查到有问题的方法。</p>\n<p><img src=\"matrix_methodmapping.jpg\" alt=\"matrix-methodmapping文件.jpg\"></p>\n<p>（图示3）matrix methodmapping文件</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ul>\n<li>FrameTracer</li>\n</ul>\n<p>计算掉帧率，生成 json 报告上报</p>\n<ul>\n<li>UIThreadMonitor </li>\n</ul>\n<p>ui 主线程监控 回调 doFrame(focusedActivityName, long frameCostMs) 每一帧总耗时，供 FrameTracer 来计算掉帧率（frameCostMs/frameIntervalMs 16.6667 + 1），</p>\n<ul>\n<li>Choregrapher.getInstance()</li>\n</ul>\n<p>监控相邻两次 Vsync 事件通知的时间差</p>\n<ul>\n<li>LooperMonitor </li>\n</ul>\n<p>implements MessageQueue.IdleHandler 监控空闲事件</p>\n<h3 id=\"FPS-帧率检测\"><a href=\"#FPS-帧率检测\" class=\"headerlink\" title=\"FPS 帧率检测\"></a>FPS 帧率检测</h3><p>clicfg_matrix_trace_fps_time_slice 表示检测总时长，由IDynamicConfig#getInt() 设置即可</p>\n<h3 id=\"慢函数\"><a href=\"#慢函数\" class=\"headerlink\" title=\"慢函数\"></a>慢函数</h3><ul>\n<li>原理：</li>\n</ul>\n<p>上部分讲述了编译器，会在每个方法的执行前后添加 <code>AppMethodBeat.i(int methodId)</code>和<code>AppMethodBeat.o(int methodId)</code>的方法调用，methodId 是在编译期生成的，在运行期是一个写死的常量。通过编译期的这个操作，就能感知到具体每个方法的进入、退出操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * hook method when it's called in.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> methodId</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">i</span><span class=\"params\">(<span class=\"keyword\">int</span> methodId)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (Thread.currentThread().getId() == sMainThread.getId()) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (assertIn) &#123;</span><br><span class=\"line\">             android.util.Log.e(TAG, <span class=\"string\">\"ERROR!!! AppMethodBeat.i Recursive calls!!!\"</span>);</span><br><span class=\"line\">             <span class=\"keyword\">return</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         assertIn = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (sIndex &lt; Constants.BUFFER_SIZE) &#123;</span><br><span class=\"line\">             mergeData(methodId, sIndex, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             sIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         ++sIndex;</span><br><span class=\"line\">         assertIn = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * hook method when it's called out.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> methodId</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">o</span><span class=\"params\">(<span class=\"keyword\">int</span> methodId)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     ...</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (Thread.currentThread().getId() == sMainThread.getId()) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (sIndex &lt; Constants.BUFFER_SIZE) &#123;</span><br><span class=\"line\">             mergeData(methodId, sIndex, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             sIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         ++sIndex;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>检测过程</li>\n</ul>\n<p>代码统计了当应用处于前台时，在主线程执行方法的进入、退出，这些信息存储在 AppMethodBeat 的 sBuffer「数组 long[100 * 10000]」 中。当主线程有疑似慢函数存在时，读取 Buffer 的数据，分析可能的慢函数，并上报 json 数据到后端，后端将 methodId 转换为具体的方法声明。</p>\n<ul>\n<li>发生场景<ol>\n<li>掉帧场景</li>\n<li>类似 ANR 长时间主线程阻塞 UI 绘制的场景</li>\n</ol>\n</li>\n</ul>\n<p>其中，掉帧场景，内部 FrameBeat 类实现了 Choreographer.FrameCallback，可以感知每一帧的绘制时间，通过前后两帧的时间差判断是否有慢函数发生；</p>\n<p>主线程长时间阻塞 UI 绘制的场景，LazyScheduler 内有一个 HandlerThread，调用 LazyScheduler.setup 方法向 HandlerThread 的 MQ 发送一个延时5s的消息，若没有发生类似 ANR 的场景，在每一帧的 doFrame 回调中取消这个消息，同时发送一个新的延时 5s 的消息（正常情况下消息是得不到执行的），若发生类似 ANR 的情况，doFrame 没有被回调，这个延时 5s 的消息得到执行，将回调到 onTimeExpire 方法。</p>\n<ul>\n<li>生成映射文件</li>\n</ul>\n<p>目前生成函数堆栈映射文件在工程的 <code>app/build/outputs/mapping/debug/methodMapping.txt</code>，如下格式</p>\n<ul>\n<li>分析结果</li>\n</ul>\n<p><img src=\"xrk_matrix_analyse_result.png\" title=\"慢函数示例\" width=\"30%\" height=\"50%\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">123570</span>,<span class=\"number\">1</span>,com.google.zxing.client.activity.<span class=\"function\">MipcaActivityCapture <span class=\"title\">onWindowFocusChanged</span> <span class=\"params\">(Z)</span>V</span></span><br><span class=\"line\"><span class=\"function\">...</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">* 第一个数字表示分配方法的Id，-1表示插桩为activity加入的onWindowFocusChanged方法。其他方法从1开始计数</span></span><br><span class=\"line\"><span class=\"function\">* 第二个数字表示方法权限修饰符，常见的值为ACC_PUBLIC </span>= <span class=\"number\">1</span>; ACC_PRIVATE = <span class=\"number\">2</span>;ACC_PROTECTED = <span class=\"number\">4</span>; ACC_STATIC = <span class=\"number\">8</span>等等。<span class=\"number\">1</span>即表示<span class=\"keyword\">public</span>方法</span><br><span class=\"line\">* 第三个参数标识类名 包名+类名；方法名 onWindowFocusChanged；参数及返回值类型Z表示参数为<span class=\"keyword\">boolean</span>类型，V表示返回值为空</span><br></pre></td></tr></table></figure>\n<h3 id=\"卡顿\"><a href=\"#卡顿\" class=\"headerlink\" title=\"卡顿\"></a>卡顿</h3><ul>\n<li>原因</li>\n</ul>\n<p>主线程执行繁重的UI绘制、大量的计算或IO等耗时操作</p>\n<ul>\n<li>方案</li>\n</ul>\n<p>业内主要框架的主要思想是，监控主线程执行耗时，当超过阈值时，dump出当前主线程的执行堆栈，通过堆栈分析找到卡顿原因。</p>\n<ul>\n<li><p>监控原理</p>\n<ol>\n<li>依赖主线程 Looper，监控每次 dispatchMessage 的执行耗时。（BlockCanary）</li>\n<li>依赖 Choreographer 模块，监控相邻两次 Vsync 事件通知的时间差。（ArgusAPM、LogMonitor）</li>\n</ol>\n</li>\n<li><p>生成结果</p>\n</li>\n</ul>\n<p><img src=\"xrk_matrix_fps_result.png\" title=\"帧率检测\" width=\"30%\" height=\"50%\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* scene 表示场景，使用 Activity + Fragment 类名作为唯一标志</span><br><span class=\"line\">* dropLevel 是表示掉帧情况-掉帧次数，衡量帧率掉帧的水平</span><br><span class=\"line\">* dropSum 总共掉帧的帧数</span><br><span class=\"line\">* fps 表示当前帧率</span><br><span class=\"line\"></span><br><span class=\"line\">掉帧计算 <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> droppedCount = (<span class=\"keyword\">int</span>) ((frameNanos - lastFrameNanos) / REFRESH_RATE_MS);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>常见卡顿场景</p>\n<ul>\n<li>布局嵌套层次太深，可以使用 merge、viewStub、include 来优化</li>\n<li>onDraw() 里面循环创建了大量临时变量，频繁触发 GC</li>\n<li>主线程等待优先级子线程问题（锁同步问题）</li>\n<li>主线程执行耗时操作，阻塞主线程执行（同步读写文件，DB 操作）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ul>\n<li>如何监听app 是否退到后台？</li>\n</ul>\n<p>通过 Application.ActivityLifecycleCallbacks 接口向全局 app 注册监听，当有 onActivityStarted(activity) 时，主动标记前台为 true，当 onActivityStopped(activity) 时，先判断当前 activity 堆栈里是否有被 paused 的页面，如果没有，则表示已退到后台。</p>\n<ul>\n<li><p>FPS 检测时，如何判断当前是在 drawing？</p>\n</li>\n<li><p>stack 慢函数堆栈如何分析？</p>\n</li>\n</ul>\n<p>可以参考 <a href=\"https://github.com/Tencent/matrix/issues/104\" target=\"_blank\" rel=\"noopener\">Matrix issue #104 stack 如何分析</a>，或者 <a href=\"https://github.com/Tencent/matrix/blob/hotfix%2F0.4.x/samples/sample-android/app/src/main/java/sample/tencent/matrix/issue/IssuesListActivity.java\" target=\"_blank\" rel=\"noopener\">hotfix/0.4.x sample-android</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>WeChat-Matrix</p>\n<ul>\n<li><a href=\"https://github.com/Tencent/matrix\" target=\"_blank\" rel=\"noopener\">Tencent/matrix</a></li>\n<li><a href=\"https://github.com/Tencent/matrix/releases\" target=\"_blank\" rel=\"noopener\">Matrxi Release Versions</a></li>\n<li><a href=\"https://github.com/Tencent/matrix#matrix_android_cn\" target=\"_blank\" rel=\"noopener\">Matrix for Android 文档</a></li>\n<li><a href=\"https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary\" target=\"_blank\" rel=\"noopener\">Matrix Android TraceCanary\n</a></li>\n<li><a href=\"https://github.com/Tencent/matrix/wiki/Matrix-Android--data-format\" target=\"_blank\" rel=\"noopener\">堆栈字段说明</a></li>\n<li><a href=\"https://github.com/Tencent/matrix/issues/57\" target=\"_blank\" rel=\"noopener\">慢函数的堆栈如何解读，现在是一堆数字</a></li>\n<li><a href=\"https://github.com/Tencent/matrix/wiki#%E5%B8%A7%E7%8E%87\" target=\"_blank\" rel=\"noopener\">matrix/home wiki</a></li>\n<li><a href=\"http://www.10tiao.com/html/330/201801/2653579565/1.html\" target=\"_blank\" rel=\"noopener\">腾讯Bugly/广研Android卡顿监控系统</a></li>\n<li><a href=\"https://github.com/ZhuoKeTeam/QPM?from=timeline\" target=\"_blank\" rel=\"noopener\">Github/QPM-聚美性能检测</a></li>\n<li><a href=\"https://www.qingtingip.com/h_227199.html\" target=\"_blank\" rel=\"noopener\">(分析到位！) Matrix源码分析————Trace Canary</a></li>\n</ul>\n<p>Matrix Stack</p>\n<ul>\n<li><a href=\"https://github.com/Tencent/matrix/issues/104\" target=\"_blank\" rel=\"noopener\">Matrix-Issue/stack 如何分析</a></li>\n<li><a href=\"https://github.com/qhy2013/matrix_evil_method_stack_parser\" target=\"_blank\" rel=\"noopener\">matrix的耗时方法日志解析-jar 工具</a></li>\n<li></li>\n</ul>\n<p>其它 APM</p>\n<ul>\n<li><a href=\"https://github.com/ZhuoKeTeam/QPM?from=timeline\" target=\"_blank\" rel=\"noopener\">Github/QPM</a></li>\n</ul>\n<p>Choreographer</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/996bca12eb1d\" target=\"_blank\" rel=\"noopener\">Android Choreographer 源码分析</a></li>\n</ul>\n<p>悬浮窗</p>\n<ul>\n<li><a href=\"https://github.com/duqian291902259/Android-FloatWindow\" target=\"_blank\" rel=\"noopener\">FloatWindow 悬浮窗</a></li>\n</ul>\n<p>进程优先级</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/QQxiaoqiang1573/article/details/79988752\" target=\"_blank\" rel=\"noopener\">Android adb 查看进程优先级</a></li>\n<li><a href=\"http://gityuan.com/2017/08/12/proc_stat/\" target=\"_blank\" rel=\"noopener\">/proc/stat解析</a></li>\n<li><a href=\"http://www.voidcn.com/article/p-oesjkqaq-bnv.html\" target=\"_blank\" rel=\"noopener\">花式读取Android CPU使用率</a></li>\n<li><a href=\"https://blog.csdn.net/Zz110753/article/details/70048811\" target=\"_blank\" rel=\"noopener\">Android 查看进程ID（PID）比较进程优先级</a></li>\n</ul>\n<p>Android是如何管理内存的？</p>\n<ul>\n<li><a href=\"http://hukai.me/android-training-course-in-chinese/performance/memory.html\" target=\"_blank\" rel=\"noopener\">管理应用的内存</a></li>\n<li><a href=\"https://blog.csdn.net/lifeshow/article/details/29174457\" target=\"_blank\" rel=\"noopener\">Android漫游记(1)—内存映射镜像(memory maps)</a></li>\n<li><a href=\"http://hukai.me/android-performance-memory/\" target=\"_blank\" rel=\"noopener\">Android性能优化之内存篇</a></li>\n</ul>\n<p>Android Davik vs Java JVM？</p>\n<ul>\n<li><a href=\"https://juejin.im/post/59b7fa8cf265da066d3323bb\" target=\"_blank\" rel=\"noopener\">一篇文章告诉你Dalvik 和JVM的区别</a></li>\n<li><a href=\"https://blog.csdn.net/zhangqiluGrubby/article/details/59110906\" target=\"_blank\" rel=\"noopener\">Java JVM 中 堆，栈，方法区 详解</a></li>\n</ul>\n<p>性能实践</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/336362b23c30\" target=\"_blank\" rel=\"noopener\">Andriod性能优化之列表卡顿——以“简书”APP为例</a></li>\n<li><a href=\"https://blog.csdn.net/zhaokaiqiang1992/article/details/49681321\" target=\"_blank\" rel=\"noopener\">Activity界面显示全解析</a></li>\n<li><a href=\"http://hukai.me/android-training-course-in-chinese/performance/memory.html\" target=\"_blank\" rel=\"noopener\">Android官方翻译-Android性能优化</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822205&amp;idx=1&amp;sn=6b8e78bc1d71eb79a199667cf132acf7&amp;chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&amp;mpshare=1\" target=\"_blank\" rel=\"noopener\">Android UI性能优化 检测应用中的UI卡顿</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzA4MzEwOTkyMQ==&amp;mid=405927192&amp;idx=1&amp;sn=71db45156530a20136b88851df3ef3e1&amp;scene=4#wechat_redirect\" target=\"_blank\" rel=\"noopener\">Android应用性能优化实践</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=203692693&amp;idx=1&amp;sn=ecf0166abdb22d28463d4facd5de473b&amp;scene=23&amp;srcid=0215Ia7vlFqGw2lWtgZbcWBy#rd\" target=\"_blank\" rel=\"noopener\">性能优化汇总</a></li>\n</ul>\n<p>Gradle</p>\n<ul>\n<li><a href=\"https://www.infoq.cn/article/android-in-depth-gradle/?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link\" target=\"_blank\" rel=\"noopener\">深入理解 Android（一）：Gradle 详解</a></li>\n</ul>"},{"title":"性能优化之卡顿优化","date":"2019-09-19T03:05:13.000Z","_content":"\n对用户来说，内存占用高、耗费电量、耗费流量可能不容易被发现，但是对于卡顿特别敏感，尤其在某些时候出现高频掉帧，俗称冻帧。对于开发者来说，卡顿问题非常难以排查定位，其产生的原因错综复杂，跟用户当前手机的 CPU、内存、磁盘 I/O 等环境都可能有关系。所以，到底如何该定义卡顿？在我们平时开发又有哪些工具可以帮助开发更好的发现和排查问题？在线上又该监控卡顿情况呢？下面我们来一一解决这些困惑。\n\n<!-- more -->\n\n## 一、基础知识\n\n### 1.1 CPU 时间\n\n造成卡顿的原因可能有千百种，不过最终都会反映到 CPU 时间上，我们可以把 CPU 时间分为两种：用户时间和系统时间。用户时间就是执行用户态应用程序代码所消耗的时间；系统时间是执行内核态系统调用所消耗的时间，包括 I/O、锁、中断以及其他系统调用的时间。\n\n评价一个 CPU 的性能，需要看主频、核心数、缓存等参数。\n\n获取设备的 CPU 信息\n\n```shell\n// 获取 CPU 核心数\ncat /sys/devices/system/cpu/possible\n\n// 获取某个 CPU 的频率\ncat /sys/devices/system/cpu/cpu0/cpufeq/cpuinfo_max_freq\n```\n\n<img src=\"pc_cpu_info.jpg\" title=\"CPU信息\"  width=\"60%\" height=\"50%\" />\n\n当出现卡顿问题的时候，怎么去区分究竟是我们代码的问题，还是系统的问题？用户时间和系统时间可以给我们哪些线索？这里需要两个非常重要的指标帮助我们做判断。\n\n* CPU 的使用率\n\n可以通过 /proc/stat 得到整个系统的 CPU 使用情况，通过 /proc/[pid]/stat 可以得到某个进程的 CPU 使用情况。\n\n<img src=\"pc_cpu_usage.jpg\" title=\"CPU 使用率\"  width=\"60%\" height=\"50%\" />\n\n<img src=\"xrk_process_cpu.jpg\" title=\"向日葵进程CPU使用率\"  width=\"60%\" height=\"50%\" />\n\n参考链接：\n* [《Linux 环境下进程的CPU 占有率》](http://www.samirchen.com/linux-cpu-performance/)\n* [Linux 文档](http://man7.org/linux/man-pages/man5/proc.5.html)\n\n```shell\n命令 \n    \n* top 命令\n帮助查看哪个进程是 CPU 的消耗大户\n    \n* vmstat 命令\n可以实时监控操作系统的虚拟内存和 CPU 活动；\n    \n* strace 命令\n    \n可以跟踪某个进程中所有的系统调用\n```\n\n* CPU 饱和度\n\nCPU 饱和度反映的是线程排队等待 CPU 的情况，也就是 CPU 的负载情况。CPU 饱和度会跟应用的线程数有关，如果启动线程过多，容易导致系统不断地切换执行的线程，把大量的时间浪费在上下文切换，每次 CPU 上下文切换都需要刷新寄存器和计数器，至少需要十几纳秒的时间。\n\n```shell\n命令\n    \n* vmstat 命令或者 /proc/[pid]/schedstat 文件\n\n查看 CPU 上下文切换次数，需要特别注意 nr_involuntary_switches 被动切换的次数。\n    \n// TODO\n    \n* uptime 命令\n查看 CPU 在1分钟、5分钟和15分钟内的平均负载，例如一个4核的 CPU，如果当前平均负载是 8，这意味着每个 CPU 上有一个线程在运行，还有一个线程在等待。一般平均负载建议控制在 0.7 x 核数 以内。\n    \n// TODO\n```\n线程优先级-nice 值越低，抢占 CPU 时间片的能力越强。\n\n### 1.2 绘制原理\n\n#### 1.2.1 UI 渲染背景知识\n\n#####  屏幕适配\n\npx、ppi、dpi、dp、density\n\n<img src=\"screen_adaptation_table.png\" title=\"屏幕适配概念图\"  width=\"60%\" height=\"50%\" />\n\n参考链接：\n\n* [一种极低成本的 Android 屏幕适配方式-今日头条适配方案](https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA)\n* [Android 目前稳定高效的 UI 适配方案-smallestWidth 限定符适配方案](https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650826381&idx=1&sn=5b71b7f1654b04a55fca25b0e90a4433&chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&scene=21#wechat_redirect)\n\n#####  CPU 与 GPU\n\nUI 渲染依赖两个核心的硬件：CPU 与 GPU。UI 组件在绘制到屏幕之前，都需要经过 Rasterization（格栅化）操作，而格栅化操作是一个耗时操作。GPU(Graphic processing Unit)也就是图形处理器，它主要用于处理图形运算，可能帮助我们加快格栅化操作。\n\n软件绘制使用的是 Skia 库，它是一款能在低端机上呈现高质量的 2D 跨平台框架，类似 Chrome、Flutter 内部使用的都是 Skia 库。\n\n<img src=\"cpu_and_gpu.png\" title=\"CPU&GPU\"  width=\"60%\" height=\"50%\" />\n\n##### OpenGL 与 Vulkan \n\n对于硬件绘制，通过调用 OpenGL ES 接口利用 GPU 完成绘制。[OpenGL](https://developer.android.com/guide/topics/graphics/opengl) 是一个跨平台的图形 API，它为 2D/3D 图形处理硬件指定了标准软件接口，而 OpenGL ES 是 OpenGL 的子集，专为嵌入式设备设计。\n\nAndroid 7.0 把 [OpenGL ES](https://www.khronos.org/opengles/) 升级到最新的 3.2 版本同时，还添加了对 [Vulkan](https://developer.android.com/guide/topics/graphics/opengl)的支持，Vulkan 是用于高性能 3D 图形的低开销、跨平台 API。相比 OpenGL ES，Vulkan 在改善功耗、多核优化提升绘图调用上有着非常明显的优势。\n\n参考资料：\n\n* [官方硬件加速文档](https://developer.android.com/guide/topics/graphics/hardware-accel)\n\n#### 1.2.2 Android 渲染的演进\n\n##### Android 图形系统整体架构\n\n<img src=\"android_graphic_system_arch.png\" title=\"Android图形系统整体架构\"  width=\"60%\" height=\"50%\" />\n\n* 画笔：Skia 或者 OpenGL\n* 画纸：Surface\n* 画板：Graphic Buffer\n* 显示：SurfaceFlinger\n\n参考资料：\n\n* [Android图形系统整体架构](https://source.android.com/devices/graphics)\n\n##### 硬件加速绘制\n\n###### Android 3.0 软件绘制\n\n在 Android 3.0 之前，或者没有启动硬件加速时，系统都会使用软件方式来渲染 UI。\n\n整个流程如上图所示： \n\n* Surface。每个 View 都由某一个窗口管理，而每一个窗口都关联有一个 Surface。\n* Canvas。通过 Surface 的 lock 函数获得一个 Canvas，Canvas 可以简单理解为 Skia 底层接口的封装。\n* Graphic Buffer。SurfaceFlinger 会帮我们托管一个 BufferQueue，我们从 BufferQueue 中拿到 Graphic Buffer，然后通过 Canvas 以及 Skia 将绘制内容栅格化到上面。\n* SurfaceFlinger。通过 Swap Buffer 把 Front Graphic Buffer 的内容交给 SurfaceFinger，最后硬件合成器 Hardware Composer 合成并输出到显示屏。\n\n###### Android 4.0 开启硬件加速\n\n* 从 Androd 3.0 开始，Android 开始支持硬件加速，到 Android 4.0 时，，默认开启硬件加速。\n\n<img src=\"soft_draw_android3.0.png\" title=\"Android3.0软件绘制\"  width=\"60%\" height=\"50%\" />\n\n<img src=\"soft_draw_android4.0.png\" title=\"Android4.0+硬件加速\"  width=\"60%\" height=\"50%\" />\n\n硬件加速核心是通过 GPU 完成 Graphic Buffer 的内容绘制，此外硬件绘制还引入了一个 DisplayList 的概念，每个 View 内部都有一个 DisplayView，当某个 View 需要重绘时，将它标记为 Dirty，不需要像软件绘制向上递归，这样可以大大减少绘图的操作数量，提升渲染效率。\n\n<img src=\"view_displaylist.png\" title=\"View的DisplayList局部刷新\"  width=\"60%\" height=\"50%\" />\n\n##### Project Butter 黄油计划\n\nAndroid 4.1：Project Butter 主要包含两个组成部分，一个是 VSYNC，一个是 Triple Buffering。\n\nVSYNC 信号\n\n<img src=\"vsync_signal.png\" title=\"VSYNC信号\"  width=\"60%\" height=\"50%\" />\n\n三级缓冲机制 Triple Buffering\n\n<img src=\"triple_buffering.png\" title=\"三级缓冲机制 Triple Buffering\"  width=\"60%\" height=\"50%\" />\n\nJank渲染超时\n\n<img src=\"display_jank.png\" title=\"Jank渲染超时\"  width=\"60%\" height=\"50%\" />\n\n##### Android 5.0: RenderThread 异步渲染\n\n<img src=\"display_renderthread.png\" title=\"RenderThread工作\"  width=\"60%\" height=\"50%\" />\n\n##### 数据测量\n\n* 绘制过度工具\n\n在 Android 4.2，系统增加了检测绘制过度工具。\n\n<img src=\"overdraw_tools.png\" title=\"检测绘制过度工具\"  width=\"50%\" height=\"50%\" />\n\n参考资料：[检查 GPU 渲染进度和绘制过度](https://developer.android.com/studio/profile/inspect-gpu-rendering)\n\n##### 未来\n\n在 Android 6.0 的时候，Android 在 gxinfo 添加了更详细的信息；在 Android 7.0 又对 HWUI 进行了一些重构，而且支持了 Vulkan；在 Android P 支持了 Vulkun 1.1。相信在未来不久的 Android Q，更好地支持 Vulkan 将是一个必然的方向。\n\n总的来说，UI 渲染的优化必然会朝着两个方向。一个是进一步压榨硬件的性能，让 UI 可以更加流畅。一个是改进或者增加更多的分析工具，帮助我们更容易地发现以及定位问题。\n\n##### 总结\n\n虽然硬件加速绘制极大提高了 Android 系统显示和刷新的速度，但它也存在一些问题，一方面是内存消耗，另一方面是兼容性问题，部分绘制函数不支持，更可怕的是硬件加速绘制流程本身存在 Bug。\n\n\n#### 1.2.3 如何优化 UI 渲染？\n\n##### adb 命令\n\n* gfxinfo，可以输出包含各阶段发生的动画以及帧相关的性能信息\n\n```shell\n// 渲染相关的内存和 View hierarchy 信息\nadb shell dumpsys gfxinfo 包名\n\n// 拿到最近 120 帧每个绘制阶段的耗时信息\nadb shell dumpsys gfxinfo 包名 framestats\n```\n\n* SurfaceFlinger\n\n```shell\n// 查看 Graphic Buffer 占用的内存\nadb shell dumpsys SurfaceFlinger\n```\n##### UI 优化常用手段\n\n<img src=\"ui_display_flow.png\" title=\"UI 渲染阶段流程图\"  width=\"60%\" height=\"50%\" />\n\n###### 尽量使用硬件加速\n\n如果使用了不支持的 API，系统就需要通过 CPU 软件模拟绘制，这也是渐变、磨砂、圆角等效果渲染性能比较低的原因。\n\nSVG 是个典型的例子，SVG 有很多指令硬件加速都不支持，我们可以用一个取巧的方法，提前将这些 SVG 转换为 Bitmap 缓存起来，这样系统就可以更好地使用硬件加速绘制。同理，对于圆角、渐变等场景，我们也可以改为 Bitmap 实现。\n\n问题：如何提前生成 Bitmap，以及 Bitmap 的内存需要如何管理，可以参考市面上常用图片库的实现！\n\n###### Create View 优化\n\n* 使用代码创建\n\n使用一些开源的 XML 转换为 Java 代码工具，例如 [X2C](https://github.com/iReaderAndroid/X2C)。建议在一些修改不频繁的场景下使用这种方式。\n\n* 异步创建\n\n在线程提前创建 View，实现 UI 的预加载，在使用线程创建 UI 的时候，先把线程 Looper 的 MessageQueue 替换为 UI 线程 Looper 的 Queue，在创建完 View 后需要把线程 Looper 恢复成原来的。\n\n<img src=\"async_create_view.png\" title=\"异步创建 View\"  width=\"60%\" height=\"50%\" />\n\n* View 重用\n\nView 会随着 Activity 的销毁而销毁，ListView、RecyclerView 通过 view 的缓存与重用大大提升渲染性能，因此我们可以参考它们的思想，实现一套可以在不同 Activity 或 Fragment 使用的 View 缓存机制。注意：需要保证所有进入缓存池的 View 都是干净的，不会保留之前的状态。\n\n<img src=\"view_reuse.png\" title=\"View 重用\"  width=\"60%\" height=\"50%\" />\n\n###### measure/layout 优化\n\n* 减少 UI 布局层次\n\n尽量扁平化，使用<ViewStub> <Merge> 等优化。\n\n* 优化 layout 开销\n\n尽量不用 RelativeLayout 或者基于 weighted LinearLayout，它们 layout 的开销非常巨大，推荐使用 ConstraintLayout 替代 RL 或者 weighted LL。\n\n* 背景优化\n\n尽量不要重复设置主题背景(Theme)，theme 默认会是一个纯色背景，如果我们自定义了界面的背景，那么主题的背景对我们来说是无用的，由于主题背景设置在 DecorView 中，所以这里会带来重复绘制，会带来绘制性能损耗。\n\n##### UI 进阶优化\n\n###### Litho: 异步布局\n\n* 异步布局\n\nAndroid 主线程，measure -> layout -> draw \n\n<img src=\"android_thread_model.png\" title=\"Android 主线程布局\"  width=\"60%\" height=\"50%\" />\n\nLitho异步布局\n\n<img src=\"litho_thread_model.png\" title=\"Litho异步布局\"  width=\"60%\" height=\"50%\" />\n\n* 界面扁平化\n\n<img src=\"layout_flat.png\" title=\"界面扁平化\"  width=\"60%\" height=\"50%\" />\n\n* 优化 RecyclerView\n\n<img src=\"optimize_recyclerview.png\" title=\"优化RecyclerView\"  width=\"60%\" height=\"50%\" />\n\nLitho 优化了 RV 中 UI 组件的缓存和回收方法，原生 RV 或者 LV 都是按照 viewType 来进行缓存和回收，但如果一个 RV/LV 中出现了 viewType 过多，会是缓存形同虚设，Litho 是按照 text、image 和 video 独立回收，可以提高缓存命中率、降低内存使用率、提高滚动帧率。\n\n缺点：Litho 实现了 measure/layout 异步化，使用了类似 react 单向数据流设计，一定程度上加大了 UI 开发的复杂度，并且 Litho 的 UI 代码是使用 java/kotlin 进行编写，无法在 AS 中预览。\n\n###### RenderThread 与 RenderScript\n\n在 Android 5.0，系统增加了 RenderThread，对于 ViewPropertyAnimator 和 CircularReveal 动画，我们可以使用 [RenderThread:异步渲染动画](https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&mid=2247489230&idx=1&sn=adc193e35903ab90a4c966059933a35a&source=41#wechat_redirect)，当主线程阻塞的时候，普通动画会出现明显的丢帧卡顿，而使用 RenderThread 渲染的动画即使阻塞了主线程仍不受影响。\n\n现在越来越多的应用会使用一些高级图片或者视频编辑功能，例如图片的高斯模糊、放大、锐化等。拿日常我们使用最多的“扫一扫”这个场景来看，这里涉及大量的图片变换操作，例如缩放、裁剪、二值化以及降噪等。\n\n图片的变换涉及大量的计算任务，这个时候使用 GPU 是更好的选择，那如何进一步压榨系统 GPU 的性能呢？\n\n我们可以通过[RenderScript](https://developer.android.com/guide/topics/renderscript/compute)，它是 Android 操作系统上的一套 API。它基于异构计算思想，专门用于密集型计算。\n\n###### Flutter: 自己的布局 + 渲染引擎\n\n<img src=\"flutter_render_engine.png\" title=\"Flutter 渲染流程\"  width=\"60%\" height=\"50%\" />\n\n##### 总结\n\n1. 在系统的框架下优化。布局优化、使用代码创建、View 缓存等都思路，减少甚至省下渲染流水线里某个阶段的耗时。\n2. 利用系统的新特性。使用硬件加速、RenderThread、RenderScript 等，通过系统一些新的特性，最大限度压榨出性能。\n3. 突破系统的限制，Android 碎片化很严重，很多好的特性可能低版本系统并不支持，一些特定的场景下它无法实现最优解。这时候，就要突破系统的条条框框，例如 Facebook-Litho 突破了布局渲染过程，Flutter 更近一步，把渲染都接管过来。\n\n> 在 UI 优化时，第一阶段的优化在系统的束缚下也可以达到非常不错的效果。不过越到后面越容易出现瓶颈，这时就需要进一步往底层走，可以对整个架构有更大的掌控力，需要造自己的「轮子」！\n\n## 二、Android 卡顿排查工具\n\n### 2.1 Traceview\n\n利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中。可监控 Android framework、java、应用程序代码。\n\n在 Android 5.0 之后，新增了 startMethodTracingSampling 方法，可以使用基于样本的方式进行分析，以减少对运行时的性能影响。新增了 sample 类型后，就需要我们在开销和信息丰富度之间做好权衡。\n\nTraceView 的生成\n\n1. 代码调用\n\n```java\nprivate void onCreate(){\n    // 生成traceView的起点，保存traceView的名称（路径：/mnt/sdcard/fileName）\n    Debug.startMethodTracing(\"fileName\");\n}\n\nprivate void onDestroy(){\n    Debug.stopMethodTracing();\n}\n\n```\n\n<center class=\"half\">\n    <img src=\"ddms_traceview_setting.jpg\" width=\"50%\"/>\n    <img src=\"ddms_traceview_result.jpg\" width=\"50%\"/>\n</center>\n\n\n缺点：工具本身带来的性能开销过大，有时候无法真实反映情况，比如一个函数本身的耗时是 1 秒，开启 TraceView 后可能变成 5 秒，而且这些函数的耗时变化并不是成比例放大。\n\n2. DDMS\n\nAndroid Device Monitor(DDMS)，选择进程 attached，点击trace 开始，操作app, trace 结束，分析结果。\n\nps：DDMS 可通过命令 monitor 直接打开，目录在 /sdk/tools 下。\n\n参考链接：\n\n* [Android性能优化—TraceView的使用](https://www.jianshu.com/p/7e9ca2c73c97)\n* [正确使用 Android 性能分析工具——TraceView](https://www.oschina.net/news/56500/traceview-android)\n\n\n### 2.2 systrace\n\nAndroid 4.1 新增的性能分析工具，经常使用 systrace 来跟踪系统的 I/O 操作、CPU 负载、Surface 渲染、GC 等事件。\n\n系统预留接口来监控应用程序的调用耗时，可以在可疑引起 jank 代码的地方，添加如下代码，这两个是成对出现的。\n\n```java\nTrace.beginSection(\"tag\");\nTrace.endSection(); \n```\n\n<img src=\"systrace_demo_code.jpg\" title=\"Trace演示代码\"  width=\"60%\" height=\"50%\" />\n\n<img src=\"systrace_result.jpg\" title=\"systrace使用演示\"  width=\"60%\" height=\"50%\" />\n\n参考资料：\n\n* [Android：通过systrace进行性能分析](https://www.cnblogs.com/blogs-of-lxl/p/10926824.html)\n* [Android Systrace 使用方法](https://www.jianshu.com/p/75aa88d1b575)\n* [Android Systrace的使用和分析](http://ddrv.cn/a/89930/)\n* [在Android Studio下使用Hierarchy Viewer](https://www.jianshu.com/p/e9e05ce5b0c9)\n\n怎样在 systrace 上面自动增加应用程序的耗时分析呢？\n> 编译时给每个函数插桩的方式来实现，在重要函数的入口和出口分别增加 Trace 代码，实现在 systrace 基础上增加应用程序耗时的监控。\n\n\n### 2.3 AS-Profiler\n\nAndroid Studio 自带 Profiler 工具，可以检测 CPU、memory等，点击 View -> Tool Window -> Profiler 打开工具使用。\n\n<img src=\"as_profiler.jpg\" title=\"AS-Profiler\"  width=\"60%\" height=\"50%\" />\n\n参考链接：\n\n* [利用 Android Profiler 测量应用性能](https://developer.android.com/studio/profile/android-profiler?hl=zh-cn)\n* [Android Studio 3.0 Memory Profiler使用\n](https://www.jianshu.com/p/e75680772375)\n\n### 2.4 Simpleperf\n\nAndroid 5.0 新增了 Simpleperf 性能分析工具，分析 Native 函数的调用，它利用 CPU 的性能监控单元 （PMU）提供的硬件 perf 事件，使用 Simpleperf 可以看到所有的 Native 代码的耗时，有时候一些 Android 系统库的调用对分析问题有比较大的帮助，例如加载 dex、verify class 的耗时等。\n\nSimpleperf 同时封装了 systrace 的监控功能，现在 Simpleperf 比较友好地支持 Java 代码的性能分析。\n\n### 其它 Nanoscope\n\nUber 开源的 [Nanoscope](http://github.com/uber/nanoscope)，直接修改 Android 虚拟机源码，在 ArtMethod 执行入口和执行结束位置新增埋点代码，将所有的信息先写到内存，等到 trace 结束后才统一生成结果文件。需要刷入 ROM。\n\n### 总结\n\n汇总一下，如果需要分析 Native 代码的耗时，可以选择 Simpleperf；如果想分析系统调用，可以选择 systrace；如果想分析整个程序执行流程的耗时，可以选择 TraceView 或者插桩版本的 systrace。\n\n## 三、监控应用卡顿实践\n\n### 3.1 监控主线程原理\n\n* 消息队列\n\n依赖主线程 Looper，监控每次 dispatchMessage 的执行耗时。（BlockCanary）\n\nLooper#loop 代码片段\n\n```java\npublic static void loop() {\n    ...\n    for (;;) {\n        ...\n        // This must be in a local variable, in case a UI event sets the logger\n        Printer logging = me.mLogging;\n        if (logging != null) {\n            logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                    msg.callback + \": \" + msg.what);\n        }\n        msg.target.dispatchMessage(msg);\n        if (logging != null) {\n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n        }\n        ...\n    }\n}\n```\n\n主线程所有执行的任务都在 dispatchMessage 方法中派发执行完成，我们通过 setMessageLogging 的方式给主线程的 Looper 设置一个 Printer ，因为 dispatchMessage 执行前后都会打印对应信息，在执行前利用另外一条线程，通过 Thread#getStackTrace 接口，以轮询的方式获取主线程执行堆栈信息并记录起来，同时统计每次 dispatchMessage 方法执行耗时，当超出阈值时，将该次获取的堆栈进行分析上报，从而来捕捉卡顿信息，否则丢弃此次记录的堆栈信息。\n\n* Vsync 时间差\n\n依赖 Choreographer 模块，监控相邻两次 Vsync 事件通知的时间差。（ArgusAPM、LogMonitor）。\n\n利用系统 Choreographer 模块，向该模块注册一个 FrameCallback 监听对象，同时通过另外一条线程循环记录主线程堆栈信息，并在每次 Vsync 事件 doFrame 通知回来时，循环注册该监听对象，间接统计两次 Vsync 事件的时间间隔，当超出阈值时，取出记录的堆栈进行分析上报。\n\n```java\nChoreographer.getInstance().postFrameCallback(new Choreographer.FrameCallback() {\n    @Override    \n    public void doFrame(long frameTimeNanos) {\n        if(frameTimeNanos - mLastFrameNanos > 100) {\n            ...\n        }\n        mLastFrameNanos = frameTimeNanos;\n        Choreographer.getInstance().postFrameCallback(this);\n    }\n});\n```\n\n这两种方案，可以较方便的捕捉到卡顿的堆栈，但其最大的不足在于，无法获取到各个函数的执行耗时，对于稍微复杂一点的堆栈，很难找出可能耗时的函数，也就很难找到卡顿的原因。另外，通过其他线程循环获取主线程的堆栈，如果稍微处理不及时，很容易导致获取的堆栈有所偏移，不够准确，加上没有耗时信息，卡顿也就不好定位。\n\n所以我们希望寻求一种可以在线上准确地捕捉卡顿堆栈，又能计算出各个函数执行耗时的方案。 而要计算函数的执行耗时，最关键的点在于如何对执行过程中的函数进行打点监控。\n\n### 3.2 插桩\n\n* 应用启动时，默认打开 Trace 功能（Debug.startMethodTracing），应用内所有函数在执行前后将会经过该函数（dalvik 上 dvmMethodTraceAdd 函数 或 art 上 Trace::LogMethodTraceEvent 函数）， 通过hack手段代理该函数，在每个执行方法前后进行打点记录。\n\n* 修改字节码的方式，在编译期修改所有 class 文件中的函数字节码，对所有函数前后进行打点插桩。\n\n第一种方案，最大的好处是能统计到包括系统函数在内的所有函数出入口，对代码或字节码不用做任何修改，所以对apk包的大小没有影响，但由于方式比较hack，在兼容性和安全性上存在一定的风险。\n\n第二种方案，利用 Java 字节码修改工具（如 BCEL、ASM、Javassis等），在编译期间收集所有生成的 class 文件，扫描文件内的方法指令进行统一的打点插桩，同样也可以高效的记录函数执行过程中的信息，相比第一种方案，除了无法统计系统内执行的函数，其它应用内实现的函数都可以覆盖到。而往往造成卡顿的函数并不是系统内执行的函数，一般都是我们应用开发实现的函数，所以这里无法统计系统内执行的函数对卡顿的定位影响不大。此方案无需 hook 任何函数，所以在兼容性方面会比第一个方案更可靠。\n\n在这考虑上，我们最终选择了修改字节码的方案，来实现 Matrix-TraceCannary 模块，解决其它方案中卡顿堆栈无耗时信息的主要问题，来帮助开发者发现及定位卡顿问题。\n\n参考链接：\n\n[Matrix Android TraceCanary](https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary)\n\n### 3.3 Profilo\n\n2018 年 3 月，Facebook 开源了一个 [Profilo](http://github.com/facebookincubator/profilo) 库，它收集了各大方案的优点。\n\n* 集成了 atrace 功能，ftrace（Linux 的ftrace 调试工具，相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里添加了一些性能监控的埋点。Android 在 ftrace 基础上封装了 atrace，并增加了更多特有的探针，例如 Graphics、Activity Manager、Dalvik VM、System Server 等。），Profilo 通过 PLT Hook 拦截了写入操作，选择部分关心事件，例如四大组件生命周期、锁等待时间、类校验、GC 时间等。\n* 快速获取 Java 堆栈，拿到当前执行的 Thread，通过 Thread 对象获取当前线程的 ManagedStack，ManagedStack 是一个单链表，保存了当前的 ShadowFrame 或 QuickFrame 栈指针，它依次遍历 ManagedStack 链表，然后遍历内部的 ShadowFrame 或 QuickFrame 还原一个可读的调用栈，从而 unwind 出当前的 Java 堆栈。通过这种方式可以实现一边继续跑步，还可以帮它做检查，而且耗时基本忽略不计。\n\n### 3.4 线程监控\n\nJava 线程管理是很多应用头疼的事情，应用启动就已经创建了十几上百个线程，而且大部分线程都没有经过线程池管理，都在自由的狂奔着。\n\n另一方面某些线程优先级或者活跃度比较高，占用了过多的 CPU，这会降低主线程 UI 响应能力，需要特别针对这些线程做重点的优化。\n\n* 线程数量\n监控线程数量的多少以及创建线程的方式，可通过 got hook 线程的 nativeCreate() 函数，用于进行线程收敛，也就是减少线程数量。\n\n* 线程时间\n\n监控线程用户时间 utime、系统时间 stime 和优先级，看哪些线程 utime + stime 比较多，占用了过多的 CPU，有可能有一些线程因为生命周期很短导致很难发现，这里我们需要结合线程创建监控。\n\n### 总结\n\n导致卡顿问题很多，比如函数非常耗时、I/O 非常慢、线程间锁竞争或者锁等待等，其实很多时候卡顿问题并不难解决，比较困难的是如何快速发现这些卡顿点，以及更多的辅助信息找到真正的卡顿原因，还原卡顿现场。\n\n## 四、向日葵工作台页面帧率情况\n\n<img src=\"xrk_homepage.png\" title=\"FPS悬浮窗检测\"  width=\"30%\" height=\"30%\" />\n\n> 演示工作台检测 trace.html 文件！\n\n## 五、卡顿优化计划\n\n### 5.1 常见卡顿场景\n\n* 布局嵌套层次太深，可以使用 merge、viewStub、include 来优化\n* onDraw() 里面循环创建了大量临时变量，频繁触发 GC\n* 主线程等待优先级子线程问题（锁同步问题）\n* 主线程执行耗时操作，阻塞主线程执行（同步读写文件，DB 操作）\n\n### 5.2 卡顿排查思路\n\n* 显示页面实时 FPS 帧率，帮助查看流畅度（UI 优化，参见上述方法）\n* 慢函数堆栈显示，当发生卡顿时，可以显示具体哪个函数哪行代码造成的卡顿\n* 线程监控，监控全局线程创建\n\n## 六、参考\n\n* [Android 开发高手课-卡顿优化](https://time.geekbang.org/column/article/71982)\n* [Android 开发高手课-渲染优化](https://time.geekbang.org/column/article/80921)\n* [不敢相信？System.currentTimeMillis() 居然存在性能问题](https://mp.weixin.qq.com/s?__biz=MzI2OTQxMTM4OQ==&mid=2247490024&idx=2&sn=3b8a42d0e9aae286984c03a5ac0b3389&chksm=eae1ecbadd9665ace47c2ce20487852a38dfe3735a0ee74d38096af7f7d38c862373a83e90a9)\n\n\n","source":"_posts/性能优化之卡顿优化.md","raw":"---\ntitle: 性能优化之卡顿优化\ndate: 2019-09-19 11:05:13\ntags: Android\ncategories: [Android,性能优化]\n---\n\n对用户来说，内存占用高、耗费电量、耗费流量可能不容易被发现，但是对于卡顿特别敏感，尤其在某些时候出现高频掉帧，俗称冻帧。对于开发者来说，卡顿问题非常难以排查定位，其产生的原因错综复杂，跟用户当前手机的 CPU、内存、磁盘 I/O 等环境都可能有关系。所以，到底如何该定义卡顿？在我们平时开发又有哪些工具可以帮助开发更好的发现和排查问题？在线上又该监控卡顿情况呢？下面我们来一一解决这些困惑。\n\n<!-- more -->\n\n## 一、基础知识\n\n### 1.1 CPU 时间\n\n造成卡顿的原因可能有千百种，不过最终都会反映到 CPU 时间上，我们可以把 CPU 时间分为两种：用户时间和系统时间。用户时间就是执行用户态应用程序代码所消耗的时间；系统时间是执行内核态系统调用所消耗的时间，包括 I/O、锁、中断以及其他系统调用的时间。\n\n评价一个 CPU 的性能，需要看主频、核心数、缓存等参数。\n\n获取设备的 CPU 信息\n\n```shell\n// 获取 CPU 核心数\ncat /sys/devices/system/cpu/possible\n\n// 获取某个 CPU 的频率\ncat /sys/devices/system/cpu/cpu0/cpufeq/cpuinfo_max_freq\n```\n\n<img src=\"pc_cpu_info.jpg\" title=\"CPU信息\"  width=\"60%\" height=\"50%\" />\n\n当出现卡顿问题的时候，怎么去区分究竟是我们代码的问题，还是系统的问题？用户时间和系统时间可以给我们哪些线索？这里需要两个非常重要的指标帮助我们做判断。\n\n* CPU 的使用率\n\n可以通过 /proc/stat 得到整个系统的 CPU 使用情况，通过 /proc/[pid]/stat 可以得到某个进程的 CPU 使用情况。\n\n<img src=\"pc_cpu_usage.jpg\" title=\"CPU 使用率\"  width=\"60%\" height=\"50%\" />\n\n<img src=\"xrk_process_cpu.jpg\" title=\"向日葵进程CPU使用率\"  width=\"60%\" height=\"50%\" />\n\n参考链接：\n* [《Linux 环境下进程的CPU 占有率》](http://www.samirchen.com/linux-cpu-performance/)\n* [Linux 文档](http://man7.org/linux/man-pages/man5/proc.5.html)\n\n```shell\n命令 \n    \n* top 命令\n帮助查看哪个进程是 CPU 的消耗大户\n    \n* vmstat 命令\n可以实时监控操作系统的虚拟内存和 CPU 活动；\n    \n* strace 命令\n    \n可以跟踪某个进程中所有的系统调用\n```\n\n* CPU 饱和度\n\nCPU 饱和度反映的是线程排队等待 CPU 的情况，也就是 CPU 的负载情况。CPU 饱和度会跟应用的线程数有关，如果启动线程过多，容易导致系统不断地切换执行的线程，把大量的时间浪费在上下文切换，每次 CPU 上下文切换都需要刷新寄存器和计数器，至少需要十几纳秒的时间。\n\n```shell\n命令\n    \n* vmstat 命令或者 /proc/[pid]/schedstat 文件\n\n查看 CPU 上下文切换次数，需要特别注意 nr_involuntary_switches 被动切换的次数。\n    \n// TODO\n    \n* uptime 命令\n查看 CPU 在1分钟、5分钟和15分钟内的平均负载，例如一个4核的 CPU，如果当前平均负载是 8，这意味着每个 CPU 上有一个线程在运行，还有一个线程在等待。一般平均负载建议控制在 0.7 x 核数 以内。\n    \n// TODO\n```\n线程优先级-nice 值越低，抢占 CPU 时间片的能力越强。\n\n### 1.2 绘制原理\n\n#### 1.2.1 UI 渲染背景知识\n\n#####  屏幕适配\n\npx、ppi、dpi、dp、density\n\n<img src=\"screen_adaptation_table.png\" title=\"屏幕适配概念图\"  width=\"60%\" height=\"50%\" />\n\n参考链接：\n\n* [一种极低成本的 Android 屏幕适配方式-今日头条适配方案](https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA)\n* [Android 目前稳定高效的 UI 适配方案-smallestWidth 限定符适配方案](https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650826381&idx=1&sn=5b71b7f1654b04a55fca25b0e90a4433&chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&scene=21#wechat_redirect)\n\n#####  CPU 与 GPU\n\nUI 渲染依赖两个核心的硬件：CPU 与 GPU。UI 组件在绘制到屏幕之前，都需要经过 Rasterization（格栅化）操作，而格栅化操作是一个耗时操作。GPU(Graphic processing Unit)也就是图形处理器，它主要用于处理图形运算，可能帮助我们加快格栅化操作。\n\n软件绘制使用的是 Skia 库，它是一款能在低端机上呈现高质量的 2D 跨平台框架，类似 Chrome、Flutter 内部使用的都是 Skia 库。\n\n<img src=\"cpu_and_gpu.png\" title=\"CPU&GPU\"  width=\"60%\" height=\"50%\" />\n\n##### OpenGL 与 Vulkan \n\n对于硬件绘制，通过调用 OpenGL ES 接口利用 GPU 完成绘制。[OpenGL](https://developer.android.com/guide/topics/graphics/opengl) 是一个跨平台的图形 API，它为 2D/3D 图形处理硬件指定了标准软件接口，而 OpenGL ES 是 OpenGL 的子集，专为嵌入式设备设计。\n\nAndroid 7.0 把 [OpenGL ES](https://www.khronos.org/opengles/) 升级到最新的 3.2 版本同时，还添加了对 [Vulkan](https://developer.android.com/guide/topics/graphics/opengl)的支持，Vulkan 是用于高性能 3D 图形的低开销、跨平台 API。相比 OpenGL ES，Vulkan 在改善功耗、多核优化提升绘图调用上有着非常明显的优势。\n\n参考资料：\n\n* [官方硬件加速文档](https://developer.android.com/guide/topics/graphics/hardware-accel)\n\n#### 1.2.2 Android 渲染的演进\n\n##### Android 图形系统整体架构\n\n<img src=\"android_graphic_system_arch.png\" title=\"Android图形系统整体架构\"  width=\"60%\" height=\"50%\" />\n\n* 画笔：Skia 或者 OpenGL\n* 画纸：Surface\n* 画板：Graphic Buffer\n* 显示：SurfaceFlinger\n\n参考资料：\n\n* [Android图形系统整体架构](https://source.android.com/devices/graphics)\n\n##### 硬件加速绘制\n\n###### Android 3.0 软件绘制\n\n在 Android 3.0 之前，或者没有启动硬件加速时，系统都会使用软件方式来渲染 UI。\n\n整个流程如上图所示： \n\n* Surface。每个 View 都由某一个窗口管理，而每一个窗口都关联有一个 Surface。\n* Canvas。通过 Surface 的 lock 函数获得一个 Canvas，Canvas 可以简单理解为 Skia 底层接口的封装。\n* Graphic Buffer。SurfaceFlinger 会帮我们托管一个 BufferQueue，我们从 BufferQueue 中拿到 Graphic Buffer，然后通过 Canvas 以及 Skia 将绘制内容栅格化到上面。\n* SurfaceFlinger。通过 Swap Buffer 把 Front Graphic Buffer 的内容交给 SurfaceFinger，最后硬件合成器 Hardware Composer 合成并输出到显示屏。\n\n###### Android 4.0 开启硬件加速\n\n* 从 Androd 3.0 开始，Android 开始支持硬件加速，到 Android 4.0 时，，默认开启硬件加速。\n\n<img src=\"soft_draw_android3.0.png\" title=\"Android3.0软件绘制\"  width=\"60%\" height=\"50%\" />\n\n<img src=\"soft_draw_android4.0.png\" title=\"Android4.0+硬件加速\"  width=\"60%\" height=\"50%\" />\n\n硬件加速核心是通过 GPU 完成 Graphic Buffer 的内容绘制，此外硬件绘制还引入了一个 DisplayList 的概念，每个 View 内部都有一个 DisplayView，当某个 View 需要重绘时，将它标记为 Dirty，不需要像软件绘制向上递归，这样可以大大减少绘图的操作数量，提升渲染效率。\n\n<img src=\"view_displaylist.png\" title=\"View的DisplayList局部刷新\"  width=\"60%\" height=\"50%\" />\n\n##### Project Butter 黄油计划\n\nAndroid 4.1：Project Butter 主要包含两个组成部分，一个是 VSYNC，一个是 Triple Buffering。\n\nVSYNC 信号\n\n<img src=\"vsync_signal.png\" title=\"VSYNC信号\"  width=\"60%\" height=\"50%\" />\n\n三级缓冲机制 Triple Buffering\n\n<img src=\"triple_buffering.png\" title=\"三级缓冲机制 Triple Buffering\"  width=\"60%\" height=\"50%\" />\n\nJank渲染超时\n\n<img src=\"display_jank.png\" title=\"Jank渲染超时\"  width=\"60%\" height=\"50%\" />\n\n##### Android 5.0: RenderThread 异步渲染\n\n<img src=\"display_renderthread.png\" title=\"RenderThread工作\"  width=\"60%\" height=\"50%\" />\n\n##### 数据测量\n\n* 绘制过度工具\n\n在 Android 4.2，系统增加了检测绘制过度工具。\n\n<img src=\"overdraw_tools.png\" title=\"检测绘制过度工具\"  width=\"50%\" height=\"50%\" />\n\n参考资料：[检查 GPU 渲染进度和绘制过度](https://developer.android.com/studio/profile/inspect-gpu-rendering)\n\n##### 未来\n\n在 Android 6.0 的时候，Android 在 gxinfo 添加了更详细的信息；在 Android 7.0 又对 HWUI 进行了一些重构，而且支持了 Vulkan；在 Android P 支持了 Vulkun 1.1。相信在未来不久的 Android Q，更好地支持 Vulkan 将是一个必然的方向。\n\n总的来说，UI 渲染的优化必然会朝着两个方向。一个是进一步压榨硬件的性能，让 UI 可以更加流畅。一个是改进或者增加更多的分析工具，帮助我们更容易地发现以及定位问题。\n\n##### 总结\n\n虽然硬件加速绘制极大提高了 Android 系统显示和刷新的速度，但它也存在一些问题，一方面是内存消耗，另一方面是兼容性问题，部分绘制函数不支持，更可怕的是硬件加速绘制流程本身存在 Bug。\n\n\n#### 1.2.3 如何优化 UI 渲染？\n\n##### adb 命令\n\n* gfxinfo，可以输出包含各阶段发生的动画以及帧相关的性能信息\n\n```shell\n// 渲染相关的内存和 View hierarchy 信息\nadb shell dumpsys gfxinfo 包名\n\n// 拿到最近 120 帧每个绘制阶段的耗时信息\nadb shell dumpsys gfxinfo 包名 framestats\n```\n\n* SurfaceFlinger\n\n```shell\n// 查看 Graphic Buffer 占用的内存\nadb shell dumpsys SurfaceFlinger\n```\n##### UI 优化常用手段\n\n<img src=\"ui_display_flow.png\" title=\"UI 渲染阶段流程图\"  width=\"60%\" height=\"50%\" />\n\n###### 尽量使用硬件加速\n\n如果使用了不支持的 API，系统就需要通过 CPU 软件模拟绘制，这也是渐变、磨砂、圆角等效果渲染性能比较低的原因。\n\nSVG 是个典型的例子，SVG 有很多指令硬件加速都不支持，我们可以用一个取巧的方法，提前将这些 SVG 转换为 Bitmap 缓存起来，这样系统就可以更好地使用硬件加速绘制。同理，对于圆角、渐变等场景，我们也可以改为 Bitmap 实现。\n\n问题：如何提前生成 Bitmap，以及 Bitmap 的内存需要如何管理，可以参考市面上常用图片库的实现！\n\n###### Create View 优化\n\n* 使用代码创建\n\n使用一些开源的 XML 转换为 Java 代码工具，例如 [X2C](https://github.com/iReaderAndroid/X2C)。建议在一些修改不频繁的场景下使用这种方式。\n\n* 异步创建\n\n在线程提前创建 View，实现 UI 的预加载，在使用线程创建 UI 的时候，先把线程 Looper 的 MessageQueue 替换为 UI 线程 Looper 的 Queue，在创建完 View 后需要把线程 Looper 恢复成原来的。\n\n<img src=\"async_create_view.png\" title=\"异步创建 View\"  width=\"60%\" height=\"50%\" />\n\n* View 重用\n\nView 会随着 Activity 的销毁而销毁，ListView、RecyclerView 通过 view 的缓存与重用大大提升渲染性能，因此我们可以参考它们的思想，实现一套可以在不同 Activity 或 Fragment 使用的 View 缓存机制。注意：需要保证所有进入缓存池的 View 都是干净的，不会保留之前的状态。\n\n<img src=\"view_reuse.png\" title=\"View 重用\"  width=\"60%\" height=\"50%\" />\n\n###### measure/layout 优化\n\n* 减少 UI 布局层次\n\n尽量扁平化，使用<ViewStub> <Merge> 等优化。\n\n* 优化 layout 开销\n\n尽量不用 RelativeLayout 或者基于 weighted LinearLayout，它们 layout 的开销非常巨大，推荐使用 ConstraintLayout 替代 RL 或者 weighted LL。\n\n* 背景优化\n\n尽量不要重复设置主题背景(Theme)，theme 默认会是一个纯色背景，如果我们自定义了界面的背景，那么主题的背景对我们来说是无用的，由于主题背景设置在 DecorView 中，所以这里会带来重复绘制，会带来绘制性能损耗。\n\n##### UI 进阶优化\n\n###### Litho: 异步布局\n\n* 异步布局\n\nAndroid 主线程，measure -> layout -> draw \n\n<img src=\"android_thread_model.png\" title=\"Android 主线程布局\"  width=\"60%\" height=\"50%\" />\n\nLitho异步布局\n\n<img src=\"litho_thread_model.png\" title=\"Litho异步布局\"  width=\"60%\" height=\"50%\" />\n\n* 界面扁平化\n\n<img src=\"layout_flat.png\" title=\"界面扁平化\"  width=\"60%\" height=\"50%\" />\n\n* 优化 RecyclerView\n\n<img src=\"optimize_recyclerview.png\" title=\"优化RecyclerView\"  width=\"60%\" height=\"50%\" />\n\nLitho 优化了 RV 中 UI 组件的缓存和回收方法，原生 RV 或者 LV 都是按照 viewType 来进行缓存和回收，但如果一个 RV/LV 中出现了 viewType 过多，会是缓存形同虚设，Litho 是按照 text、image 和 video 独立回收，可以提高缓存命中率、降低内存使用率、提高滚动帧率。\n\n缺点：Litho 实现了 measure/layout 异步化，使用了类似 react 单向数据流设计，一定程度上加大了 UI 开发的复杂度，并且 Litho 的 UI 代码是使用 java/kotlin 进行编写，无法在 AS 中预览。\n\n###### RenderThread 与 RenderScript\n\n在 Android 5.0，系统增加了 RenderThread，对于 ViewPropertyAnimator 和 CircularReveal 动画，我们可以使用 [RenderThread:异步渲染动画](https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&mid=2247489230&idx=1&sn=adc193e35903ab90a4c966059933a35a&source=41#wechat_redirect)，当主线程阻塞的时候，普通动画会出现明显的丢帧卡顿，而使用 RenderThread 渲染的动画即使阻塞了主线程仍不受影响。\n\n现在越来越多的应用会使用一些高级图片或者视频编辑功能，例如图片的高斯模糊、放大、锐化等。拿日常我们使用最多的“扫一扫”这个场景来看，这里涉及大量的图片变换操作，例如缩放、裁剪、二值化以及降噪等。\n\n图片的变换涉及大量的计算任务，这个时候使用 GPU 是更好的选择，那如何进一步压榨系统 GPU 的性能呢？\n\n我们可以通过[RenderScript](https://developer.android.com/guide/topics/renderscript/compute)，它是 Android 操作系统上的一套 API。它基于异构计算思想，专门用于密集型计算。\n\n###### Flutter: 自己的布局 + 渲染引擎\n\n<img src=\"flutter_render_engine.png\" title=\"Flutter 渲染流程\"  width=\"60%\" height=\"50%\" />\n\n##### 总结\n\n1. 在系统的框架下优化。布局优化、使用代码创建、View 缓存等都思路，减少甚至省下渲染流水线里某个阶段的耗时。\n2. 利用系统的新特性。使用硬件加速、RenderThread、RenderScript 等，通过系统一些新的特性，最大限度压榨出性能。\n3. 突破系统的限制，Android 碎片化很严重，很多好的特性可能低版本系统并不支持，一些特定的场景下它无法实现最优解。这时候，就要突破系统的条条框框，例如 Facebook-Litho 突破了布局渲染过程，Flutter 更近一步，把渲染都接管过来。\n\n> 在 UI 优化时，第一阶段的优化在系统的束缚下也可以达到非常不错的效果。不过越到后面越容易出现瓶颈，这时就需要进一步往底层走，可以对整个架构有更大的掌控力，需要造自己的「轮子」！\n\n## 二、Android 卡顿排查工具\n\n### 2.1 Traceview\n\n利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中。可监控 Android framework、java、应用程序代码。\n\n在 Android 5.0 之后，新增了 startMethodTracingSampling 方法，可以使用基于样本的方式进行分析，以减少对运行时的性能影响。新增了 sample 类型后，就需要我们在开销和信息丰富度之间做好权衡。\n\nTraceView 的生成\n\n1. 代码调用\n\n```java\nprivate void onCreate(){\n    // 生成traceView的起点，保存traceView的名称（路径：/mnt/sdcard/fileName）\n    Debug.startMethodTracing(\"fileName\");\n}\n\nprivate void onDestroy(){\n    Debug.stopMethodTracing();\n}\n\n```\n\n<center class=\"half\">\n    <img src=\"ddms_traceview_setting.jpg\" width=\"50%\"/>\n    <img src=\"ddms_traceview_result.jpg\" width=\"50%\"/>\n</center>\n\n\n缺点：工具本身带来的性能开销过大，有时候无法真实反映情况，比如一个函数本身的耗时是 1 秒，开启 TraceView 后可能变成 5 秒，而且这些函数的耗时变化并不是成比例放大。\n\n2. DDMS\n\nAndroid Device Monitor(DDMS)，选择进程 attached，点击trace 开始，操作app, trace 结束，分析结果。\n\nps：DDMS 可通过命令 monitor 直接打开，目录在 /sdk/tools 下。\n\n参考链接：\n\n* [Android性能优化—TraceView的使用](https://www.jianshu.com/p/7e9ca2c73c97)\n* [正确使用 Android 性能分析工具——TraceView](https://www.oschina.net/news/56500/traceview-android)\n\n\n### 2.2 systrace\n\nAndroid 4.1 新增的性能分析工具，经常使用 systrace 来跟踪系统的 I/O 操作、CPU 负载、Surface 渲染、GC 等事件。\n\n系统预留接口来监控应用程序的调用耗时，可以在可疑引起 jank 代码的地方，添加如下代码，这两个是成对出现的。\n\n```java\nTrace.beginSection(\"tag\");\nTrace.endSection(); \n```\n\n<img src=\"systrace_demo_code.jpg\" title=\"Trace演示代码\"  width=\"60%\" height=\"50%\" />\n\n<img src=\"systrace_result.jpg\" title=\"systrace使用演示\"  width=\"60%\" height=\"50%\" />\n\n参考资料：\n\n* [Android：通过systrace进行性能分析](https://www.cnblogs.com/blogs-of-lxl/p/10926824.html)\n* [Android Systrace 使用方法](https://www.jianshu.com/p/75aa88d1b575)\n* [Android Systrace的使用和分析](http://ddrv.cn/a/89930/)\n* [在Android Studio下使用Hierarchy Viewer](https://www.jianshu.com/p/e9e05ce5b0c9)\n\n怎样在 systrace 上面自动增加应用程序的耗时分析呢？\n> 编译时给每个函数插桩的方式来实现，在重要函数的入口和出口分别增加 Trace 代码，实现在 systrace 基础上增加应用程序耗时的监控。\n\n\n### 2.3 AS-Profiler\n\nAndroid Studio 自带 Profiler 工具，可以检测 CPU、memory等，点击 View -> Tool Window -> Profiler 打开工具使用。\n\n<img src=\"as_profiler.jpg\" title=\"AS-Profiler\"  width=\"60%\" height=\"50%\" />\n\n参考链接：\n\n* [利用 Android Profiler 测量应用性能](https://developer.android.com/studio/profile/android-profiler?hl=zh-cn)\n* [Android Studio 3.0 Memory Profiler使用\n](https://www.jianshu.com/p/e75680772375)\n\n### 2.4 Simpleperf\n\nAndroid 5.0 新增了 Simpleperf 性能分析工具，分析 Native 函数的调用，它利用 CPU 的性能监控单元 （PMU）提供的硬件 perf 事件，使用 Simpleperf 可以看到所有的 Native 代码的耗时，有时候一些 Android 系统库的调用对分析问题有比较大的帮助，例如加载 dex、verify class 的耗时等。\n\nSimpleperf 同时封装了 systrace 的监控功能，现在 Simpleperf 比较友好地支持 Java 代码的性能分析。\n\n### 其它 Nanoscope\n\nUber 开源的 [Nanoscope](http://github.com/uber/nanoscope)，直接修改 Android 虚拟机源码，在 ArtMethod 执行入口和执行结束位置新增埋点代码，将所有的信息先写到内存，等到 trace 结束后才统一生成结果文件。需要刷入 ROM。\n\n### 总结\n\n汇总一下，如果需要分析 Native 代码的耗时，可以选择 Simpleperf；如果想分析系统调用，可以选择 systrace；如果想分析整个程序执行流程的耗时，可以选择 TraceView 或者插桩版本的 systrace。\n\n## 三、监控应用卡顿实践\n\n### 3.1 监控主线程原理\n\n* 消息队列\n\n依赖主线程 Looper，监控每次 dispatchMessage 的执行耗时。（BlockCanary）\n\nLooper#loop 代码片段\n\n```java\npublic static void loop() {\n    ...\n    for (;;) {\n        ...\n        // This must be in a local variable, in case a UI event sets the logger\n        Printer logging = me.mLogging;\n        if (logging != null) {\n            logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                    msg.callback + \": \" + msg.what);\n        }\n        msg.target.dispatchMessage(msg);\n        if (logging != null) {\n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n        }\n        ...\n    }\n}\n```\n\n主线程所有执行的任务都在 dispatchMessage 方法中派发执行完成，我们通过 setMessageLogging 的方式给主线程的 Looper 设置一个 Printer ，因为 dispatchMessage 执行前后都会打印对应信息，在执行前利用另外一条线程，通过 Thread#getStackTrace 接口，以轮询的方式获取主线程执行堆栈信息并记录起来，同时统计每次 dispatchMessage 方法执行耗时，当超出阈值时，将该次获取的堆栈进行分析上报，从而来捕捉卡顿信息，否则丢弃此次记录的堆栈信息。\n\n* Vsync 时间差\n\n依赖 Choreographer 模块，监控相邻两次 Vsync 事件通知的时间差。（ArgusAPM、LogMonitor）。\n\n利用系统 Choreographer 模块，向该模块注册一个 FrameCallback 监听对象，同时通过另外一条线程循环记录主线程堆栈信息，并在每次 Vsync 事件 doFrame 通知回来时，循环注册该监听对象，间接统计两次 Vsync 事件的时间间隔，当超出阈值时，取出记录的堆栈进行分析上报。\n\n```java\nChoreographer.getInstance().postFrameCallback(new Choreographer.FrameCallback() {\n    @Override    \n    public void doFrame(long frameTimeNanos) {\n        if(frameTimeNanos - mLastFrameNanos > 100) {\n            ...\n        }\n        mLastFrameNanos = frameTimeNanos;\n        Choreographer.getInstance().postFrameCallback(this);\n    }\n});\n```\n\n这两种方案，可以较方便的捕捉到卡顿的堆栈，但其最大的不足在于，无法获取到各个函数的执行耗时，对于稍微复杂一点的堆栈，很难找出可能耗时的函数，也就很难找到卡顿的原因。另外，通过其他线程循环获取主线程的堆栈，如果稍微处理不及时，很容易导致获取的堆栈有所偏移，不够准确，加上没有耗时信息，卡顿也就不好定位。\n\n所以我们希望寻求一种可以在线上准确地捕捉卡顿堆栈，又能计算出各个函数执行耗时的方案。 而要计算函数的执行耗时，最关键的点在于如何对执行过程中的函数进行打点监控。\n\n### 3.2 插桩\n\n* 应用启动时，默认打开 Trace 功能（Debug.startMethodTracing），应用内所有函数在执行前后将会经过该函数（dalvik 上 dvmMethodTraceAdd 函数 或 art 上 Trace::LogMethodTraceEvent 函数）， 通过hack手段代理该函数，在每个执行方法前后进行打点记录。\n\n* 修改字节码的方式，在编译期修改所有 class 文件中的函数字节码，对所有函数前后进行打点插桩。\n\n第一种方案，最大的好处是能统计到包括系统函数在内的所有函数出入口，对代码或字节码不用做任何修改，所以对apk包的大小没有影响，但由于方式比较hack，在兼容性和安全性上存在一定的风险。\n\n第二种方案，利用 Java 字节码修改工具（如 BCEL、ASM、Javassis等），在编译期间收集所有生成的 class 文件，扫描文件内的方法指令进行统一的打点插桩，同样也可以高效的记录函数执行过程中的信息，相比第一种方案，除了无法统计系统内执行的函数，其它应用内实现的函数都可以覆盖到。而往往造成卡顿的函数并不是系统内执行的函数，一般都是我们应用开发实现的函数，所以这里无法统计系统内执行的函数对卡顿的定位影响不大。此方案无需 hook 任何函数，所以在兼容性方面会比第一个方案更可靠。\n\n在这考虑上，我们最终选择了修改字节码的方案，来实现 Matrix-TraceCannary 模块，解决其它方案中卡顿堆栈无耗时信息的主要问题，来帮助开发者发现及定位卡顿问题。\n\n参考链接：\n\n[Matrix Android TraceCanary](https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary)\n\n### 3.3 Profilo\n\n2018 年 3 月，Facebook 开源了一个 [Profilo](http://github.com/facebookincubator/profilo) 库，它收集了各大方案的优点。\n\n* 集成了 atrace 功能，ftrace（Linux 的ftrace 调试工具，相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里添加了一些性能监控的埋点。Android 在 ftrace 基础上封装了 atrace，并增加了更多特有的探针，例如 Graphics、Activity Manager、Dalvik VM、System Server 等。），Profilo 通过 PLT Hook 拦截了写入操作，选择部分关心事件，例如四大组件生命周期、锁等待时间、类校验、GC 时间等。\n* 快速获取 Java 堆栈，拿到当前执行的 Thread，通过 Thread 对象获取当前线程的 ManagedStack，ManagedStack 是一个单链表，保存了当前的 ShadowFrame 或 QuickFrame 栈指针，它依次遍历 ManagedStack 链表，然后遍历内部的 ShadowFrame 或 QuickFrame 还原一个可读的调用栈，从而 unwind 出当前的 Java 堆栈。通过这种方式可以实现一边继续跑步，还可以帮它做检查，而且耗时基本忽略不计。\n\n### 3.4 线程监控\n\nJava 线程管理是很多应用头疼的事情，应用启动就已经创建了十几上百个线程，而且大部分线程都没有经过线程池管理，都在自由的狂奔着。\n\n另一方面某些线程优先级或者活跃度比较高，占用了过多的 CPU，这会降低主线程 UI 响应能力，需要特别针对这些线程做重点的优化。\n\n* 线程数量\n监控线程数量的多少以及创建线程的方式，可通过 got hook 线程的 nativeCreate() 函数，用于进行线程收敛，也就是减少线程数量。\n\n* 线程时间\n\n监控线程用户时间 utime、系统时间 stime 和优先级，看哪些线程 utime + stime 比较多，占用了过多的 CPU，有可能有一些线程因为生命周期很短导致很难发现，这里我们需要结合线程创建监控。\n\n### 总结\n\n导致卡顿问题很多，比如函数非常耗时、I/O 非常慢、线程间锁竞争或者锁等待等，其实很多时候卡顿问题并不难解决，比较困难的是如何快速发现这些卡顿点，以及更多的辅助信息找到真正的卡顿原因，还原卡顿现场。\n\n## 四、向日葵工作台页面帧率情况\n\n<img src=\"xrk_homepage.png\" title=\"FPS悬浮窗检测\"  width=\"30%\" height=\"30%\" />\n\n> 演示工作台检测 trace.html 文件！\n\n## 五、卡顿优化计划\n\n### 5.1 常见卡顿场景\n\n* 布局嵌套层次太深，可以使用 merge、viewStub、include 来优化\n* onDraw() 里面循环创建了大量临时变量，频繁触发 GC\n* 主线程等待优先级子线程问题（锁同步问题）\n* 主线程执行耗时操作，阻塞主线程执行（同步读写文件，DB 操作）\n\n### 5.2 卡顿排查思路\n\n* 显示页面实时 FPS 帧率，帮助查看流畅度（UI 优化，参见上述方法）\n* 慢函数堆栈显示，当发生卡顿时，可以显示具体哪个函数哪行代码造成的卡顿\n* 线程监控，监控全局线程创建\n\n## 六、参考\n\n* [Android 开发高手课-卡顿优化](https://time.geekbang.org/column/article/71982)\n* [Android 开发高手课-渲染优化](https://time.geekbang.org/column/article/80921)\n* [不敢相信？System.currentTimeMillis() 居然存在性能问题](https://mp.weixin.qq.com/s?__biz=MzI2OTQxMTM4OQ==&mid=2247490024&idx=2&sn=3b8a42d0e9aae286984c03a5ac0b3389&chksm=eae1ecbadd9665ace47c2ce20487852a38dfe3735a0ee74d38096af7f7d38c862373a83e90a9)\n\n\n","slug":"性能优化之卡顿优化","published":1,"updated":"2020-01-14T03:35:49.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vfk001vn2cbkz0oamcp","content":"<p>对用户来说，内存占用高、耗费电量、耗费流量可能不容易被发现，但是对于卡顿特别敏感，尤其在某些时候出现高频掉帧，俗称冻帧。对于开发者来说，卡顿问题非常难以排查定位，其产生的原因错综复杂，跟用户当前手机的 CPU、内存、磁盘 I/O 等环境都可能有关系。所以，到底如何该定义卡顿？在我们平时开发又有哪些工具可以帮助开发更好的发现和排查问题？在线上又该监控卡顿情况呢？下面我们来一一解决这些困惑。</p>\n<a id=\"more\"></a>\n<h2 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h2><h3 id=\"1-1-CPU-时间\"><a href=\"#1-1-CPU-时间\" class=\"headerlink\" title=\"1.1 CPU 时间\"></a>1.1 CPU 时间</h3><p>造成卡顿的原因可能有千百种，不过最终都会反映到 CPU 时间上，我们可以把 CPU 时间分为两种：用户时间和系统时间。用户时间就是执行用户态应用程序代码所消耗的时间；系统时间是执行内核态系统调用所消耗的时间，包括 I/O、锁、中断以及其他系统调用的时间。</p>\n<p>评价一个 CPU 的性能，需要看主频、核心数、缓存等参数。</p>\n<p>获取设备的 CPU 信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取 CPU 核心数</span><br><span class=\"line\">cat /sys/devices/system/cpu/possible</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取某个 CPU 的频率</span><br><span class=\"line\">cat /sys/devices/system/cpu/cpu0/cpufeq/cpuinfo_max_freq</span><br></pre></td></tr></table></figure>\n<p><img src=\"pc_cpu_info.jpg\" title=\"CPU信息\" width=\"60%\" height=\"50%\"></p>\n<p>当出现卡顿问题的时候，怎么去区分究竟是我们代码的问题，还是系统的问题？用户时间和系统时间可以给我们哪些线索？这里需要两个非常重要的指标帮助我们做判断。</p>\n<ul>\n<li>CPU 的使用率</li>\n</ul>\n<p>可以通过 /proc/stat 得到整个系统的 CPU 使用情况，通过 /proc/[pid]/stat 可以得到某个进程的 CPU 使用情况。</p>\n<p><img src=\"pc_cpu_usage.jpg\" title=\"CPU 使用率\" width=\"60%\" height=\"50%\"></p>\n<p><img src=\"xrk_process_cpu.jpg\" title=\"向日葵进程CPU使用率\" width=\"60%\" height=\"50%\"></p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"http://www.samirchen.com/linux-cpu-performance/\" target=\"_blank\" rel=\"noopener\">《Linux 环境下进程的CPU 占有率》</a></li>\n<li><a href=\"http://man7.org/linux/man-pages/man5/proc.5.html\" target=\"_blank\" rel=\"noopener\">Linux 文档</a></li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令 </span><br><span class=\"line\">    </span><br><span class=\"line\">* top 命令</span><br><span class=\"line\">帮助查看哪个进程是 CPU 的消耗大户</span><br><span class=\"line\">    </span><br><span class=\"line\">* vmstat 命令</span><br><span class=\"line\">可以实时监控操作系统的虚拟内存和 CPU 活动；</span><br><span class=\"line\">    </span><br><span class=\"line\">* strace 命令</span><br><span class=\"line\">    </span><br><span class=\"line\">可以跟踪某个进程中所有的系统调用</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CPU 饱和度</li>\n</ul>\n<p>CPU 饱和度反映的是线程排队等待 CPU 的情况，也就是 CPU 的负载情况。CPU 饱和度会跟应用的线程数有关，如果启动线程过多，容易导致系统不断地切换执行的线程，把大量的时间浪费在上下文切换，每次 CPU 上下文切换都需要刷新寄存器和计数器，至少需要十几纳秒的时间。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令</span><br><span class=\"line\">    </span><br><span class=\"line\">* vmstat 命令或者 /proc/[pid]/schedstat 文件</span><br><span class=\"line\"></span><br><span class=\"line\">查看 CPU 上下文切换次数，需要特别注意 nr_involuntary_switches 被动切换的次数。</span><br><span class=\"line\">    </span><br><span class=\"line\">// TODO</span><br><span class=\"line\">    </span><br><span class=\"line\">* uptime 命令</span><br><span class=\"line\">查看 CPU 在1分钟、5分钟和15分钟内的平均负载，例如一个4核的 CPU，如果当前平均负载是 8，这意味着每个 CPU 上有一个线程在运行，还有一个线程在等待。一般平均负载建议控制在 0.7 x 核数 以内。</span><br><span class=\"line\">    </span><br><span class=\"line\">// TODO</span><br></pre></td></tr></table></figure>\n<p>线程优先级-nice 值越低，抢占 CPU 时间片的能力越强。</p>\n<h3 id=\"1-2-绘制原理\"><a href=\"#1-2-绘制原理\" class=\"headerlink\" title=\"1.2 绘制原理\"></a>1.2 绘制原理</h3><h4 id=\"1-2-1-UI-渲染背景知识\"><a href=\"#1-2-1-UI-渲染背景知识\" class=\"headerlink\" title=\"1.2.1 UI 渲染背景知识\"></a>1.2.1 UI 渲染背景知识</h4><h5 id=\"屏幕适配\"><a href=\"#屏幕适配\" class=\"headerlink\" title=\"屏幕适配\"></a>屏幕适配</h5><p>px、ppi、dpi、dp、density</p>\n<p><img src=\"screen_adaptation_table.png\" title=\"屏幕适配概念图\" width=\"60%\" height=\"50%\"></p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA\" target=\"_blank\" rel=\"noopener\">一种极低成本的 Android 屏幕适配方式-今日头条适配方案</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826381&amp;idx=1&amp;sn=5b71b7f1654b04a55fca25b0e90a4433&amp;chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">Android 目前稳定高效的 UI 适配方案-smallestWidth 限定符适配方案</a></li>\n</ul>\n<h5 id=\"CPU-与-GPU\"><a href=\"#CPU-与-GPU\" class=\"headerlink\" title=\"CPU 与 GPU\"></a>CPU 与 GPU</h5><p>UI 渲染依赖两个核心的硬件：CPU 与 GPU。UI 组件在绘制到屏幕之前，都需要经过 Rasterization（格栅化）操作，而格栅化操作是一个耗时操作。GPU(Graphic processing Unit)也就是图形处理器，它主要用于处理图形运算，可能帮助我们加快格栅化操作。</p>\n<p>软件绘制使用的是 Skia 库，它是一款能在低端机上呈现高质量的 2D 跨平台框架，类似 Chrome、Flutter 内部使用的都是 Skia 库。</p>\n<p><img src=\"cpu_and_gpu.png\" title=\"CPU&GPU\" width=\"60%\" height=\"50%\"></p>\n<h5 id=\"OpenGL-与-Vulkan\"><a href=\"#OpenGL-与-Vulkan\" class=\"headerlink\" title=\"OpenGL 与 Vulkan\"></a>OpenGL 与 Vulkan</h5><p>对于硬件绘制，通过调用 OpenGL ES 接口利用 GPU 完成绘制。<a href=\"https://developer.android.com/guide/topics/graphics/opengl\" target=\"_blank\" rel=\"noopener\">OpenGL</a> 是一个跨平台的图形 API，它为 2D/3D 图形处理硬件指定了标准软件接口，而 OpenGL ES 是 OpenGL 的子集，专为嵌入式设备设计。</p>\n<p>Android 7.0 把 <a href=\"https://www.khronos.org/opengles/\" target=\"_blank\" rel=\"noopener\">OpenGL ES</a> 升级到最新的 3.2 版本同时，还添加了对 <a href=\"https://developer.android.com/guide/topics/graphics/opengl\" target=\"_blank\" rel=\"noopener\">Vulkan</a>的支持，Vulkan 是用于高性能 3D 图形的低开销、跨平台 API。相比 OpenGL ES，Vulkan 在改善功耗、多核优化提升绘图调用上有着非常明显的优势。</p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.android.com/guide/topics/graphics/hardware-accel\" target=\"_blank\" rel=\"noopener\">官方硬件加速文档</a></li>\n</ul>\n<h4 id=\"1-2-2-Android-渲染的演进\"><a href=\"#1-2-2-Android-渲染的演进\" class=\"headerlink\" title=\"1.2.2 Android 渲染的演进\"></a>1.2.2 Android 渲染的演进</h4><h5 id=\"Android-图形系统整体架构\"><a href=\"#Android-图形系统整体架构\" class=\"headerlink\" title=\"Android 图形系统整体架构\"></a>Android 图形系统整体架构</h5><p><img src=\"android_graphic_system_arch.png\" title=\"Android图形系统整体架构\" width=\"60%\" height=\"50%\"></p>\n<ul>\n<li>画笔：Skia 或者 OpenGL</li>\n<li>画纸：Surface</li>\n<li>画板：Graphic Buffer</li>\n<li>显示：SurfaceFlinger</li>\n</ul>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://source.android.com/devices/graphics\" target=\"_blank\" rel=\"noopener\">Android图形系统整体架构</a></li>\n</ul>\n<h5 id=\"硬件加速绘制\"><a href=\"#硬件加速绘制\" class=\"headerlink\" title=\"硬件加速绘制\"></a>硬件加速绘制</h5><h6 id=\"Android-3-0-软件绘制\"><a href=\"#Android-3-0-软件绘制\" class=\"headerlink\" title=\"Android 3.0 软件绘制\"></a>Android 3.0 软件绘制</h6><p>在 Android 3.0 之前，或者没有启动硬件加速时，系统都会使用软件方式来渲染 UI。</p>\n<p>整个流程如上图所示： </p>\n<ul>\n<li>Surface。每个 View 都由某一个窗口管理，而每一个窗口都关联有一个 Surface。</li>\n<li>Canvas。通过 Surface 的 lock 函数获得一个 Canvas，Canvas 可以简单理解为 Skia 底层接口的封装。</li>\n<li>Graphic Buffer。SurfaceFlinger 会帮我们托管一个 BufferQueue，我们从 BufferQueue 中拿到 Graphic Buffer，然后通过 Canvas 以及 Skia 将绘制内容栅格化到上面。</li>\n<li>SurfaceFlinger。通过 Swap Buffer 把 Front Graphic Buffer 的内容交给 SurfaceFinger，最后硬件合成器 Hardware Composer 合成并输出到显示屏。</li>\n</ul>\n<h6 id=\"Android-4-0-开启硬件加速\"><a href=\"#Android-4-0-开启硬件加速\" class=\"headerlink\" title=\"Android 4.0 开启硬件加速\"></a>Android 4.0 开启硬件加速</h6><ul>\n<li>从 Androd 3.0 开始，Android 开始支持硬件加速，到 Android 4.0 时，，默认开启硬件加速。</li>\n</ul>\n<p><img src=\"soft_draw_android3.0.png\" title=\"Android3.0软件绘制\" width=\"60%\" height=\"50%\"></p>\n<p><img src=\"soft_draw_android4.0.png\" title=\"Android4.0+硬件加速\" width=\"60%\" height=\"50%\"></p>\n<p>硬件加速核心是通过 GPU 完成 Graphic Buffer 的内容绘制，此外硬件绘制还引入了一个 DisplayList 的概念，每个 View 内部都有一个 DisplayView，当某个 View 需要重绘时，将它标记为 Dirty，不需要像软件绘制向上递归，这样可以大大减少绘图的操作数量，提升渲染效率。</p>\n<p><img src=\"view_displaylist.png\" title=\"View的DisplayList局部刷新\" width=\"60%\" height=\"50%\"></p>\n<h5 id=\"Project-Butter-黄油计划\"><a href=\"#Project-Butter-黄油计划\" class=\"headerlink\" title=\"Project Butter 黄油计划\"></a>Project Butter 黄油计划</h5><p>Android 4.1：Project Butter 主要包含两个组成部分，一个是 VSYNC，一个是 Triple Buffering。</p>\n<p>VSYNC 信号</p>\n<p><img src=\"vsync_signal.png\" title=\"VSYNC信号\" width=\"60%\" height=\"50%\"></p>\n<p>三级缓冲机制 Triple Buffering</p>\n<p><img src=\"triple_buffering.png\" title=\"三级缓冲机制 Triple Buffering\" width=\"60%\" height=\"50%\"></p>\n<p>Jank渲染超时</p>\n<p><img src=\"display_jank.png\" title=\"Jank渲染超时\" width=\"60%\" height=\"50%\"></p>\n<h5 id=\"Android-5-0-RenderThread-异步渲染\"><a href=\"#Android-5-0-RenderThread-异步渲染\" class=\"headerlink\" title=\"Android 5.0: RenderThread 异步渲染\"></a>Android 5.0: RenderThread 异步渲染</h5><p><img src=\"display_renderthread.png\" title=\"RenderThread工作\" width=\"60%\" height=\"50%\"></p>\n<h5 id=\"数据测量\"><a href=\"#数据测量\" class=\"headerlink\" title=\"数据测量\"></a>数据测量</h5><ul>\n<li>绘制过度工具</li>\n</ul>\n<p>在 Android 4.2，系统增加了检测绘制过度工具。</p>\n<p><img src=\"overdraw_tools.png\" title=\"检测绘制过度工具\" width=\"50%\" height=\"50%\"></p>\n<p>参考资料：<a href=\"https://developer.android.com/studio/profile/inspect-gpu-rendering\" target=\"_blank\" rel=\"noopener\">检查 GPU 渲染进度和绘制过度</a></p>\n<h5 id=\"未来\"><a href=\"#未来\" class=\"headerlink\" title=\"未来\"></a>未来</h5><p>在 Android 6.0 的时候，Android 在 gxinfo 添加了更详细的信息；在 Android 7.0 又对 HWUI 进行了一些重构，而且支持了 Vulkan；在 Android P 支持了 Vulkun 1.1。相信在未来不久的 Android Q，更好地支持 Vulkan 将是一个必然的方向。</p>\n<p>总的来说，UI 渲染的优化必然会朝着两个方向。一个是进一步压榨硬件的性能，让 UI 可以更加流畅。一个是改进或者增加更多的分析工具，帮助我们更容易地发现以及定位问题。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>虽然硬件加速绘制极大提高了 Android 系统显示和刷新的速度，但它也存在一些问题，一方面是内存消耗，另一方面是兼容性问题，部分绘制函数不支持，更可怕的是硬件加速绘制流程本身存在 Bug。</p>\n<h4 id=\"1-2-3-如何优化-UI-渲染？\"><a href=\"#1-2-3-如何优化-UI-渲染？\" class=\"headerlink\" title=\"1.2.3 如何优化 UI 渲染？\"></a>1.2.3 如何优化 UI 渲染？</h4><h5 id=\"adb-命令\"><a href=\"#adb-命令\" class=\"headerlink\" title=\"adb 命令\"></a>adb 命令</h5><ul>\n<li>gfxinfo，可以输出包含各阶段发生的动画以及帧相关的性能信息</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 渲染相关的内存和 View hierarchy 信息</span><br><span class=\"line\">adb shell dumpsys gfxinfo 包名</span><br><span class=\"line\"></span><br><span class=\"line\">// 拿到最近 120 帧每个绘制阶段的耗时信息</span><br><span class=\"line\">adb shell dumpsys gfxinfo 包名 framestats</span><br></pre></td></tr></table></figure>\n<ul>\n<li>SurfaceFlinger</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看 Graphic Buffer 占用的内存</span><br><span class=\"line\">adb shell dumpsys SurfaceFlinger</span><br></pre></td></tr></table></figure>\n<h5 id=\"UI-优化常用手段\"><a href=\"#UI-优化常用手段\" class=\"headerlink\" title=\"UI 优化常用手段\"></a>UI 优化常用手段</h5><p><img src=\"ui_display_flow.png\" title=\"UI 渲染阶段流程图\" width=\"60%\" height=\"50%\"></p>\n<h6 id=\"尽量使用硬件加速\"><a href=\"#尽量使用硬件加速\" class=\"headerlink\" title=\"尽量使用硬件加速\"></a>尽量使用硬件加速</h6><p>如果使用了不支持的 API，系统就需要通过 CPU 软件模拟绘制，这也是渐变、磨砂、圆角等效果渲染性能比较低的原因。</p>\n<p>SVG 是个典型的例子，SVG 有很多指令硬件加速都不支持，我们可以用一个取巧的方法，提前将这些 SVG 转换为 Bitmap 缓存起来，这样系统就可以更好地使用硬件加速绘制。同理，对于圆角、渐变等场景，我们也可以改为 Bitmap 实现。</p>\n<p>问题：如何提前生成 Bitmap，以及 Bitmap 的内存需要如何管理，可以参考市面上常用图片库的实现！</p>\n<h6 id=\"Create-View-优化\"><a href=\"#Create-View-优化\" class=\"headerlink\" title=\"Create View 优化\"></a>Create View 优化</h6><ul>\n<li>使用代码创建</li>\n</ul>\n<p>使用一些开源的 XML 转换为 Java 代码工具，例如 <a href=\"https://github.com/iReaderAndroid/X2C\" target=\"_blank\" rel=\"noopener\">X2C</a>。建议在一些修改不频繁的场景下使用这种方式。</p>\n<ul>\n<li>异步创建</li>\n</ul>\n<p>在线程提前创建 View，实现 UI 的预加载，在使用线程创建 UI 的时候，先把线程 Looper 的 MessageQueue 替换为 UI 线程 Looper 的 Queue，在创建完 View 后需要把线程 Looper 恢复成原来的。</p>\n<p><img src=\"async_create_view.png\" title=\"异步创建 View\" width=\"60%\" height=\"50%\"></p>\n<ul>\n<li>View 重用</li>\n</ul>\n<p>View 会随着 Activity 的销毁而销毁，ListView、RecyclerView 通过 view 的缓存与重用大大提升渲染性能，因此我们可以参考它们的思想，实现一套可以在不同 Activity 或 Fragment 使用的 View 缓存机制。注意：需要保证所有进入缓存池的 View 都是干净的，不会保留之前的状态。</p>\n<p><img src=\"view_reuse.png\" title=\"View 重用\" width=\"60%\" height=\"50%\"></p>\n<h6 id=\"measure-layout-优化\"><a href=\"#measure-layout-优化\" class=\"headerlink\" title=\"measure/layout 优化\"></a>measure/layout 优化</h6><ul>\n<li>减少 UI 布局层次</li>\n</ul>\n<p>尽量扁平化，使用<viewstub> <merge> 等优化。</merge></viewstub></p>\n<ul>\n<li>优化 layout 开销</li>\n</ul>\n<p>尽量不用 RelativeLayout 或者基于 weighted LinearLayout，它们 layout 的开销非常巨大，推荐使用 ConstraintLayout 替代 RL 或者 weighted LL。</p>\n<ul>\n<li>背景优化</li>\n</ul>\n<p>尽量不要重复设置主题背景(Theme)，theme 默认会是一个纯色背景，如果我们自定义了界面的背景，那么主题的背景对我们来说是无用的，由于主题背景设置在 DecorView 中，所以这里会带来重复绘制，会带来绘制性能损耗。</p>\n<h5 id=\"UI-进阶优化\"><a href=\"#UI-进阶优化\" class=\"headerlink\" title=\"UI 进阶优化\"></a>UI 进阶优化</h5><h6 id=\"Litho-异步布局\"><a href=\"#Litho-异步布局\" class=\"headerlink\" title=\"Litho: 异步布局\"></a>Litho: 异步布局</h6><ul>\n<li>异步布局</li>\n</ul>\n<p>Android 主线程，measure -&gt; layout -&gt; draw </p>\n<p><img src=\"android_thread_model.png\" title=\"Android 主线程布局\" width=\"60%\" height=\"50%\"></p>\n<p>Litho异步布局</p>\n<p><img src=\"litho_thread_model.png\" title=\"Litho异步布局\" width=\"60%\" height=\"50%\"></p>\n<ul>\n<li>界面扁平化</li>\n</ul>\n<p><img src=\"layout_flat.png\" title=\"界面扁平化\" width=\"60%\" height=\"50%\"></p>\n<ul>\n<li>优化 RecyclerView</li>\n</ul>\n<p><img src=\"optimize_recyclerview.png\" title=\"优化RecyclerView\" width=\"60%\" height=\"50%\"></p>\n<p>Litho 优化了 RV 中 UI 组件的缓存和回收方法，原生 RV 或者 LV 都是按照 viewType 来进行缓存和回收，但如果一个 RV/LV 中出现了 viewType 过多，会是缓存形同虚设，Litho 是按照 text、image 和 video 独立回收，可以提高缓存命中率、降低内存使用率、提高滚动帧率。</p>\n<p>缺点：Litho 实现了 measure/layout 异步化，使用了类似 react 单向数据流设计，一定程度上加大了 UI 开发的复杂度，并且 Litho 的 UI 代码是使用 java/kotlin 进行编写，无法在 AS 中预览。</p>\n<h6 id=\"RenderThread-与-RenderScript\"><a href=\"#RenderThread-与-RenderScript\" class=\"headerlink\" title=\"RenderThread 与 RenderScript\"></a>RenderThread 与 RenderScript</h6><p>在 Android 5.0，系统增加了 RenderThread，对于 ViewPropertyAnimator 和 CircularReveal 动画，我们可以使用 <a href=\"https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&amp;mid=2247489230&amp;idx=1&amp;sn=adc193e35903ab90a4c966059933a35a&amp;source=41#wechat_redirect\" target=\"_blank\" rel=\"noopener\">RenderThread:异步渲染动画</a>，当主线程阻塞的时候，普通动画会出现明显的丢帧卡顿，而使用 RenderThread 渲染的动画即使阻塞了主线程仍不受影响。</p>\n<p>现在越来越多的应用会使用一些高级图片或者视频编辑功能，例如图片的高斯模糊、放大、锐化等。拿日常我们使用最多的“扫一扫”这个场景来看，这里涉及大量的图片变换操作，例如缩放、裁剪、二值化以及降噪等。</p>\n<p>图片的变换涉及大量的计算任务，这个时候使用 GPU 是更好的选择，那如何进一步压榨系统 GPU 的性能呢？</p>\n<p>我们可以通过<a href=\"https://developer.android.com/guide/topics/renderscript/compute\" target=\"_blank\" rel=\"noopener\">RenderScript</a>，它是 Android 操作系统上的一套 API。它基于异构计算思想，专门用于密集型计算。</p>\n<h6 id=\"Flutter-自己的布局-渲染引擎\"><a href=\"#Flutter-自己的布局-渲染引擎\" class=\"headerlink\" title=\"Flutter: 自己的布局 + 渲染引擎\"></a>Flutter: 自己的布局 + 渲染引擎</h6><p><img src=\"flutter_render_engine.png\" title=\"Flutter 渲染流程\" width=\"60%\" height=\"50%\"></p>\n<h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><ol>\n<li>在系统的框架下优化。布局优化、使用代码创建、View 缓存等都思路，减少甚至省下渲染流水线里某个阶段的耗时。</li>\n<li>利用系统的新特性。使用硬件加速、RenderThread、RenderScript 等，通过系统一些新的特性，最大限度压榨出性能。</li>\n<li>突破系统的限制，Android 碎片化很严重，很多好的特性可能低版本系统并不支持，一些特定的场景下它无法实现最优解。这时候，就要突破系统的条条框框，例如 Facebook-Litho 突破了布局渲染过程，Flutter 更近一步，把渲染都接管过来。</li>\n</ol>\n<blockquote>\n<p>在 UI 优化时，第一阶段的优化在系统的束缚下也可以达到非常不错的效果。不过越到后面越容易出现瓶颈，这时就需要进一步往底层走，可以对整个架构有更大的掌控力，需要造自己的「轮子」！</p>\n</blockquote>\n<h2 id=\"二、Android-卡顿排查工具\"><a href=\"#二、Android-卡顿排查工具\" class=\"headerlink\" title=\"二、Android 卡顿排查工具\"></a>二、Android 卡顿排查工具</h2><h3 id=\"2-1-Traceview\"><a href=\"#2-1-Traceview\" class=\"headerlink\" title=\"2.1 Traceview\"></a>2.1 Traceview</h3><p>利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中。可监控 Android framework、java、应用程序代码。</p>\n<p>在 Android 5.0 之后，新增了 startMethodTracingSampling 方法，可以使用基于样本的方式进行分析，以减少对运行时的性能影响。新增了 sample 类型后，就需要我们在开销和信息丰富度之间做好权衡。</p>\n<p>TraceView 的生成</p>\n<ol>\n<li>代码调用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 生成traceView的起点，保存traceView的名称（路径：/mnt/sdcard/fileName）</span></span><br><span class=\"line\">    Debug.startMethodTracing(<span class=\"string\">\"fileName\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Debug.stopMethodTracing();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<center class=\"half\"><br>    <img src=\"ddms_traceview_setting.jpg\" width=\"50%\"><br>    <img src=\"ddms_traceview_result.jpg\" width=\"50%\"><br></center>\n\n\n<p>缺点：工具本身带来的性能开销过大，有时候无法真实反映情况，比如一个函数本身的耗时是 1 秒，开启 TraceView 后可能变成 5 秒，而且这些函数的耗时变化并不是成比例放大。</p>\n<ol start=\"2\">\n<li>DDMS</li>\n</ol>\n<p>Android Device Monitor(DDMS)，选择进程 attached，点击trace 开始，操作app, trace 结束，分析结果。</p>\n<p>ps：DDMS 可通过命令 monitor 直接打开，目录在 /sdk/tools 下。</p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/7e9ca2c73c97\" target=\"_blank\" rel=\"noopener\">Android性能优化—TraceView的使用</a></li>\n<li><a href=\"https://www.oschina.net/news/56500/traceview-android\" target=\"_blank\" rel=\"noopener\">正确使用 Android 性能分析工具——TraceView</a></li>\n</ul>\n<h3 id=\"2-2-systrace\"><a href=\"#2-2-systrace\" class=\"headerlink\" title=\"2.2 systrace\"></a>2.2 systrace</h3><p>Android 4.1 新增的性能分析工具，经常使用 systrace 来跟踪系统的 I/O 操作、CPU 负载、Surface 渲染、GC 等事件。</p>\n<p>系统预留接口来监控应用程序的调用耗时，可以在可疑引起 jank 代码的地方，添加如下代码，这两个是成对出现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Trace.beginSection(<span class=\"string\">\"tag\"</span>);</span><br><span class=\"line\">Trace.endSection();</span><br></pre></td></tr></table></figure>\n<p><img src=\"systrace_demo_code.jpg\" title=\"Trace演示代码\" width=\"60%\" height=\"50%\"></p>\n<p><img src=\"systrace_result.jpg\" title=\"systrace使用演示\" width=\"60%\" height=\"50%\"></p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/blogs-of-lxl/p/10926824.html\" target=\"_blank\" rel=\"noopener\">Android：通过systrace进行性能分析</a></li>\n<li><a href=\"https://www.jianshu.com/p/75aa88d1b575\" target=\"_blank\" rel=\"noopener\">Android Systrace 使用方法</a></li>\n<li><a href=\"http://ddrv.cn/a/89930/\" target=\"_blank\" rel=\"noopener\">Android Systrace的使用和分析</a></li>\n<li><a href=\"https://www.jianshu.com/p/e9e05ce5b0c9\" target=\"_blank\" rel=\"noopener\">在Android Studio下使用Hierarchy Viewer</a></li>\n</ul>\n<p>怎样在 systrace 上面自动增加应用程序的耗时分析呢？</p>\n<blockquote>\n<p>编译时给每个函数插桩的方式来实现，在重要函数的入口和出口分别增加 Trace 代码，实现在 systrace 基础上增加应用程序耗时的监控。</p>\n</blockquote>\n<h3 id=\"2-3-AS-Profiler\"><a href=\"#2-3-AS-Profiler\" class=\"headerlink\" title=\"2.3 AS-Profiler\"></a>2.3 AS-Profiler</h3><p>Android Studio 自带 Profiler 工具，可以检测 CPU、memory等，点击 View -&gt; Tool Window -&gt; Profiler 打开工具使用。</p>\n<p><img src=\"as_profiler.jpg\" title=\"AS-Profiler\" width=\"60%\" height=\"50%\"></p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://developer.android.com/studio/profile/android-profiler?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">利用 Android Profiler 测量应用性能</a></li>\n<li><a href=\"https://www.jianshu.com/p/e75680772375\" target=\"_blank\" rel=\"noopener\">Android Studio 3.0 Memory Profiler使用\n</a></li>\n</ul>\n<h3 id=\"2-4-Simpleperf\"><a href=\"#2-4-Simpleperf\" class=\"headerlink\" title=\"2.4 Simpleperf\"></a>2.4 Simpleperf</h3><p>Android 5.0 新增了 Simpleperf 性能分析工具，分析 Native 函数的调用，它利用 CPU 的性能监控单元 （PMU）提供的硬件 perf 事件，使用 Simpleperf 可以看到所有的 Native 代码的耗时，有时候一些 Android 系统库的调用对分析问题有比较大的帮助，例如加载 dex、verify class 的耗时等。</p>\n<p>Simpleperf 同时封装了 systrace 的监控功能，现在 Simpleperf 比较友好地支持 Java 代码的性能分析。</p>\n<h3 id=\"其它-Nanoscope\"><a href=\"#其它-Nanoscope\" class=\"headerlink\" title=\"其它 Nanoscope\"></a>其它 Nanoscope</h3><p>Uber 开源的 <a href=\"http://github.com/uber/nanoscope\" target=\"_blank\" rel=\"noopener\">Nanoscope</a>，直接修改 Android 虚拟机源码，在 ArtMethod 执行入口和执行结束位置新增埋点代码，将所有的信息先写到内存，等到 trace 结束后才统一生成结果文件。需要刷入 ROM。</p>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>汇总一下，如果需要分析 Native 代码的耗时，可以选择 Simpleperf；如果想分析系统调用，可以选择 systrace；如果想分析整个程序执行流程的耗时，可以选择 TraceView 或者插桩版本的 systrace。</p>\n<h2 id=\"三、监控应用卡顿实践\"><a href=\"#三、监控应用卡顿实践\" class=\"headerlink\" title=\"三、监控应用卡顿实践\"></a>三、监控应用卡顿实践</h2><h3 id=\"3-1-监控主线程原理\"><a href=\"#3-1-监控主线程原理\" class=\"headerlink\" title=\"3.1 监控主线程原理\"></a>3.1 监控主线程原理</h3><ul>\n<li>消息队列</li>\n</ul>\n<p>依赖主线程 Looper，监控每次 dispatchMessage 的执行耗时。（BlockCanary）</p>\n<p>Looper#loop 代码片段</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class=\"line\">        Printer logging = me.mLogging;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +</span><br><span class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.target.dispatchMessage(msg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主线程所有执行的任务都在 dispatchMessage 方法中派发执行完成，我们通过 setMessageLogging 的方式给主线程的 Looper 设置一个 Printer ，因为 dispatchMessage 执行前后都会打印对应信息，在执行前利用另外一条线程，通过 Thread#getStackTrace 接口，以轮询的方式获取主线程执行堆栈信息并记录起来，同时统计每次 dispatchMessage 方法执行耗时，当超出阈值时，将该次获取的堆栈进行分析上报，从而来捕捉卡顿信息，否则丢弃此次记录的堆栈信息。</p>\n<ul>\n<li>Vsync 时间差</li>\n</ul>\n<p>依赖 Choreographer 模块，监控相邻两次 Vsync 事件通知的时间差。（ArgusAPM、LogMonitor）。</p>\n<p>利用系统 Choreographer 模块，向该模块注册一个 FrameCallback 监听对象，同时通过另外一条线程循环记录主线程堆栈信息，并在每次 Vsync 事件 doFrame 通知回来时，循环注册该监听对象，间接统计两次 Vsync 事件的时间间隔，当超出阈值时，取出记录的堆栈进行分析上报。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Choreographer.getInstance().postFrameCallback(<span class=\"keyword\">new</span> Choreographer.FrameCallback() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFrame</span><span class=\"params\">(<span class=\"keyword\">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(frameTimeNanos - mLastFrameNanos &gt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mLastFrameNanos = frameTimeNanos;</span><br><span class=\"line\">        Choreographer.getInstance().postFrameCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这两种方案，可以较方便的捕捉到卡顿的堆栈，但其最大的不足在于，无法获取到各个函数的执行耗时，对于稍微复杂一点的堆栈，很难找出可能耗时的函数，也就很难找到卡顿的原因。另外，通过其他线程循环获取主线程的堆栈，如果稍微处理不及时，很容易导致获取的堆栈有所偏移，不够准确，加上没有耗时信息，卡顿也就不好定位。</p>\n<p>所以我们希望寻求一种可以在线上准确地捕捉卡顿堆栈，又能计算出各个函数执行耗时的方案。 而要计算函数的执行耗时，最关键的点在于如何对执行过程中的函数进行打点监控。</p>\n<h3 id=\"3-2-插桩\"><a href=\"#3-2-插桩\" class=\"headerlink\" title=\"3.2 插桩\"></a>3.2 插桩</h3><ul>\n<li><p>应用启动时，默认打开 Trace 功能（Debug.startMethodTracing），应用内所有函数在执行前后将会经过该函数（dalvik 上 dvmMethodTraceAdd 函数 或 art 上 Trace::LogMethodTraceEvent 函数）， 通过hack手段代理该函数，在每个执行方法前后进行打点记录。</p>\n</li>\n<li><p>修改字节码的方式，在编译期修改所有 class 文件中的函数字节码，对所有函数前后进行打点插桩。</p>\n</li>\n</ul>\n<p>第一种方案，最大的好处是能统计到包括系统函数在内的所有函数出入口，对代码或字节码不用做任何修改，所以对apk包的大小没有影响，但由于方式比较hack，在兼容性和安全性上存在一定的风险。</p>\n<p>第二种方案，利用 Java 字节码修改工具（如 BCEL、ASM、Javassis等），在编译期间收集所有生成的 class 文件，扫描文件内的方法指令进行统一的打点插桩，同样也可以高效的记录函数执行过程中的信息，相比第一种方案，除了无法统计系统内执行的函数，其它应用内实现的函数都可以覆盖到。而往往造成卡顿的函数并不是系统内执行的函数，一般都是我们应用开发实现的函数，所以这里无法统计系统内执行的函数对卡顿的定位影响不大。此方案无需 hook 任何函数，所以在兼容性方面会比第一个方案更可靠。</p>\n<p>在这考虑上，我们最终选择了修改字节码的方案，来实现 Matrix-TraceCannary 模块，解决其它方案中卡顿堆栈无耗时信息的主要问题，来帮助开发者发现及定位卡顿问题。</p>\n<p>参考链接：</p>\n<p><a href=\"https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary\" target=\"_blank\" rel=\"noopener\">Matrix Android TraceCanary</a></p>\n<h3 id=\"3-3-Profilo\"><a href=\"#3-3-Profilo\" class=\"headerlink\" title=\"3.3 Profilo\"></a>3.3 Profilo</h3><p>2018 年 3 月，Facebook 开源了一个 <a href=\"http://github.com/facebookincubator/profilo\" target=\"_blank\" rel=\"noopener\">Profilo</a> 库，它收集了各大方案的优点。</p>\n<ul>\n<li>集成了 atrace 功能，ftrace（Linux 的ftrace 调试工具，相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里添加了一些性能监控的埋点。Android 在 ftrace 基础上封装了 atrace，并增加了更多特有的探针，例如 Graphics、Activity Manager、Dalvik VM、System Server 等。），Profilo 通过 PLT Hook 拦截了写入操作，选择部分关心事件，例如四大组件生命周期、锁等待时间、类校验、GC 时间等。</li>\n<li>快速获取 Java 堆栈，拿到当前执行的 Thread，通过 Thread 对象获取当前线程的 ManagedStack，ManagedStack 是一个单链表，保存了当前的 ShadowFrame 或 QuickFrame 栈指针，它依次遍历 ManagedStack 链表，然后遍历内部的 ShadowFrame 或 QuickFrame 还原一个可读的调用栈，从而 unwind 出当前的 Java 堆栈。通过这种方式可以实现一边继续跑步，还可以帮它做检查，而且耗时基本忽略不计。</li>\n</ul>\n<h3 id=\"3-4-线程监控\"><a href=\"#3-4-线程监控\" class=\"headerlink\" title=\"3.4 线程监控\"></a>3.4 线程监控</h3><p>Java 线程管理是很多应用头疼的事情，应用启动就已经创建了十几上百个线程，而且大部分线程都没有经过线程池管理，都在自由的狂奔着。</p>\n<p>另一方面某些线程优先级或者活跃度比较高，占用了过多的 CPU，这会降低主线程 UI 响应能力，需要特别针对这些线程做重点的优化。</p>\n<ul>\n<li><p>线程数量<br>监控线程数量的多少以及创建线程的方式，可通过 got hook 线程的 nativeCreate() 函数，用于进行线程收敛，也就是减少线程数量。</p>\n</li>\n<li><p>线程时间</p>\n</li>\n</ul>\n<p>监控线程用户时间 utime、系统时间 stime 和优先级，看哪些线程 utime + stime 比较多，占用了过多的 CPU，有可能有一些线程因为生命周期很短导致很难发现，这里我们需要结合线程创建监控。</p>\n<h3 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>导致卡顿问题很多，比如函数非常耗时、I/O 非常慢、线程间锁竞争或者锁等待等，其实很多时候卡顿问题并不难解决，比较困难的是如何快速发现这些卡顿点，以及更多的辅助信息找到真正的卡顿原因，还原卡顿现场。</p>\n<h2 id=\"四、向日葵工作台页面帧率情况\"><a href=\"#四、向日葵工作台页面帧率情况\" class=\"headerlink\" title=\"四、向日葵工作台页面帧率情况\"></a>四、向日葵工作台页面帧率情况</h2><p><img src=\"xrk_homepage.png\" title=\"FPS悬浮窗检测\" width=\"30%\" height=\"30%\"></p>\n<blockquote>\n<p>演示工作台检测 trace.html 文件！</p>\n</blockquote>\n<h2 id=\"五、卡顿优化计划\"><a href=\"#五、卡顿优化计划\" class=\"headerlink\" title=\"五、卡顿优化计划\"></a>五、卡顿优化计划</h2><h3 id=\"5-1-常见卡顿场景\"><a href=\"#5-1-常见卡顿场景\" class=\"headerlink\" title=\"5.1 常见卡顿场景\"></a>5.1 常见卡顿场景</h3><ul>\n<li>布局嵌套层次太深，可以使用 merge、viewStub、include 来优化</li>\n<li>onDraw() 里面循环创建了大量临时变量，频繁触发 GC</li>\n<li>主线程等待优先级子线程问题（锁同步问题）</li>\n<li>主线程执行耗时操作，阻塞主线程执行（同步读写文件，DB 操作）</li>\n</ul>\n<h3 id=\"5-2-卡顿排查思路\"><a href=\"#5-2-卡顿排查思路\" class=\"headerlink\" title=\"5.2 卡顿排查思路\"></a>5.2 卡顿排查思路</h3><ul>\n<li>显示页面实时 FPS 帧率，帮助查看流畅度（UI 优化，参见上述方法）</li>\n<li>慢函数堆栈显示，当发生卡顿时，可以显示具体哪个函数哪行代码造成的卡顿</li>\n<li>线程监控，监控全局线程创建</li>\n</ul>\n<h2 id=\"六、参考\"><a href=\"#六、参考\" class=\"headerlink\" title=\"六、参考\"></a>六、参考</h2><ul>\n<li><a href=\"https://time.geekbang.org/column/article/71982\" target=\"_blank\" rel=\"noopener\">Android 开发高手课-卡顿优化</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/80921\" target=\"_blank\" rel=\"noopener\">Android 开发高手课-渲染优化</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2OTQxMTM4OQ==&amp;mid=2247490024&amp;idx=2&amp;sn=3b8a42d0e9aae286984c03a5ac0b3389&amp;chksm=eae1ecbadd9665ace47c2ce20487852a38dfe3735a0ee74d38096af7f7d38c862373a83e90a9\" target=\"_blank\" rel=\"noopener\">不敢相信？System.currentTimeMillis() 居然存在性能问题</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>对用户来说，内存占用高、耗费电量、耗费流量可能不容易被发现，但是对于卡顿特别敏感，尤其在某些时候出现高频掉帧，俗称冻帧。对于开发者来说，卡顿问题非常难以排查定位，其产生的原因错综复杂，跟用户当前手机的 CPU、内存、磁盘 I/O 等环境都可能有关系。所以，到底如何该定义卡顿？在我们平时开发又有哪些工具可以帮助开发更好的发现和排查问题？在线上又该监控卡顿情况呢？下面我们来一一解决这些困惑。</p>","more":"<h2 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h2><h3 id=\"1-1-CPU-时间\"><a href=\"#1-1-CPU-时间\" class=\"headerlink\" title=\"1.1 CPU 时间\"></a>1.1 CPU 时间</h3><p>造成卡顿的原因可能有千百种，不过最终都会反映到 CPU 时间上，我们可以把 CPU 时间分为两种：用户时间和系统时间。用户时间就是执行用户态应用程序代码所消耗的时间；系统时间是执行内核态系统调用所消耗的时间，包括 I/O、锁、中断以及其他系统调用的时间。</p>\n<p>评价一个 CPU 的性能，需要看主频、核心数、缓存等参数。</p>\n<p>获取设备的 CPU 信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取 CPU 核心数</span><br><span class=\"line\">cat /sys/devices/system/cpu/possible</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取某个 CPU 的频率</span><br><span class=\"line\">cat /sys/devices/system/cpu/cpu0/cpufeq/cpuinfo_max_freq</span><br></pre></td></tr></table></figure>\n<p><img src=\"pc_cpu_info.jpg\" title=\"CPU信息\" width=\"60%\" height=\"50%\"></p>\n<p>当出现卡顿问题的时候，怎么去区分究竟是我们代码的问题，还是系统的问题？用户时间和系统时间可以给我们哪些线索？这里需要两个非常重要的指标帮助我们做判断。</p>\n<ul>\n<li>CPU 的使用率</li>\n</ul>\n<p>可以通过 /proc/stat 得到整个系统的 CPU 使用情况，通过 /proc/[pid]/stat 可以得到某个进程的 CPU 使用情况。</p>\n<p><img src=\"pc_cpu_usage.jpg\" title=\"CPU 使用率\" width=\"60%\" height=\"50%\"></p>\n<p><img src=\"xrk_process_cpu.jpg\" title=\"向日葵进程CPU使用率\" width=\"60%\" height=\"50%\"></p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"http://www.samirchen.com/linux-cpu-performance/\" target=\"_blank\" rel=\"noopener\">《Linux 环境下进程的CPU 占有率》</a></li>\n<li><a href=\"http://man7.org/linux/man-pages/man5/proc.5.html\" target=\"_blank\" rel=\"noopener\">Linux 文档</a></li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令 </span><br><span class=\"line\">    </span><br><span class=\"line\">* top 命令</span><br><span class=\"line\">帮助查看哪个进程是 CPU 的消耗大户</span><br><span class=\"line\">    </span><br><span class=\"line\">* vmstat 命令</span><br><span class=\"line\">可以实时监控操作系统的虚拟内存和 CPU 活动；</span><br><span class=\"line\">    </span><br><span class=\"line\">* strace 命令</span><br><span class=\"line\">    </span><br><span class=\"line\">可以跟踪某个进程中所有的系统调用</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CPU 饱和度</li>\n</ul>\n<p>CPU 饱和度反映的是线程排队等待 CPU 的情况，也就是 CPU 的负载情况。CPU 饱和度会跟应用的线程数有关，如果启动线程过多，容易导致系统不断地切换执行的线程，把大量的时间浪费在上下文切换，每次 CPU 上下文切换都需要刷新寄存器和计数器，至少需要十几纳秒的时间。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令</span><br><span class=\"line\">    </span><br><span class=\"line\">* vmstat 命令或者 /proc/[pid]/schedstat 文件</span><br><span class=\"line\"></span><br><span class=\"line\">查看 CPU 上下文切换次数，需要特别注意 nr_involuntary_switches 被动切换的次数。</span><br><span class=\"line\">    </span><br><span class=\"line\">// TODO</span><br><span class=\"line\">    </span><br><span class=\"line\">* uptime 命令</span><br><span class=\"line\">查看 CPU 在1分钟、5分钟和15分钟内的平均负载，例如一个4核的 CPU，如果当前平均负载是 8，这意味着每个 CPU 上有一个线程在运行，还有一个线程在等待。一般平均负载建议控制在 0.7 x 核数 以内。</span><br><span class=\"line\">    </span><br><span class=\"line\">// TODO</span><br></pre></td></tr></table></figure>\n<p>线程优先级-nice 值越低，抢占 CPU 时间片的能力越强。</p>\n<h3 id=\"1-2-绘制原理\"><a href=\"#1-2-绘制原理\" class=\"headerlink\" title=\"1.2 绘制原理\"></a>1.2 绘制原理</h3><h4 id=\"1-2-1-UI-渲染背景知识\"><a href=\"#1-2-1-UI-渲染背景知识\" class=\"headerlink\" title=\"1.2.1 UI 渲染背景知识\"></a>1.2.1 UI 渲染背景知识</h4><h5 id=\"屏幕适配\"><a href=\"#屏幕适配\" class=\"headerlink\" title=\"屏幕适配\"></a>屏幕适配</h5><p>px、ppi、dpi、dp、density</p>\n<p><img src=\"screen_adaptation_table.png\" title=\"屏幕适配概念图\" width=\"60%\" height=\"50%\"></p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA\" target=\"_blank\" rel=\"noopener\">一种极低成本的 Android 屏幕适配方式-今日头条适配方案</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826381&amp;idx=1&amp;sn=5b71b7f1654b04a55fca25b0e90a4433&amp;chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">Android 目前稳定高效的 UI 适配方案-smallestWidth 限定符适配方案</a></li>\n</ul>\n<h5 id=\"CPU-与-GPU\"><a href=\"#CPU-与-GPU\" class=\"headerlink\" title=\"CPU 与 GPU\"></a>CPU 与 GPU</h5><p>UI 渲染依赖两个核心的硬件：CPU 与 GPU。UI 组件在绘制到屏幕之前，都需要经过 Rasterization（格栅化）操作，而格栅化操作是一个耗时操作。GPU(Graphic processing Unit)也就是图形处理器，它主要用于处理图形运算，可能帮助我们加快格栅化操作。</p>\n<p>软件绘制使用的是 Skia 库，它是一款能在低端机上呈现高质量的 2D 跨平台框架，类似 Chrome、Flutter 内部使用的都是 Skia 库。</p>\n<p><img src=\"cpu_and_gpu.png\" title=\"CPU&GPU\" width=\"60%\" height=\"50%\"></p>\n<h5 id=\"OpenGL-与-Vulkan\"><a href=\"#OpenGL-与-Vulkan\" class=\"headerlink\" title=\"OpenGL 与 Vulkan\"></a>OpenGL 与 Vulkan</h5><p>对于硬件绘制，通过调用 OpenGL ES 接口利用 GPU 完成绘制。<a href=\"https://developer.android.com/guide/topics/graphics/opengl\" target=\"_blank\" rel=\"noopener\">OpenGL</a> 是一个跨平台的图形 API，它为 2D/3D 图形处理硬件指定了标准软件接口，而 OpenGL ES 是 OpenGL 的子集，专为嵌入式设备设计。</p>\n<p>Android 7.0 把 <a href=\"https://www.khronos.org/opengles/\" target=\"_blank\" rel=\"noopener\">OpenGL ES</a> 升级到最新的 3.2 版本同时，还添加了对 <a href=\"https://developer.android.com/guide/topics/graphics/opengl\" target=\"_blank\" rel=\"noopener\">Vulkan</a>的支持，Vulkan 是用于高性能 3D 图形的低开销、跨平台 API。相比 OpenGL ES，Vulkan 在改善功耗、多核优化提升绘图调用上有着非常明显的优势。</p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.android.com/guide/topics/graphics/hardware-accel\" target=\"_blank\" rel=\"noopener\">官方硬件加速文档</a></li>\n</ul>\n<h4 id=\"1-2-2-Android-渲染的演进\"><a href=\"#1-2-2-Android-渲染的演进\" class=\"headerlink\" title=\"1.2.2 Android 渲染的演进\"></a>1.2.2 Android 渲染的演进</h4><h5 id=\"Android-图形系统整体架构\"><a href=\"#Android-图形系统整体架构\" class=\"headerlink\" title=\"Android 图形系统整体架构\"></a>Android 图形系统整体架构</h5><p><img src=\"android_graphic_system_arch.png\" title=\"Android图形系统整体架构\" width=\"60%\" height=\"50%\"></p>\n<ul>\n<li>画笔：Skia 或者 OpenGL</li>\n<li>画纸：Surface</li>\n<li>画板：Graphic Buffer</li>\n<li>显示：SurfaceFlinger</li>\n</ul>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://source.android.com/devices/graphics\" target=\"_blank\" rel=\"noopener\">Android图形系统整体架构</a></li>\n</ul>\n<h5 id=\"硬件加速绘制\"><a href=\"#硬件加速绘制\" class=\"headerlink\" title=\"硬件加速绘制\"></a>硬件加速绘制</h5><h6 id=\"Android-3-0-软件绘制\"><a href=\"#Android-3-0-软件绘制\" class=\"headerlink\" title=\"Android 3.0 软件绘制\"></a>Android 3.0 软件绘制</h6><p>在 Android 3.0 之前，或者没有启动硬件加速时，系统都会使用软件方式来渲染 UI。</p>\n<p>整个流程如上图所示： </p>\n<ul>\n<li>Surface。每个 View 都由某一个窗口管理，而每一个窗口都关联有一个 Surface。</li>\n<li>Canvas。通过 Surface 的 lock 函数获得一个 Canvas，Canvas 可以简单理解为 Skia 底层接口的封装。</li>\n<li>Graphic Buffer。SurfaceFlinger 会帮我们托管一个 BufferQueue，我们从 BufferQueue 中拿到 Graphic Buffer，然后通过 Canvas 以及 Skia 将绘制内容栅格化到上面。</li>\n<li>SurfaceFlinger。通过 Swap Buffer 把 Front Graphic Buffer 的内容交给 SurfaceFinger，最后硬件合成器 Hardware Composer 合成并输出到显示屏。</li>\n</ul>\n<h6 id=\"Android-4-0-开启硬件加速\"><a href=\"#Android-4-0-开启硬件加速\" class=\"headerlink\" title=\"Android 4.0 开启硬件加速\"></a>Android 4.0 开启硬件加速</h6><ul>\n<li>从 Androd 3.0 开始，Android 开始支持硬件加速，到 Android 4.0 时，，默认开启硬件加速。</li>\n</ul>\n<p><img src=\"soft_draw_android3.0.png\" title=\"Android3.0软件绘制\" width=\"60%\" height=\"50%\"></p>\n<p><img src=\"soft_draw_android4.0.png\" title=\"Android4.0+硬件加速\" width=\"60%\" height=\"50%\"></p>\n<p>硬件加速核心是通过 GPU 完成 Graphic Buffer 的内容绘制，此外硬件绘制还引入了一个 DisplayList 的概念，每个 View 内部都有一个 DisplayView，当某个 View 需要重绘时，将它标记为 Dirty，不需要像软件绘制向上递归，这样可以大大减少绘图的操作数量，提升渲染效率。</p>\n<p><img src=\"view_displaylist.png\" title=\"View的DisplayList局部刷新\" width=\"60%\" height=\"50%\"></p>\n<h5 id=\"Project-Butter-黄油计划\"><a href=\"#Project-Butter-黄油计划\" class=\"headerlink\" title=\"Project Butter 黄油计划\"></a>Project Butter 黄油计划</h5><p>Android 4.1：Project Butter 主要包含两个组成部分，一个是 VSYNC，一个是 Triple Buffering。</p>\n<p>VSYNC 信号</p>\n<p><img src=\"vsync_signal.png\" title=\"VSYNC信号\" width=\"60%\" height=\"50%\"></p>\n<p>三级缓冲机制 Triple Buffering</p>\n<p><img src=\"triple_buffering.png\" title=\"三级缓冲机制 Triple Buffering\" width=\"60%\" height=\"50%\"></p>\n<p>Jank渲染超时</p>\n<p><img src=\"display_jank.png\" title=\"Jank渲染超时\" width=\"60%\" height=\"50%\"></p>\n<h5 id=\"Android-5-0-RenderThread-异步渲染\"><a href=\"#Android-5-0-RenderThread-异步渲染\" class=\"headerlink\" title=\"Android 5.0: RenderThread 异步渲染\"></a>Android 5.0: RenderThread 异步渲染</h5><p><img src=\"display_renderthread.png\" title=\"RenderThread工作\" width=\"60%\" height=\"50%\"></p>\n<h5 id=\"数据测量\"><a href=\"#数据测量\" class=\"headerlink\" title=\"数据测量\"></a>数据测量</h5><ul>\n<li>绘制过度工具</li>\n</ul>\n<p>在 Android 4.2，系统增加了检测绘制过度工具。</p>\n<p><img src=\"overdraw_tools.png\" title=\"检测绘制过度工具\" width=\"50%\" height=\"50%\"></p>\n<p>参考资料：<a href=\"https://developer.android.com/studio/profile/inspect-gpu-rendering\" target=\"_blank\" rel=\"noopener\">检查 GPU 渲染进度和绘制过度</a></p>\n<h5 id=\"未来\"><a href=\"#未来\" class=\"headerlink\" title=\"未来\"></a>未来</h5><p>在 Android 6.0 的时候，Android 在 gxinfo 添加了更详细的信息；在 Android 7.0 又对 HWUI 进行了一些重构，而且支持了 Vulkan；在 Android P 支持了 Vulkun 1.1。相信在未来不久的 Android Q，更好地支持 Vulkan 将是一个必然的方向。</p>\n<p>总的来说，UI 渲染的优化必然会朝着两个方向。一个是进一步压榨硬件的性能，让 UI 可以更加流畅。一个是改进或者增加更多的分析工具，帮助我们更容易地发现以及定位问题。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>虽然硬件加速绘制极大提高了 Android 系统显示和刷新的速度，但它也存在一些问题，一方面是内存消耗，另一方面是兼容性问题，部分绘制函数不支持，更可怕的是硬件加速绘制流程本身存在 Bug。</p>\n<h4 id=\"1-2-3-如何优化-UI-渲染？\"><a href=\"#1-2-3-如何优化-UI-渲染？\" class=\"headerlink\" title=\"1.2.3 如何优化 UI 渲染？\"></a>1.2.3 如何优化 UI 渲染？</h4><h5 id=\"adb-命令\"><a href=\"#adb-命令\" class=\"headerlink\" title=\"adb 命令\"></a>adb 命令</h5><ul>\n<li>gfxinfo，可以输出包含各阶段发生的动画以及帧相关的性能信息</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 渲染相关的内存和 View hierarchy 信息</span><br><span class=\"line\">adb shell dumpsys gfxinfo 包名</span><br><span class=\"line\"></span><br><span class=\"line\">// 拿到最近 120 帧每个绘制阶段的耗时信息</span><br><span class=\"line\">adb shell dumpsys gfxinfo 包名 framestats</span><br></pre></td></tr></table></figure>\n<ul>\n<li>SurfaceFlinger</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看 Graphic Buffer 占用的内存</span><br><span class=\"line\">adb shell dumpsys SurfaceFlinger</span><br></pre></td></tr></table></figure>\n<h5 id=\"UI-优化常用手段\"><a href=\"#UI-优化常用手段\" class=\"headerlink\" title=\"UI 优化常用手段\"></a>UI 优化常用手段</h5><p><img src=\"ui_display_flow.png\" title=\"UI 渲染阶段流程图\" width=\"60%\" height=\"50%\"></p>\n<h6 id=\"尽量使用硬件加速\"><a href=\"#尽量使用硬件加速\" class=\"headerlink\" title=\"尽量使用硬件加速\"></a>尽量使用硬件加速</h6><p>如果使用了不支持的 API，系统就需要通过 CPU 软件模拟绘制，这也是渐变、磨砂、圆角等效果渲染性能比较低的原因。</p>\n<p>SVG 是个典型的例子，SVG 有很多指令硬件加速都不支持，我们可以用一个取巧的方法，提前将这些 SVG 转换为 Bitmap 缓存起来，这样系统就可以更好地使用硬件加速绘制。同理，对于圆角、渐变等场景，我们也可以改为 Bitmap 实现。</p>\n<p>问题：如何提前生成 Bitmap，以及 Bitmap 的内存需要如何管理，可以参考市面上常用图片库的实现！</p>\n<h6 id=\"Create-View-优化\"><a href=\"#Create-View-优化\" class=\"headerlink\" title=\"Create View 优化\"></a>Create View 优化</h6><ul>\n<li>使用代码创建</li>\n</ul>\n<p>使用一些开源的 XML 转换为 Java 代码工具，例如 <a href=\"https://github.com/iReaderAndroid/X2C\" target=\"_blank\" rel=\"noopener\">X2C</a>。建议在一些修改不频繁的场景下使用这种方式。</p>\n<ul>\n<li>异步创建</li>\n</ul>\n<p>在线程提前创建 View，实现 UI 的预加载，在使用线程创建 UI 的时候，先把线程 Looper 的 MessageQueue 替换为 UI 线程 Looper 的 Queue，在创建完 View 后需要把线程 Looper 恢复成原来的。</p>\n<p><img src=\"async_create_view.png\" title=\"异步创建 View\" width=\"60%\" height=\"50%\"></p>\n<ul>\n<li>View 重用</li>\n</ul>\n<p>View 会随着 Activity 的销毁而销毁，ListView、RecyclerView 通过 view 的缓存与重用大大提升渲染性能，因此我们可以参考它们的思想，实现一套可以在不同 Activity 或 Fragment 使用的 View 缓存机制。注意：需要保证所有进入缓存池的 View 都是干净的，不会保留之前的状态。</p>\n<p><img src=\"view_reuse.png\" title=\"View 重用\" width=\"60%\" height=\"50%\"></p>\n<h6 id=\"measure-layout-优化\"><a href=\"#measure-layout-优化\" class=\"headerlink\" title=\"measure/layout 优化\"></a>measure/layout 优化</h6><ul>\n<li>减少 UI 布局层次</li>\n</ul>\n<p>尽量扁平化，使用<viewstub> <merge> 等优化。</merge></viewstub></p>\n<ul>\n<li>优化 layout 开销</li>\n</ul>\n<p>尽量不用 RelativeLayout 或者基于 weighted LinearLayout，它们 layout 的开销非常巨大，推荐使用 ConstraintLayout 替代 RL 或者 weighted LL。</p>\n<ul>\n<li>背景优化</li>\n</ul>\n<p>尽量不要重复设置主题背景(Theme)，theme 默认会是一个纯色背景，如果我们自定义了界面的背景，那么主题的背景对我们来说是无用的，由于主题背景设置在 DecorView 中，所以这里会带来重复绘制，会带来绘制性能损耗。</p>\n<h5 id=\"UI-进阶优化\"><a href=\"#UI-进阶优化\" class=\"headerlink\" title=\"UI 进阶优化\"></a>UI 进阶优化</h5><h6 id=\"Litho-异步布局\"><a href=\"#Litho-异步布局\" class=\"headerlink\" title=\"Litho: 异步布局\"></a>Litho: 异步布局</h6><ul>\n<li>异步布局</li>\n</ul>\n<p>Android 主线程，measure -&gt; layout -&gt; draw </p>\n<p><img src=\"android_thread_model.png\" title=\"Android 主线程布局\" width=\"60%\" height=\"50%\"></p>\n<p>Litho异步布局</p>\n<p><img src=\"litho_thread_model.png\" title=\"Litho异步布局\" width=\"60%\" height=\"50%\"></p>\n<ul>\n<li>界面扁平化</li>\n</ul>\n<p><img src=\"layout_flat.png\" title=\"界面扁平化\" width=\"60%\" height=\"50%\"></p>\n<ul>\n<li>优化 RecyclerView</li>\n</ul>\n<p><img src=\"optimize_recyclerview.png\" title=\"优化RecyclerView\" width=\"60%\" height=\"50%\"></p>\n<p>Litho 优化了 RV 中 UI 组件的缓存和回收方法，原生 RV 或者 LV 都是按照 viewType 来进行缓存和回收，但如果一个 RV/LV 中出现了 viewType 过多，会是缓存形同虚设，Litho 是按照 text、image 和 video 独立回收，可以提高缓存命中率、降低内存使用率、提高滚动帧率。</p>\n<p>缺点：Litho 实现了 measure/layout 异步化，使用了类似 react 单向数据流设计，一定程度上加大了 UI 开发的复杂度，并且 Litho 的 UI 代码是使用 java/kotlin 进行编写，无法在 AS 中预览。</p>\n<h6 id=\"RenderThread-与-RenderScript\"><a href=\"#RenderThread-与-RenderScript\" class=\"headerlink\" title=\"RenderThread 与 RenderScript\"></a>RenderThread 与 RenderScript</h6><p>在 Android 5.0，系统增加了 RenderThread，对于 ViewPropertyAnimator 和 CircularReveal 动画，我们可以使用 <a href=\"https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&amp;mid=2247489230&amp;idx=1&amp;sn=adc193e35903ab90a4c966059933a35a&amp;source=41#wechat_redirect\" target=\"_blank\" rel=\"noopener\">RenderThread:异步渲染动画</a>，当主线程阻塞的时候，普通动画会出现明显的丢帧卡顿，而使用 RenderThread 渲染的动画即使阻塞了主线程仍不受影响。</p>\n<p>现在越来越多的应用会使用一些高级图片或者视频编辑功能，例如图片的高斯模糊、放大、锐化等。拿日常我们使用最多的“扫一扫”这个场景来看，这里涉及大量的图片变换操作，例如缩放、裁剪、二值化以及降噪等。</p>\n<p>图片的变换涉及大量的计算任务，这个时候使用 GPU 是更好的选择，那如何进一步压榨系统 GPU 的性能呢？</p>\n<p>我们可以通过<a href=\"https://developer.android.com/guide/topics/renderscript/compute\" target=\"_blank\" rel=\"noopener\">RenderScript</a>，它是 Android 操作系统上的一套 API。它基于异构计算思想，专门用于密集型计算。</p>\n<h6 id=\"Flutter-自己的布局-渲染引擎\"><a href=\"#Flutter-自己的布局-渲染引擎\" class=\"headerlink\" title=\"Flutter: 自己的布局 + 渲染引擎\"></a>Flutter: 自己的布局 + 渲染引擎</h6><p><img src=\"flutter_render_engine.png\" title=\"Flutter 渲染流程\" width=\"60%\" height=\"50%\"></p>\n<h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><ol>\n<li>在系统的框架下优化。布局优化、使用代码创建、View 缓存等都思路，减少甚至省下渲染流水线里某个阶段的耗时。</li>\n<li>利用系统的新特性。使用硬件加速、RenderThread、RenderScript 等，通过系统一些新的特性，最大限度压榨出性能。</li>\n<li>突破系统的限制，Android 碎片化很严重，很多好的特性可能低版本系统并不支持，一些特定的场景下它无法实现最优解。这时候，就要突破系统的条条框框，例如 Facebook-Litho 突破了布局渲染过程，Flutter 更近一步，把渲染都接管过来。</li>\n</ol>\n<blockquote>\n<p>在 UI 优化时，第一阶段的优化在系统的束缚下也可以达到非常不错的效果。不过越到后面越容易出现瓶颈，这时就需要进一步往底层走，可以对整个架构有更大的掌控力，需要造自己的「轮子」！</p>\n</blockquote>\n<h2 id=\"二、Android-卡顿排查工具\"><a href=\"#二、Android-卡顿排查工具\" class=\"headerlink\" title=\"二、Android 卡顿排查工具\"></a>二、Android 卡顿排查工具</h2><h3 id=\"2-1-Traceview\"><a href=\"#2-1-Traceview\" class=\"headerlink\" title=\"2.1 Traceview\"></a>2.1 Traceview</h3><p>利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中。可监控 Android framework、java、应用程序代码。</p>\n<p>在 Android 5.0 之后，新增了 startMethodTracingSampling 方法，可以使用基于样本的方式进行分析，以减少对运行时的性能影响。新增了 sample 类型后，就需要我们在开销和信息丰富度之间做好权衡。</p>\n<p>TraceView 的生成</p>\n<ol>\n<li>代码调用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 生成traceView的起点，保存traceView的名称（路径：/mnt/sdcard/fileName）</span></span><br><span class=\"line\">    Debug.startMethodTracing(<span class=\"string\">\"fileName\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Debug.stopMethodTracing();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<center class=\"half\"><br>    <img src=\"ddms_traceview_setting.jpg\" width=\"50%\"><br>    <img src=\"ddms_traceview_result.jpg\" width=\"50%\"><br></center>\n\n\n<p>缺点：工具本身带来的性能开销过大，有时候无法真实反映情况，比如一个函数本身的耗时是 1 秒，开启 TraceView 后可能变成 5 秒，而且这些函数的耗时变化并不是成比例放大。</p>\n<ol start=\"2\">\n<li>DDMS</li>\n</ol>\n<p>Android Device Monitor(DDMS)，选择进程 attached，点击trace 开始，操作app, trace 结束，分析结果。</p>\n<p>ps：DDMS 可通过命令 monitor 直接打开，目录在 /sdk/tools 下。</p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/7e9ca2c73c97\" target=\"_blank\" rel=\"noopener\">Android性能优化—TraceView的使用</a></li>\n<li><a href=\"https://www.oschina.net/news/56500/traceview-android\" target=\"_blank\" rel=\"noopener\">正确使用 Android 性能分析工具——TraceView</a></li>\n</ul>\n<h3 id=\"2-2-systrace\"><a href=\"#2-2-systrace\" class=\"headerlink\" title=\"2.2 systrace\"></a>2.2 systrace</h3><p>Android 4.1 新增的性能分析工具，经常使用 systrace 来跟踪系统的 I/O 操作、CPU 负载、Surface 渲染、GC 等事件。</p>\n<p>系统预留接口来监控应用程序的调用耗时，可以在可疑引起 jank 代码的地方，添加如下代码，这两个是成对出现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Trace.beginSection(<span class=\"string\">\"tag\"</span>);</span><br><span class=\"line\">Trace.endSection();</span><br></pre></td></tr></table></figure>\n<p><img src=\"systrace_demo_code.jpg\" title=\"Trace演示代码\" width=\"60%\" height=\"50%\"></p>\n<p><img src=\"systrace_result.jpg\" title=\"systrace使用演示\" width=\"60%\" height=\"50%\"></p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/blogs-of-lxl/p/10926824.html\" target=\"_blank\" rel=\"noopener\">Android：通过systrace进行性能分析</a></li>\n<li><a href=\"https://www.jianshu.com/p/75aa88d1b575\" target=\"_blank\" rel=\"noopener\">Android Systrace 使用方法</a></li>\n<li><a href=\"http://ddrv.cn/a/89930/\" target=\"_blank\" rel=\"noopener\">Android Systrace的使用和分析</a></li>\n<li><a href=\"https://www.jianshu.com/p/e9e05ce5b0c9\" target=\"_blank\" rel=\"noopener\">在Android Studio下使用Hierarchy Viewer</a></li>\n</ul>\n<p>怎样在 systrace 上面自动增加应用程序的耗时分析呢？</p>\n<blockquote>\n<p>编译时给每个函数插桩的方式来实现，在重要函数的入口和出口分别增加 Trace 代码，实现在 systrace 基础上增加应用程序耗时的监控。</p>\n</blockquote>\n<h3 id=\"2-3-AS-Profiler\"><a href=\"#2-3-AS-Profiler\" class=\"headerlink\" title=\"2.3 AS-Profiler\"></a>2.3 AS-Profiler</h3><p>Android Studio 自带 Profiler 工具，可以检测 CPU、memory等，点击 View -&gt; Tool Window -&gt; Profiler 打开工具使用。</p>\n<p><img src=\"as_profiler.jpg\" title=\"AS-Profiler\" width=\"60%\" height=\"50%\"></p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://developer.android.com/studio/profile/android-profiler?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">利用 Android Profiler 测量应用性能</a></li>\n<li><a href=\"https://www.jianshu.com/p/e75680772375\" target=\"_blank\" rel=\"noopener\">Android Studio 3.0 Memory Profiler使用\n</a></li>\n</ul>\n<h3 id=\"2-4-Simpleperf\"><a href=\"#2-4-Simpleperf\" class=\"headerlink\" title=\"2.4 Simpleperf\"></a>2.4 Simpleperf</h3><p>Android 5.0 新增了 Simpleperf 性能分析工具，分析 Native 函数的调用，它利用 CPU 的性能监控单元 （PMU）提供的硬件 perf 事件，使用 Simpleperf 可以看到所有的 Native 代码的耗时，有时候一些 Android 系统库的调用对分析问题有比较大的帮助，例如加载 dex、verify class 的耗时等。</p>\n<p>Simpleperf 同时封装了 systrace 的监控功能，现在 Simpleperf 比较友好地支持 Java 代码的性能分析。</p>\n<h3 id=\"其它-Nanoscope\"><a href=\"#其它-Nanoscope\" class=\"headerlink\" title=\"其它 Nanoscope\"></a>其它 Nanoscope</h3><p>Uber 开源的 <a href=\"http://github.com/uber/nanoscope\" target=\"_blank\" rel=\"noopener\">Nanoscope</a>，直接修改 Android 虚拟机源码，在 ArtMethod 执行入口和执行结束位置新增埋点代码，将所有的信息先写到内存，等到 trace 结束后才统一生成结果文件。需要刷入 ROM。</p>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>汇总一下，如果需要分析 Native 代码的耗时，可以选择 Simpleperf；如果想分析系统调用，可以选择 systrace；如果想分析整个程序执行流程的耗时，可以选择 TraceView 或者插桩版本的 systrace。</p>\n<h2 id=\"三、监控应用卡顿实践\"><a href=\"#三、监控应用卡顿实践\" class=\"headerlink\" title=\"三、监控应用卡顿实践\"></a>三、监控应用卡顿实践</h2><h3 id=\"3-1-监控主线程原理\"><a href=\"#3-1-监控主线程原理\" class=\"headerlink\" title=\"3.1 监控主线程原理\"></a>3.1 监控主线程原理</h3><ul>\n<li>消息队列</li>\n</ul>\n<p>依赖主线程 Looper，监控每次 dispatchMessage 的执行耗时。（BlockCanary）</p>\n<p>Looper#loop 代码片段</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class=\"line\">        Printer logging = me.mLogging;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +</span><br><span class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.target.dispatchMessage(msg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主线程所有执行的任务都在 dispatchMessage 方法中派发执行完成，我们通过 setMessageLogging 的方式给主线程的 Looper 设置一个 Printer ，因为 dispatchMessage 执行前后都会打印对应信息，在执行前利用另外一条线程，通过 Thread#getStackTrace 接口，以轮询的方式获取主线程执行堆栈信息并记录起来，同时统计每次 dispatchMessage 方法执行耗时，当超出阈值时，将该次获取的堆栈进行分析上报，从而来捕捉卡顿信息，否则丢弃此次记录的堆栈信息。</p>\n<ul>\n<li>Vsync 时间差</li>\n</ul>\n<p>依赖 Choreographer 模块，监控相邻两次 Vsync 事件通知的时间差。（ArgusAPM、LogMonitor）。</p>\n<p>利用系统 Choreographer 模块，向该模块注册一个 FrameCallback 监听对象，同时通过另外一条线程循环记录主线程堆栈信息，并在每次 Vsync 事件 doFrame 通知回来时，循环注册该监听对象，间接统计两次 Vsync 事件的时间间隔，当超出阈值时，取出记录的堆栈进行分析上报。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Choreographer.getInstance().postFrameCallback(<span class=\"keyword\">new</span> Choreographer.FrameCallback() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFrame</span><span class=\"params\">(<span class=\"keyword\">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(frameTimeNanos - mLastFrameNanos &gt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mLastFrameNanos = frameTimeNanos;</span><br><span class=\"line\">        Choreographer.getInstance().postFrameCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这两种方案，可以较方便的捕捉到卡顿的堆栈，但其最大的不足在于，无法获取到各个函数的执行耗时，对于稍微复杂一点的堆栈，很难找出可能耗时的函数，也就很难找到卡顿的原因。另外，通过其他线程循环获取主线程的堆栈，如果稍微处理不及时，很容易导致获取的堆栈有所偏移，不够准确，加上没有耗时信息，卡顿也就不好定位。</p>\n<p>所以我们希望寻求一种可以在线上准确地捕捉卡顿堆栈，又能计算出各个函数执行耗时的方案。 而要计算函数的执行耗时，最关键的点在于如何对执行过程中的函数进行打点监控。</p>\n<h3 id=\"3-2-插桩\"><a href=\"#3-2-插桩\" class=\"headerlink\" title=\"3.2 插桩\"></a>3.2 插桩</h3><ul>\n<li><p>应用启动时，默认打开 Trace 功能（Debug.startMethodTracing），应用内所有函数在执行前后将会经过该函数（dalvik 上 dvmMethodTraceAdd 函数 或 art 上 Trace::LogMethodTraceEvent 函数）， 通过hack手段代理该函数，在每个执行方法前后进行打点记录。</p>\n</li>\n<li><p>修改字节码的方式，在编译期修改所有 class 文件中的函数字节码，对所有函数前后进行打点插桩。</p>\n</li>\n</ul>\n<p>第一种方案，最大的好处是能统计到包括系统函数在内的所有函数出入口，对代码或字节码不用做任何修改，所以对apk包的大小没有影响，但由于方式比较hack，在兼容性和安全性上存在一定的风险。</p>\n<p>第二种方案，利用 Java 字节码修改工具（如 BCEL、ASM、Javassis等），在编译期间收集所有生成的 class 文件，扫描文件内的方法指令进行统一的打点插桩，同样也可以高效的记录函数执行过程中的信息，相比第一种方案，除了无法统计系统内执行的函数，其它应用内实现的函数都可以覆盖到。而往往造成卡顿的函数并不是系统内执行的函数，一般都是我们应用开发实现的函数，所以这里无法统计系统内执行的函数对卡顿的定位影响不大。此方案无需 hook 任何函数，所以在兼容性方面会比第一个方案更可靠。</p>\n<p>在这考虑上，我们最终选择了修改字节码的方案，来实现 Matrix-TraceCannary 模块，解决其它方案中卡顿堆栈无耗时信息的主要问题，来帮助开发者发现及定位卡顿问题。</p>\n<p>参考链接：</p>\n<p><a href=\"https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary\" target=\"_blank\" rel=\"noopener\">Matrix Android TraceCanary</a></p>\n<h3 id=\"3-3-Profilo\"><a href=\"#3-3-Profilo\" class=\"headerlink\" title=\"3.3 Profilo\"></a>3.3 Profilo</h3><p>2018 年 3 月，Facebook 开源了一个 <a href=\"http://github.com/facebookincubator/profilo\" target=\"_blank\" rel=\"noopener\">Profilo</a> 库，它收集了各大方案的优点。</p>\n<ul>\n<li>集成了 atrace 功能，ftrace（Linux 的ftrace 调试工具，相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里添加了一些性能监控的埋点。Android 在 ftrace 基础上封装了 atrace，并增加了更多特有的探针，例如 Graphics、Activity Manager、Dalvik VM、System Server 等。），Profilo 通过 PLT Hook 拦截了写入操作，选择部分关心事件，例如四大组件生命周期、锁等待时间、类校验、GC 时间等。</li>\n<li>快速获取 Java 堆栈，拿到当前执行的 Thread，通过 Thread 对象获取当前线程的 ManagedStack，ManagedStack 是一个单链表，保存了当前的 ShadowFrame 或 QuickFrame 栈指针，它依次遍历 ManagedStack 链表，然后遍历内部的 ShadowFrame 或 QuickFrame 还原一个可读的调用栈，从而 unwind 出当前的 Java 堆栈。通过这种方式可以实现一边继续跑步，还可以帮它做检查，而且耗时基本忽略不计。</li>\n</ul>\n<h3 id=\"3-4-线程监控\"><a href=\"#3-4-线程监控\" class=\"headerlink\" title=\"3.4 线程监控\"></a>3.4 线程监控</h3><p>Java 线程管理是很多应用头疼的事情，应用启动就已经创建了十几上百个线程，而且大部分线程都没有经过线程池管理，都在自由的狂奔着。</p>\n<p>另一方面某些线程优先级或者活跃度比较高，占用了过多的 CPU，这会降低主线程 UI 响应能力，需要特别针对这些线程做重点的优化。</p>\n<ul>\n<li><p>线程数量<br>监控线程数量的多少以及创建线程的方式，可通过 got hook 线程的 nativeCreate() 函数，用于进行线程收敛，也就是减少线程数量。</p>\n</li>\n<li><p>线程时间</p>\n</li>\n</ul>\n<p>监控线程用户时间 utime、系统时间 stime 和优先级，看哪些线程 utime + stime 比较多，占用了过多的 CPU，有可能有一些线程因为生命周期很短导致很难发现，这里我们需要结合线程创建监控。</p>\n<h3 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>导致卡顿问题很多，比如函数非常耗时、I/O 非常慢、线程间锁竞争或者锁等待等，其实很多时候卡顿问题并不难解决，比较困难的是如何快速发现这些卡顿点，以及更多的辅助信息找到真正的卡顿原因，还原卡顿现场。</p>\n<h2 id=\"四、向日葵工作台页面帧率情况\"><a href=\"#四、向日葵工作台页面帧率情况\" class=\"headerlink\" title=\"四、向日葵工作台页面帧率情况\"></a>四、向日葵工作台页面帧率情况</h2><p><img src=\"xrk_homepage.png\" title=\"FPS悬浮窗检测\" width=\"30%\" height=\"30%\"></p>\n<blockquote>\n<p>演示工作台检测 trace.html 文件！</p>\n</blockquote>\n<h2 id=\"五、卡顿优化计划\"><a href=\"#五、卡顿优化计划\" class=\"headerlink\" title=\"五、卡顿优化计划\"></a>五、卡顿优化计划</h2><h3 id=\"5-1-常见卡顿场景\"><a href=\"#5-1-常见卡顿场景\" class=\"headerlink\" title=\"5.1 常见卡顿场景\"></a>5.1 常见卡顿场景</h3><ul>\n<li>布局嵌套层次太深，可以使用 merge、viewStub、include 来优化</li>\n<li>onDraw() 里面循环创建了大量临时变量，频繁触发 GC</li>\n<li>主线程等待优先级子线程问题（锁同步问题）</li>\n<li>主线程执行耗时操作，阻塞主线程执行（同步读写文件，DB 操作）</li>\n</ul>\n<h3 id=\"5-2-卡顿排查思路\"><a href=\"#5-2-卡顿排查思路\" class=\"headerlink\" title=\"5.2 卡顿排查思路\"></a>5.2 卡顿排查思路</h3><ul>\n<li>显示页面实时 FPS 帧率，帮助查看流畅度（UI 优化，参见上述方法）</li>\n<li>慢函数堆栈显示，当发生卡顿时，可以显示具体哪个函数哪行代码造成的卡顿</li>\n<li>线程监控，监控全局线程创建</li>\n</ul>\n<h2 id=\"六、参考\"><a href=\"#六、参考\" class=\"headerlink\" title=\"六、参考\"></a>六、参考</h2><ul>\n<li><a href=\"https://time.geekbang.org/column/article/71982\" target=\"_blank\" rel=\"noopener\">Android 开发高手课-卡顿优化</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/80921\" target=\"_blank\" rel=\"noopener\">Android 开发高手课-渲染优化</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2OTQxMTM4OQ==&amp;mid=2247490024&amp;idx=2&amp;sn=3b8a42d0e9aae286984c03a5ac0b3389&amp;chksm=eae1ecbadd9665ace47c2ce20487852a38dfe3735a0ee74d38096af7f7d38c862373a83e90a9\" target=\"_blank\" rel=\"noopener\">不敢相信？System.currentTimeMillis() 居然存在性能问题</a></li>\n</ul>"},{"title":"我的2017年","date":"2018-01-02T13:33:39.000Z","_content":"\n![2017](http://opkjcw4sd.bkt.clouddn.com/2017.jpg)\n\n<!-- more -->\n\n> 时间过得好快，转眼间就2018年了，回顾2017年，好多事情还历历在目，有快乐，有收获，也有好多遗憾。。。\n\n## 目标\n2017开始设定的各种计划，有些完成了，有些没实现；写了10+博客，阅读了6+英文原著，学习了技术外的一些知识，对理财开始有了认识，没有学完Python，没有看人类简史等。\n\n## 写作\n今年开始写了些blog和公众号分享，虽然数量少的可怜，但也算是突破了一次自己，能沉淀下来一些东西，虽然很简单，以后再次翻阅会发现会很有意义；2018年希望自己能写出来更多的文章，记录发现和学到的新知识。\n\n## 阅读\n2017年陆陆续续关注了一些公众号和其他科技博客，原作对技术和生活分享认真的态度真心让我收获了不少，很感谢@stormzhang，@何俊林，@HenCoder，@傅盛，@北京GDG，@一个程序员的日常，@谷歌开发者，@湾区日报等等，很多就不一一列举了，特别感谢@stormzhang和@湾区日报，都是独立运营自己的账号，坚持原创和分享，收获了很多技术和超出技术的东西，十分感谢！我相信2018年我会关注更多有意思的科技和生活账号，同时也会和其他人一起分享自己的理解，结交更多的朋友。\n坚持了100+的薄荷阅读，收获满满，第一次英语产生了浓厚的兴趣，*记得马老师说过，他自己英语说得好并不是自己英语学的多好，而是对外国的文化感兴趣，才能有持续的动力来说好英语，而且是越讲越遛。*到目前为止阅读了有6本英语原著，都是原味著作，没有经过二手翻译，每天坚持阅读和理解故事情节，自己学到了很多，很感谢@薄荷阅读，也向大家极力推荐，一年已经向很多朋友成功推荐并开始使用了，哈哈~ 反馈还不错。后面我也会阅读更多有意思的书籍。\n\n## 认知\n为什么要说**认知**呢？回想自己开始编程已经有好多年头了，正式工作现在要开始第四个年头了。从一开始满头扎入技术里面，到现在关注一些超出技术的东西，就是自己的认知在不断拓宽。随着技术栈的不断深入，一些超出技术的东西被发现，像运营，产品，设计，融资，创业等等。我想2018年，我会继续升级认知，不断成长自己。\n\n## 生活\n今年是加班最多的一年，没意见吧，130+天，第一次感觉身体有点吃不消了。出去旅游的次数很少，现在想想真幸亏有@小戴的婚礼，才能去次张家界，哈哈哈，祝愿小戴以后的生活越来越好。感谢我的对象@Jolly对我的宽容和理解，给了我很多鼓励和支持，期间虽然我们发生了一些别扭，但是我知道我们都很在乎对方，你抱怨了我的缺点，我也牢记在心理，希望2018我会改掉那些毛病，给你最好的我。我们10月份订婚了，完成了人生第一件大事，以后的日子我相信我们会越来越好，I love you~ 今年家庭里面有人住院了，突然意识到随着年龄不断增长，爸妈的身体也不容忽视，所以，每年的健康体检和投资健康保险的产品是很有必要的，也是对家庭的一种保障。也谢谢@Dad&@Mum的辛勤付出，I love you too~\n\n## 其他\n感谢陪我走过2017年的人们，谢谢你们让我成长，2018年，我会继续努力，跳出自己的舒适区，不断尝试新的东西，多多阅读，多多参加一些交流会议，多多分享。加油2018！！！\n\n\n","source":"_posts/我的2017年.md","raw":"---\ntitle: 我的2017年\ndate: 2018-01-02 21:33:39\ntags: Life\ncategories: Life\n---\n\n![2017](http://opkjcw4sd.bkt.clouddn.com/2017.jpg)\n\n<!-- more -->\n\n> 时间过得好快，转眼间就2018年了，回顾2017年，好多事情还历历在目，有快乐，有收获，也有好多遗憾。。。\n\n## 目标\n2017开始设定的各种计划，有些完成了，有些没实现；写了10+博客，阅读了6+英文原著，学习了技术外的一些知识，对理财开始有了认识，没有学完Python，没有看人类简史等。\n\n## 写作\n今年开始写了些blog和公众号分享，虽然数量少的可怜，但也算是突破了一次自己，能沉淀下来一些东西，虽然很简单，以后再次翻阅会发现会很有意义；2018年希望自己能写出来更多的文章，记录发现和学到的新知识。\n\n## 阅读\n2017年陆陆续续关注了一些公众号和其他科技博客，原作对技术和生活分享认真的态度真心让我收获了不少，很感谢@stormzhang，@何俊林，@HenCoder，@傅盛，@北京GDG，@一个程序员的日常，@谷歌开发者，@湾区日报等等，很多就不一一列举了，特别感谢@stormzhang和@湾区日报，都是独立运营自己的账号，坚持原创和分享，收获了很多技术和超出技术的东西，十分感谢！我相信2018年我会关注更多有意思的科技和生活账号，同时也会和其他人一起分享自己的理解，结交更多的朋友。\n坚持了100+的薄荷阅读，收获满满，第一次英语产生了浓厚的兴趣，*记得马老师说过，他自己英语说得好并不是自己英语学的多好，而是对外国的文化感兴趣，才能有持续的动力来说好英语，而且是越讲越遛。*到目前为止阅读了有6本英语原著，都是原味著作，没有经过二手翻译，每天坚持阅读和理解故事情节，自己学到了很多，很感谢@薄荷阅读，也向大家极力推荐，一年已经向很多朋友成功推荐并开始使用了，哈哈~ 反馈还不错。后面我也会阅读更多有意思的书籍。\n\n## 认知\n为什么要说**认知**呢？回想自己开始编程已经有好多年头了，正式工作现在要开始第四个年头了。从一开始满头扎入技术里面，到现在关注一些超出技术的东西，就是自己的认知在不断拓宽。随着技术栈的不断深入，一些超出技术的东西被发现，像运营，产品，设计，融资，创业等等。我想2018年，我会继续升级认知，不断成长自己。\n\n## 生活\n今年是加班最多的一年，没意见吧，130+天，第一次感觉身体有点吃不消了。出去旅游的次数很少，现在想想真幸亏有@小戴的婚礼，才能去次张家界，哈哈哈，祝愿小戴以后的生活越来越好。感谢我的对象@Jolly对我的宽容和理解，给了我很多鼓励和支持，期间虽然我们发生了一些别扭，但是我知道我们都很在乎对方，你抱怨了我的缺点，我也牢记在心理，希望2018我会改掉那些毛病，给你最好的我。我们10月份订婚了，完成了人生第一件大事，以后的日子我相信我们会越来越好，I love you~ 今年家庭里面有人住院了，突然意识到随着年龄不断增长，爸妈的身体也不容忽视，所以，每年的健康体检和投资健康保险的产品是很有必要的，也是对家庭的一种保障。也谢谢@Dad&@Mum的辛勤付出，I love you too~\n\n## 其他\n感谢陪我走过2017年的人们，谢谢你们让我成长，2018年，我会继续努力，跳出自己的舒适区，不断尝试新的东西，多多阅读，多多参加一些交流会议，多多分享。加油2018！！！\n\n\n","slug":"我的2017年","published":1,"updated":"2020-01-14T03:35:49.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vfp0020n2cb953uojt4","content":"<p><img src=\"http://opkjcw4sd.bkt.clouddn.com/2017.jpg\" alt=\"2017\"></p>\n<a id=\"more\"></a>\n<blockquote>\n<p>时间过得好快，转眼间就2018年了，回顾2017年，好多事情还历历在目，有快乐，有收获，也有好多遗憾。。。</p>\n</blockquote>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>2017开始设定的各种计划，有些完成了，有些没实现；写了10+博客，阅读了6+英文原著，学习了技术外的一些知识，对理财开始有了认识，没有学完Python，没有看人类简史等。</p>\n<h2 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h2><p>今年开始写了些blog和公众号分享，虽然数量少的可怜，但也算是突破了一次自己，能沉淀下来一些东西，虽然很简单，以后再次翻阅会发现会很有意义；2018年希望自己能写出来更多的文章，记录发现和学到的新知识。</p>\n<h2 id=\"阅读\"><a href=\"#阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读</h2><p>2017年陆陆续续关注了一些公众号和其他科技博客，原作对技术和生活分享认真的态度真心让我收获了不少，很感谢@stormzhang，@何俊林，@HenCoder，@傅盛，@北京GDG，@一个程序员的日常，@谷歌开发者，@湾区日报等等，很多就不一一列举了，特别感谢@stormzhang和@湾区日报，都是独立运营自己的账号，坚持原创和分享，收获了很多技术和超出技术的东西，十分感谢！我相信2018年我会关注更多有意思的科技和生活账号，同时也会和其他人一起分享自己的理解，结交更多的朋友。<br>坚持了100+的薄荷阅读，收获满满，第一次英语产生了浓厚的兴趣，<em>记得马老师说过，他自己英语说得好并不是自己英语学的多好，而是对外国的文化感兴趣，才能有持续的动力来说好英语，而且是越讲越遛。</em>到目前为止阅读了有6本英语原著，都是原味著作，没有经过二手翻译，每天坚持阅读和理解故事情节，自己学到了很多，很感谢@薄荷阅读，也向大家极力推荐，一年已经向很多朋友成功推荐并开始使用了，哈哈~ 反馈还不错。后面我也会阅读更多有意思的书籍。</p>\n<h2 id=\"认知\"><a href=\"#认知\" class=\"headerlink\" title=\"认知\"></a>认知</h2><p>为什么要说<strong>认知</strong>呢？回想自己开始编程已经有好多年头了，正式工作现在要开始第四个年头了。从一开始满头扎入技术里面，到现在关注一些超出技术的东西，就是自己的认知在不断拓宽。随着技术栈的不断深入，一些超出技术的东西被发现，像运营，产品，设计，融资，创业等等。我想2018年，我会继续升级认知，不断成长自己。</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>今年是加班最多的一年，没意见吧，130+天，第一次感觉身体有点吃不消了。出去旅游的次数很少，现在想想真幸亏有@小戴的婚礼，才能去次张家界，哈哈哈，祝愿小戴以后的生活越来越好。感谢我的对象@Jolly对我的宽容和理解，给了我很多鼓励和支持，期间虽然我们发生了一些别扭，但是我知道我们都很在乎对方，你抱怨了我的缺点，我也牢记在心理，希望2018我会改掉那些毛病，给你最好的我。我们10月份订婚了，完成了人生第一件大事，以后的日子我相信我们会越来越好，I love you~ 今年家庭里面有人住院了，突然意识到随着年龄不断增长，爸妈的身体也不容忽视，所以，每年的健康体检和投资健康保险的产品是很有必要的，也是对家庭的一种保障。也谢谢@Dad&amp;@Mum的辛勤付出，I love you too~</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>感谢陪我走过2017年的人们，谢谢你们让我成长，2018年，我会继续努力，跳出自己的舒适区，不断尝试新的东西，多多阅读，多多参加一些交流会议，多多分享。加油2018！！！</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://opkjcw4sd.bkt.clouddn.com/2017.jpg\" alt=\"2017\"></p>","more":"<blockquote>\n<p>时间过得好快，转眼间就2018年了，回顾2017年，好多事情还历历在目，有快乐，有收获，也有好多遗憾。。。</p>\n</blockquote>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>2017开始设定的各种计划，有些完成了，有些没实现；写了10+博客，阅读了6+英文原著，学习了技术外的一些知识，对理财开始有了认识，没有学完Python，没有看人类简史等。</p>\n<h2 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h2><p>今年开始写了些blog和公众号分享，虽然数量少的可怜，但也算是突破了一次自己，能沉淀下来一些东西，虽然很简单，以后再次翻阅会发现会很有意义；2018年希望自己能写出来更多的文章，记录发现和学到的新知识。</p>\n<h2 id=\"阅读\"><a href=\"#阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读</h2><p>2017年陆陆续续关注了一些公众号和其他科技博客，原作对技术和生活分享认真的态度真心让我收获了不少，很感谢@stormzhang，@何俊林，@HenCoder，@傅盛，@北京GDG，@一个程序员的日常，@谷歌开发者，@湾区日报等等，很多就不一一列举了，特别感谢@stormzhang和@湾区日报，都是独立运营自己的账号，坚持原创和分享，收获了很多技术和超出技术的东西，十分感谢！我相信2018年我会关注更多有意思的科技和生活账号，同时也会和其他人一起分享自己的理解，结交更多的朋友。<br>坚持了100+的薄荷阅读，收获满满，第一次英语产生了浓厚的兴趣，<em>记得马老师说过，他自己英语说得好并不是自己英语学的多好，而是对外国的文化感兴趣，才能有持续的动力来说好英语，而且是越讲越遛。</em>到目前为止阅读了有6本英语原著，都是原味著作，没有经过二手翻译，每天坚持阅读和理解故事情节，自己学到了很多，很感谢@薄荷阅读，也向大家极力推荐，一年已经向很多朋友成功推荐并开始使用了，哈哈~ 反馈还不错。后面我也会阅读更多有意思的书籍。</p>\n<h2 id=\"认知\"><a href=\"#认知\" class=\"headerlink\" title=\"认知\"></a>认知</h2><p>为什么要说<strong>认知</strong>呢？回想自己开始编程已经有好多年头了，正式工作现在要开始第四个年头了。从一开始满头扎入技术里面，到现在关注一些超出技术的东西，就是自己的认知在不断拓宽。随着技术栈的不断深入，一些超出技术的东西被发现，像运营，产品，设计，融资，创业等等。我想2018年，我会继续升级认知，不断成长自己。</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>今年是加班最多的一年，没意见吧，130+天，第一次感觉身体有点吃不消了。出去旅游的次数很少，现在想想真幸亏有@小戴的婚礼，才能去次张家界，哈哈哈，祝愿小戴以后的生活越来越好。感谢我的对象@Jolly对我的宽容和理解，给了我很多鼓励和支持，期间虽然我们发生了一些别扭，但是我知道我们都很在乎对方，你抱怨了我的缺点，我也牢记在心理，希望2018我会改掉那些毛病，给你最好的我。我们10月份订婚了，完成了人生第一件大事，以后的日子我相信我们会越来越好，I love you~ 今年家庭里面有人住院了，突然意识到随着年龄不断增长，爸妈的身体也不容忽视，所以，每年的健康体检和投资健康保险的产品是很有必要的，也是对家庭的一种保障。也谢谢@Dad&amp;@Mum的辛勤付出，I love you too~</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>感谢陪我走过2017年的人们，谢谢你们让我成长，2018年，我会继续努力，跳出自己的舒适区，不断尝试新的东西，多多阅读，多多参加一些交流会议，多多分享。加油2018！！！</p>"},{"title":"断点调试 APT 和 Gradle Plugin","date":"2019-12-02T15:59:59.000Z","_content":"\n本文会讲解如何在 IDE（AS、Intellij）下 debug 断点调试注解处理器 APT(Annotation Processing Tool) 和 gradle plugin，帮你摆脱只能打印日志调试的窘境。\n\n<!-- more -->\n\n## 调试步骤\n\n1. 设置 Remote configuration\n\n* 打开 Edit Configurations，\n\n![toolbar-edit configurations](toolbar_edit_configurations.jpg)\n\n* 点击左上角 + 号，创建一个 Remote configuration，上面名字随便写，我写了 debug，port 端口设置为 5005，点击 ok 即可。\n\n<img desc=\"设置界面\" src=\"as_settings_remote.jpg\" width=\"80%\"/>\n\n2. 在 IDE Terminal 下，输入如下命令：\n\n```\n./gradlew clean :moduleName:assembleDebug -Dorg.gradle.debug=true --no-daemon\n```\n\n之后这个进程就会一直等待，知道我们 attach 我们的调试进程进来。执行命令后如图：\n\n<img desc=\"执行等待命令\" src=\"gradle_task_daemon.jpg\" width=\"80%\"/>\n\n3. 下断点\n\n这一步需要你去具体代码里打上断点，比如：android apt 去具体 abstractProcessor 处理器类打断点。\n\n3. 启动远程调试器 \n\n* 点击 debug 按钮连接上远程调试器进行调试\n\n![debug attach](toolbar_debug_attach.jpg)\n\n* 可以看到 connected to target VM 等信息输出就表示已连接到了远程服务器，之后就是正常的调试了\n\n<img desc=\"已连接到了远程服务器\" src=\"connected_to_target_vm.jpg\" width=\"80%\"/>\n\n* 连接上远程服务器之后，可以发现我们刚刚运行的命令已经开始执行了，这时候静代码执行到我们断点处\n\n<img desc=\"远程代码执行\" src=\"gradle_execute_remote_code.jpg\" width=\"80%\"/>\n\n最后附上一张调试的图片：\n\n<img desc=\"断点调试情景图\" src=\"debug_coding_sense.jpg\" width=\"80%\"/>\n\n## 遇到的错误\n\n* Android APT 死活不能自动生成？\n\n由于 Android Gradle 构建版本问题引起，之前设置的是 gradle 版本 5.1.1 + android gradle 3.4.1，修改成 4.4 + 3.1.4 解决。建议 3.3.2 + 4.10.1 以下都可以。具体可以参考[这篇博客](https://blog.csdn.net/allenli0413/article/details/90602402)。\n\n## 总结\n\n调试步骤其实很简单，分如下两步即可：\n\n* 新建 remote target\n* 在命令行输入执行 `./gradlew --no-daemon -Dorg.gradle.debug=true :moduleName:assembleDebug`\n* 之后选择刚刚创建的 remote target，然后点击调试按钮即可\n\n## 参考\n\n* [调试Annotation Processor编译时注解器](https://www.jianshu.com/p/cc369dca20d1)\n* [又掌握了一项新技能 - 断点调试 Gradle 插件](https://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/)\n* [gradle调试断点](https://fsilence.github.io/2017/04/11/gradle-debug/)\n* [Android APT不能自动生成文件](https://blog.csdn.net/allenli0413/article/details/90602402)\n\n\n","source":"_posts/断点调试-APT-和-Gradle-Plugin.md","raw":"---\ntitle: 断点调试 APT 和 Gradle Plugin\ndate: 2019-12-02 23:59:59\ntags: 调试\ncategories: [Android,调试]\n---\n\n本文会讲解如何在 IDE（AS、Intellij）下 debug 断点调试注解处理器 APT(Annotation Processing Tool) 和 gradle plugin，帮你摆脱只能打印日志调试的窘境。\n\n<!-- more -->\n\n## 调试步骤\n\n1. 设置 Remote configuration\n\n* 打开 Edit Configurations，\n\n![toolbar-edit configurations](toolbar_edit_configurations.jpg)\n\n* 点击左上角 + 号，创建一个 Remote configuration，上面名字随便写，我写了 debug，port 端口设置为 5005，点击 ok 即可。\n\n<img desc=\"设置界面\" src=\"as_settings_remote.jpg\" width=\"80%\"/>\n\n2. 在 IDE Terminal 下，输入如下命令：\n\n```\n./gradlew clean :moduleName:assembleDebug -Dorg.gradle.debug=true --no-daemon\n```\n\n之后这个进程就会一直等待，知道我们 attach 我们的调试进程进来。执行命令后如图：\n\n<img desc=\"执行等待命令\" src=\"gradle_task_daemon.jpg\" width=\"80%\"/>\n\n3. 下断点\n\n这一步需要你去具体代码里打上断点，比如：android apt 去具体 abstractProcessor 处理器类打断点。\n\n3. 启动远程调试器 \n\n* 点击 debug 按钮连接上远程调试器进行调试\n\n![debug attach](toolbar_debug_attach.jpg)\n\n* 可以看到 connected to target VM 等信息输出就表示已连接到了远程服务器，之后就是正常的调试了\n\n<img desc=\"已连接到了远程服务器\" src=\"connected_to_target_vm.jpg\" width=\"80%\"/>\n\n* 连接上远程服务器之后，可以发现我们刚刚运行的命令已经开始执行了，这时候静代码执行到我们断点处\n\n<img desc=\"远程代码执行\" src=\"gradle_execute_remote_code.jpg\" width=\"80%\"/>\n\n最后附上一张调试的图片：\n\n<img desc=\"断点调试情景图\" src=\"debug_coding_sense.jpg\" width=\"80%\"/>\n\n## 遇到的错误\n\n* Android APT 死活不能自动生成？\n\n由于 Android Gradle 构建版本问题引起，之前设置的是 gradle 版本 5.1.1 + android gradle 3.4.1，修改成 4.4 + 3.1.4 解决。建议 3.3.2 + 4.10.1 以下都可以。具体可以参考[这篇博客](https://blog.csdn.net/allenli0413/article/details/90602402)。\n\n## 总结\n\n调试步骤其实很简单，分如下两步即可：\n\n* 新建 remote target\n* 在命令行输入执行 `./gradlew --no-daemon -Dorg.gradle.debug=true :moduleName:assembleDebug`\n* 之后选择刚刚创建的 remote target，然后点击调试按钮即可\n\n## 参考\n\n* [调试Annotation Processor编译时注解器](https://www.jianshu.com/p/cc369dca20d1)\n* [又掌握了一项新技能 - 断点调试 Gradle 插件](https://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/)\n* [gradle调试断点](https://fsilence.github.io/2017/04/11/gradle-debug/)\n* [Android APT不能自动生成文件](https://blog.csdn.net/allenli0413/article/details/90602402)\n\n\n","slug":"断点调试-APT-和-Gradle-Plugin","published":1,"updated":"2020-01-14T03:35:49.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vfr0022n2cbvslubute","content":"<p>本文会讲解如何在 IDE（AS、Intellij）下 debug 断点调试注解处理器 APT(Annotation Processing Tool) 和 gradle plugin，帮你摆脱只能打印日志调试的窘境。</p>\n<a id=\"more\"></a>\n<h2 id=\"调试步骤\"><a href=\"#调试步骤\" class=\"headerlink\" title=\"调试步骤\"></a>调试步骤</h2><ol>\n<li>设置 Remote configuration</li>\n</ol>\n<ul>\n<li>打开 Edit Configurations，</li>\n</ul>\n<p><img src=\"toolbar_edit_configurations.jpg\" alt=\"toolbar-edit configurations\"></p>\n<ul>\n<li>点击左上角 + 号，创建一个 Remote configuration，上面名字随便写，我写了 debug，port 端口设置为 5005，点击 ok 即可。</li>\n</ul>\n<p><img desc=\"设置界面\" src=\"as_settings_remote.jpg\" width=\"80%\"></p>\n<ol start=\"2\">\n<li>在 IDE Terminal 下，输入如下命令：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gradlew clean :moduleName:assembleDebug -Dorg.gradle.debug=true --no-daemon</span><br></pre></td></tr></table></figure>\n<p>之后这个进程就会一直等待，知道我们 attach 我们的调试进程进来。执行命令后如图：</p>\n<p><img desc=\"执行等待命令\" src=\"gradle_task_daemon.jpg\" width=\"80%\"></p>\n<ol start=\"3\">\n<li>下断点</li>\n</ol>\n<p>这一步需要你去具体代码里打上断点，比如：android apt 去具体 abstractProcessor 处理器类打断点。</p>\n<ol start=\"3\">\n<li>启动远程调试器 </li>\n</ol>\n<ul>\n<li>点击 debug 按钮连接上远程调试器进行调试</li>\n</ul>\n<p><img src=\"toolbar_debug_attach.jpg\" alt=\"debug attach\"></p>\n<ul>\n<li>可以看到 connected to target VM 等信息输出就表示已连接到了远程服务器，之后就是正常的调试了</li>\n</ul>\n<p><img desc=\"已连接到了远程服务器\" src=\"connected_to_target_vm.jpg\" width=\"80%\"></p>\n<ul>\n<li>连接上远程服务器之后，可以发现我们刚刚运行的命令已经开始执行了，这时候静代码执行到我们断点处</li>\n</ul>\n<p><img desc=\"远程代码执行\" src=\"gradle_execute_remote_code.jpg\" width=\"80%\"></p>\n<p>最后附上一张调试的图片：</p>\n<p><img desc=\"断点调试情景图\" src=\"debug_coding_sense.jpg\" width=\"80%\"></p>\n<h2 id=\"遇到的错误\"><a href=\"#遇到的错误\" class=\"headerlink\" title=\"遇到的错误\"></a>遇到的错误</h2><ul>\n<li>Android APT 死活不能自动生成？</li>\n</ul>\n<p>由于 Android Gradle 构建版本问题引起，之前设置的是 gradle 版本 5.1.1 + android gradle 3.4.1，修改成 4.4 + 3.1.4 解决。建议 3.3.2 + 4.10.1 以下都可以。具体可以参考<a href=\"https://blog.csdn.net/allenli0413/article/details/90602402\" target=\"_blank\" rel=\"noopener\">这篇博客</a>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>调试步骤其实很简单，分如下两步即可：</p>\n<ul>\n<li>新建 remote target</li>\n<li>在命令行输入执行 <code>./gradlew --no-daemon -Dorg.gradle.debug=true :moduleName:assembleDebug</code></li>\n<li>之后选择刚刚创建的 remote target，然后点击调试按钮即可</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/cc369dca20d1\" target=\"_blank\" rel=\"noopener\">调试Annotation Processor编译时注解器</a></li>\n<li><a href=\"https://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/\" target=\"_blank\" rel=\"noopener\">又掌握了一项新技能 - 断点调试 Gradle 插件</a></li>\n<li><a href=\"https://fsilence.github.io/2017/04/11/gradle-debug/\" target=\"_blank\" rel=\"noopener\">gradle调试断点</a></li>\n<li><a href=\"https://blog.csdn.net/allenli0413/article/details/90602402\" target=\"_blank\" rel=\"noopener\">Android APT不能自动生成文件</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文会讲解如何在 IDE（AS、Intellij）下 debug 断点调试注解处理器 APT(Annotation Processing Tool) 和 gradle plugin，帮你摆脱只能打印日志调试的窘境。</p>","more":"<h2 id=\"调试步骤\"><a href=\"#调试步骤\" class=\"headerlink\" title=\"调试步骤\"></a>调试步骤</h2><ol>\n<li>设置 Remote configuration</li>\n</ol>\n<ul>\n<li>打开 Edit Configurations，</li>\n</ul>\n<p><img src=\"toolbar_edit_configurations.jpg\" alt=\"toolbar-edit configurations\"></p>\n<ul>\n<li>点击左上角 + 号，创建一个 Remote configuration，上面名字随便写，我写了 debug，port 端口设置为 5005，点击 ok 即可。</li>\n</ul>\n<p><img desc=\"设置界面\" src=\"as_settings_remote.jpg\" width=\"80%\"></p>\n<ol start=\"2\">\n<li>在 IDE Terminal 下，输入如下命令：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gradlew clean :moduleName:assembleDebug -Dorg.gradle.debug=true --no-daemon</span><br></pre></td></tr></table></figure>\n<p>之后这个进程就会一直等待，知道我们 attach 我们的调试进程进来。执行命令后如图：</p>\n<p><img desc=\"执行等待命令\" src=\"gradle_task_daemon.jpg\" width=\"80%\"></p>\n<ol start=\"3\">\n<li>下断点</li>\n</ol>\n<p>这一步需要你去具体代码里打上断点，比如：android apt 去具体 abstractProcessor 处理器类打断点。</p>\n<ol start=\"3\">\n<li>启动远程调试器 </li>\n</ol>\n<ul>\n<li>点击 debug 按钮连接上远程调试器进行调试</li>\n</ul>\n<p><img src=\"toolbar_debug_attach.jpg\" alt=\"debug attach\"></p>\n<ul>\n<li>可以看到 connected to target VM 等信息输出就表示已连接到了远程服务器，之后就是正常的调试了</li>\n</ul>\n<p><img desc=\"已连接到了远程服务器\" src=\"connected_to_target_vm.jpg\" width=\"80%\"></p>\n<ul>\n<li>连接上远程服务器之后，可以发现我们刚刚运行的命令已经开始执行了，这时候静代码执行到我们断点处</li>\n</ul>\n<p><img desc=\"远程代码执行\" src=\"gradle_execute_remote_code.jpg\" width=\"80%\"></p>\n<p>最后附上一张调试的图片：</p>\n<p><img desc=\"断点调试情景图\" src=\"debug_coding_sense.jpg\" width=\"80%\"></p>\n<h2 id=\"遇到的错误\"><a href=\"#遇到的错误\" class=\"headerlink\" title=\"遇到的错误\"></a>遇到的错误</h2><ul>\n<li>Android APT 死活不能自动生成？</li>\n</ul>\n<p>由于 Android Gradle 构建版本问题引起，之前设置的是 gradle 版本 5.1.1 + android gradle 3.4.1，修改成 4.4 + 3.1.4 解决。建议 3.3.2 + 4.10.1 以下都可以。具体可以参考<a href=\"https://blog.csdn.net/allenli0413/article/details/90602402\" target=\"_blank\" rel=\"noopener\">这篇博客</a>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>调试步骤其实很简单，分如下两步即可：</p>\n<ul>\n<li>新建 remote target</li>\n<li>在命令行输入执行 <code>./gradlew --no-daemon -Dorg.gradle.debug=true :moduleName:assembleDebug</code></li>\n<li>之后选择刚刚创建的 remote target，然后点击调试按钮即可</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/cc369dca20d1\" target=\"_blank\" rel=\"noopener\">调试Annotation Processor编译时注解器</a></li>\n<li><a href=\"https://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/\" target=\"_blank\" rel=\"noopener\">又掌握了一项新技能 - 断点调试 Gradle 插件</a></li>\n<li><a href=\"https://fsilence.github.io/2017/04/11/gradle-debug/\" target=\"_blank\" rel=\"noopener\">gradle调试断点</a></li>\n<li><a href=\"https://blog.csdn.net/allenli0413/article/details/90602402\" target=\"_blank\" rel=\"noopener\">Android APT不能自动生成文件</a></li>\n</ul>"},{"title":"科学上网的姿势，帮你解决翻墙上网的烦恼","date":"2018-03-25T15:49:09.000Z","_content":"\n不管是作为学生党还是程序员，一个畅通的搜索工具一直是我们身边必不可少的，比如时不时需要去Google、Stack Overflow、GitHub上去浏览和搜索一些有用的知识。但是一些xx的原因，我们无法正常访问国外服务。本文将讲解使用科学上网利器Shadowsocks + banwagong(搬瓦工)来搭建实现翻墙，操作步骤很简单，搭建完成之后，效率几乎秒杀其他免费和收费工具。\n\n![shadowsocks-logo](http://wanghaoxun.com/shadowsocks-logo.png)\n![banwagong-logo](http://wanghaoxun.com/banwagong-logo.png)\n\n<!-- more -->\n\n## 配置过程\n\n### shadowsocks\n\n一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种传输包。目前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。\n\n上面这段话是来自维基百科的简介，关于shadowsocks的详细介绍可以去Wikipedia [^Shadowsocks]查看，总而言之就是一种基于Socks5代理方式的加密传输协议，我们可以使用开源shadowsocks工具来和远端socks服务器通信，突破国内防火墙的限制，来达到翻墙上网的目的。\n\n[^Shadowsocks]: https://zh.wikipedia.org/wiki/Shadowsocks\n\n#### shadowsocks客户端\n\n关于shadowsocks各个平台客户端的应用，可以去[这里](https://shadowsocks.org/en/download/clients.html)查看。\n\n* Android-安卓客户端\n由于shadowsocks开源组织把应用上传到[Google Play](https://play.google.com/store/apps/details?id=com.github.shadowsocks)，国内可能无法下载，所以，我提供一个GitHub的[下载地址](https://github.com/shadowsocks/shadowsocks-android/releases)，一般手机都下载armeabi-v7a架构的apk，例如：[shadowsocks-armeabi-v7a-4.6.1.apk](https://github.com/shadowsocks/shadowsocks-android/releases/download/v4.6.1/shadowsocks-armeabi-v7a-4.6.1.apk)\n* ios-苹果，本人手机使用了一款名为OpenWingy的应用，很方便，你可以去app store搜索下载即可\n* Windows- [下载地址](https://github.com/shadowsocks/shadowsocks-windows/releases)\n* Mac- [下载地址](https://github.com/shadowsocks/ShadowsocksX-NG/releases)\n\n### banwagong\n\n#### 官方网站\n\n网站：[banwagong](https://bandwagonhost.com/index.php)\n\n![banwagong](http://wanghaoxun.com/banwagong-site.jpg)\n\n#### 套餐\n\n![banwagong-package](http://wanghaoxun.com/banwagong-package.jpg)\n\n一般我们选择10G VPS（服务器：10GB磁盘存储 + 512MB内存+每月500GB流量，无设备数量限制）这个套餐就够了，支持支付宝付款！博主选择的就是这个套餐，日常Google搜索和视频的使用绰绰有余，网络很稳定。\n\n#### 设置\n\n购买完成后，点击services->My Services->KiwiVM Control Panel进入服务器管理界面，接下来要去设置socks协议的服务。注意：刚才是购买了一台服务器，具体服务器干啥，需要我们自己去设置，因为我们要使用socks协议服务来翻墙，所以要在购买的远端服务器上安装socks的服务。\n\n接下来要去安装操作系统和shadowsocks服务，都是傻瓜式的安装，点击按钮即可。\n\n![banwagong-service](http://wanghaoxun.com/banwagong-service.jpg)\n\n* 服务器安装操作系统\n![banwagong-os](http://wanghaoxun.com/banwagong-os.jpg)\n\n* 服务器安装shadowsocks服务\n![banwagong-shadowsocksServer](http://wanghaoxun.com/banwagong-shadowsocksServer.jpg)\n\n等到几分钟安装完成后，重新点击左侧的shadowsocks server菜单，页面已经变成了下图。这三项是你链接你的vpn的必要内容\n\n![image](http://wanghaoxun.com/banwagong-server-user.jpeg)\n\n拿到ip地址、端口号和密码就可以用shadowsocks客户端来连接服务了。\n\n注意：ip地址可以去下图查找\n![banwagong-server-ip](http://wanghaoxun.com/banwagong-server-ip.jpg)\n\n最后，shadowsocks客户端连接配置页面如下：\n\n![shadowsocks-connected](http://wanghaoxun.com/shadowsocks-connected.jpg)\n\n## 总结\n\n* 首先去[banwagong](https://bandwagonhost.com/index.php)网站购买服务器\n* 下载shadowsocks客户端[shadowsocks](https://shadowsocks.org/en/download/clients.html)\n* 设置服务器，安装操作系统和shadowsocks服务\n* 配置客户端连接远端服务\n\n## 浏览器插件利器-SwitchyOmega\n\n已经成功翻墙你，如果想对某些网站动态设置翻墙服务，可以使用SwitchyOmega来解决，详细教程请查看这里。\n\n[shadowsocks配合chrome插件SwitchyOmega](https://blog.csdn.net/shouldnotappearcalm/article/details/77900399)\n\n## 参考\n\n* [Wikipedia-shadowsocks](https://zh.wikipedia.org/wiki/Shadowsock)\n* [写给非专业人士看的 Shadowsocks 简介](https://vc2tea.com/whats-shadowsocks/)\n* [搬瓦工-产品链接](https://bandwagonhost.com/clientarea.php?action=products)\n* [Linux VPS基本常识 - KVM与OpenVZ架构的区别](http://banwagong.cn/ovz-kvm.html)\n* [搬瓦工Bandwagon一键搭建ShadowSocks翻墙教程](http://www.huizhanzhang.com/2017/05/bandwagon-one-key-shadowsocks.html)\n* [shadowsocks配合chrome插件SwitchyOmega](https://blog.csdn.net/shouldnotappearcalm/article/details/77900399)\n\n\n\n\n","source":"_posts/科学上网的姿势，帮你解决翻墙上网的烦恼.md","raw":"---\ntitle: 科学上网的姿势，帮你解决翻墙上网的烦恼\ndate: 2018-03-25 23:49:09\ntags: 翻墙\ncategories: 翻墙\n---\n\n不管是作为学生党还是程序员，一个畅通的搜索工具一直是我们身边必不可少的，比如时不时需要去Google、Stack Overflow、GitHub上去浏览和搜索一些有用的知识。但是一些xx的原因，我们无法正常访问国外服务。本文将讲解使用科学上网利器Shadowsocks + banwagong(搬瓦工)来搭建实现翻墙，操作步骤很简单，搭建完成之后，效率几乎秒杀其他免费和收费工具。\n\n![shadowsocks-logo](http://wanghaoxun.com/shadowsocks-logo.png)\n![banwagong-logo](http://wanghaoxun.com/banwagong-logo.png)\n\n<!-- more -->\n\n## 配置过程\n\n### shadowsocks\n\n一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种传输包。目前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。\n\n上面这段话是来自维基百科的简介，关于shadowsocks的详细介绍可以去Wikipedia [^Shadowsocks]查看，总而言之就是一种基于Socks5代理方式的加密传输协议，我们可以使用开源shadowsocks工具来和远端socks服务器通信，突破国内防火墙的限制，来达到翻墙上网的目的。\n\n[^Shadowsocks]: https://zh.wikipedia.org/wiki/Shadowsocks\n\n#### shadowsocks客户端\n\n关于shadowsocks各个平台客户端的应用，可以去[这里](https://shadowsocks.org/en/download/clients.html)查看。\n\n* Android-安卓客户端\n由于shadowsocks开源组织把应用上传到[Google Play](https://play.google.com/store/apps/details?id=com.github.shadowsocks)，国内可能无法下载，所以，我提供一个GitHub的[下载地址](https://github.com/shadowsocks/shadowsocks-android/releases)，一般手机都下载armeabi-v7a架构的apk，例如：[shadowsocks-armeabi-v7a-4.6.1.apk](https://github.com/shadowsocks/shadowsocks-android/releases/download/v4.6.1/shadowsocks-armeabi-v7a-4.6.1.apk)\n* ios-苹果，本人手机使用了一款名为OpenWingy的应用，很方便，你可以去app store搜索下载即可\n* Windows- [下载地址](https://github.com/shadowsocks/shadowsocks-windows/releases)\n* Mac- [下载地址](https://github.com/shadowsocks/ShadowsocksX-NG/releases)\n\n### banwagong\n\n#### 官方网站\n\n网站：[banwagong](https://bandwagonhost.com/index.php)\n\n![banwagong](http://wanghaoxun.com/banwagong-site.jpg)\n\n#### 套餐\n\n![banwagong-package](http://wanghaoxun.com/banwagong-package.jpg)\n\n一般我们选择10G VPS（服务器：10GB磁盘存储 + 512MB内存+每月500GB流量，无设备数量限制）这个套餐就够了，支持支付宝付款！博主选择的就是这个套餐，日常Google搜索和视频的使用绰绰有余，网络很稳定。\n\n#### 设置\n\n购买完成后，点击services->My Services->KiwiVM Control Panel进入服务器管理界面，接下来要去设置socks协议的服务。注意：刚才是购买了一台服务器，具体服务器干啥，需要我们自己去设置，因为我们要使用socks协议服务来翻墙，所以要在购买的远端服务器上安装socks的服务。\n\n接下来要去安装操作系统和shadowsocks服务，都是傻瓜式的安装，点击按钮即可。\n\n![banwagong-service](http://wanghaoxun.com/banwagong-service.jpg)\n\n* 服务器安装操作系统\n![banwagong-os](http://wanghaoxun.com/banwagong-os.jpg)\n\n* 服务器安装shadowsocks服务\n![banwagong-shadowsocksServer](http://wanghaoxun.com/banwagong-shadowsocksServer.jpg)\n\n等到几分钟安装完成后，重新点击左侧的shadowsocks server菜单，页面已经变成了下图。这三项是你链接你的vpn的必要内容\n\n![image](http://wanghaoxun.com/banwagong-server-user.jpeg)\n\n拿到ip地址、端口号和密码就可以用shadowsocks客户端来连接服务了。\n\n注意：ip地址可以去下图查找\n![banwagong-server-ip](http://wanghaoxun.com/banwagong-server-ip.jpg)\n\n最后，shadowsocks客户端连接配置页面如下：\n\n![shadowsocks-connected](http://wanghaoxun.com/shadowsocks-connected.jpg)\n\n## 总结\n\n* 首先去[banwagong](https://bandwagonhost.com/index.php)网站购买服务器\n* 下载shadowsocks客户端[shadowsocks](https://shadowsocks.org/en/download/clients.html)\n* 设置服务器，安装操作系统和shadowsocks服务\n* 配置客户端连接远端服务\n\n## 浏览器插件利器-SwitchyOmega\n\n已经成功翻墙你，如果想对某些网站动态设置翻墙服务，可以使用SwitchyOmega来解决，详细教程请查看这里。\n\n[shadowsocks配合chrome插件SwitchyOmega](https://blog.csdn.net/shouldnotappearcalm/article/details/77900399)\n\n## 参考\n\n* [Wikipedia-shadowsocks](https://zh.wikipedia.org/wiki/Shadowsock)\n* [写给非专业人士看的 Shadowsocks 简介](https://vc2tea.com/whats-shadowsocks/)\n* [搬瓦工-产品链接](https://bandwagonhost.com/clientarea.php?action=products)\n* [Linux VPS基本常识 - KVM与OpenVZ架构的区别](http://banwagong.cn/ovz-kvm.html)\n* [搬瓦工Bandwagon一键搭建ShadowSocks翻墙教程](http://www.huizhanzhang.com/2017/05/bandwagon-one-key-shadowsocks.html)\n* [shadowsocks配合chrome插件SwitchyOmega](https://blog.csdn.net/shouldnotappearcalm/article/details/77900399)\n\n\n\n\n","slug":"科学上网的姿势，帮你解决翻墙上网的烦恼","published":1,"updated":"2020-01-14T03:35:49.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5gf4vfv0027n2cbntdt2oju","content":"<p>不管是作为学生党还是程序员，一个畅通的搜索工具一直是我们身边必不可少的，比如时不时需要去Google、Stack Overflow、GitHub上去浏览和搜索一些有用的知识。但是一些xx的原因，我们无法正常访问国外服务。本文将讲解使用科学上网利器Shadowsocks + banwagong(搬瓦工)来搭建实现翻墙，操作步骤很简单，搭建完成之后，效率几乎秒杀其他免费和收费工具。</p>\n<p><img src=\"http://wanghaoxun.com/shadowsocks-logo.png\" alt=\"shadowsocks-logo\"><br><img src=\"http://wanghaoxun.com/banwagong-logo.png\" alt=\"banwagong-logo\"></p>\n<a id=\"more\"></a>\n<h2 id=\"配置过程\"><a href=\"#配置过程\" class=\"headerlink\" title=\"配置过程\"></a>配置过程</h2><h3 id=\"shadowsocks\"><a href=\"#shadowsocks\" class=\"headerlink\" title=\"shadowsocks\"></a>shadowsocks</h3><p>一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种传输包。目前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。</p>\n<p>上面这段话是来自维基百科的简介，关于shadowsocks的详细介绍可以去Wikipedia <a href=\"https://zh.wikipedia.org/wiki/Shadowsocks\" target=\"_blank\" rel=\"noopener\">^Shadowsocks</a>查看，总而言之就是一种基于Socks5代理方式的加密传输协议，我们可以使用开源shadowsocks工具来和远端socks服务器通信，突破国内防火墙的限制，来达到翻墙上网的目的。</p>\n<h4 id=\"shadowsocks客户端\"><a href=\"#shadowsocks客户端\" class=\"headerlink\" title=\"shadowsocks客户端\"></a>shadowsocks客户端</h4><p>关于shadowsocks各个平台客户端的应用，可以去<a href=\"https://shadowsocks.org/en/download/clients.html\" target=\"_blank\" rel=\"noopener\">这里</a>查看。</p>\n<ul>\n<li>Android-安卓客户端<br>由于shadowsocks开源组织把应用上传到<a href=\"https://play.google.com/store/apps/details?id=com.github.shadowsocks\" target=\"_blank\" rel=\"noopener\">Google Play</a>，国内可能无法下载，所以，我提供一个GitHub的<a href=\"https://github.com/shadowsocks/shadowsocks-android/releases\" target=\"_blank\" rel=\"noopener\">下载地址</a>，一般手机都下载armeabi-v7a架构的apk，例如：<a href=\"https://github.com/shadowsocks/shadowsocks-android/releases/download/v4.6.1/shadowsocks-armeabi-v7a-4.6.1.apk\" target=\"_blank\" rel=\"noopener\">shadowsocks-armeabi-v7a-4.6.1.apk</a></li>\n<li>ios-苹果，本人手机使用了一款名为OpenWingy的应用，很方便，你可以去app store搜索下载即可</li>\n<li>Windows- <a href=\"https://github.com/shadowsocks/shadowsocks-windows/releases\" target=\"_blank\" rel=\"noopener\">下载地址</a></li>\n<li>Mac- <a href=\"https://github.com/shadowsocks/ShadowsocksX-NG/releases\" target=\"_blank\" rel=\"noopener\">下载地址</a></li>\n</ul>\n<h3 id=\"banwagong\"><a href=\"#banwagong\" class=\"headerlink\" title=\"banwagong\"></a>banwagong</h3><h4 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h4><p>网站：<a href=\"https://bandwagonhost.com/index.php\" target=\"_blank\" rel=\"noopener\">banwagong</a></p>\n<p><img src=\"http://wanghaoxun.com/banwagong-site.jpg\" alt=\"banwagong\"></p>\n<h4 id=\"套餐\"><a href=\"#套餐\" class=\"headerlink\" title=\"套餐\"></a>套餐</h4><p><img src=\"http://wanghaoxun.com/banwagong-package.jpg\" alt=\"banwagong-package\"></p>\n<p>一般我们选择10G VPS（服务器：10GB磁盘存储 + 512MB内存+每月500GB流量，无设备数量限制）这个套餐就够了，支持支付宝付款！博主选择的就是这个套餐，日常Google搜索和视频的使用绰绰有余，网络很稳定。</p>\n<h4 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h4><p>购买完成后，点击services-&gt;My Services-&gt;KiwiVM Control Panel进入服务器管理界面，接下来要去设置socks协议的服务。注意：刚才是购买了一台服务器，具体服务器干啥，需要我们自己去设置，因为我们要使用socks协议服务来翻墙，所以要在购买的远端服务器上安装socks的服务。</p>\n<p>接下来要去安装操作系统和shadowsocks服务，都是傻瓜式的安装，点击按钮即可。</p>\n<p><img src=\"http://wanghaoxun.com/banwagong-service.jpg\" alt=\"banwagong-service\"></p>\n<ul>\n<li><p>服务器安装操作系统<br><img src=\"http://wanghaoxun.com/banwagong-os.jpg\" alt=\"banwagong-os\"></p>\n</li>\n<li><p>服务器安装shadowsocks服务<br><img src=\"http://wanghaoxun.com/banwagong-shadowsocksServer.jpg\" alt=\"banwagong-shadowsocksServer\"></p>\n</li>\n</ul>\n<p>等到几分钟安装完成后，重新点击左侧的shadowsocks server菜单，页面已经变成了下图。这三项是你链接你的vpn的必要内容</p>\n<p><img src=\"http://wanghaoxun.com/banwagong-server-user.jpeg\" alt=\"image\"></p>\n<p>拿到ip地址、端口号和密码就可以用shadowsocks客户端来连接服务了。</p>\n<p>注意：ip地址可以去下图查找<br><img src=\"http://wanghaoxun.com/banwagong-server-ip.jpg\" alt=\"banwagong-server-ip\"></p>\n<p>最后，shadowsocks客户端连接配置页面如下：</p>\n<p><img src=\"http://wanghaoxun.com/shadowsocks-connected.jpg\" alt=\"shadowsocks-connected\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>首先去<a href=\"https://bandwagonhost.com/index.php\" target=\"_blank\" rel=\"noopener\">banwagong</a>网站购买服务器</li>\n<li>下载shadowsocks客户端<a href=\"https://shadowsocks.org/en/download/clients.html\" target=\"_blank\" rel=\"noopener\">shadowsocks</a></li>\n<li>设置服务器，安装操作系统和shadowsocks服务</li>\n<li>配置客户端连接远端服务</li>\n</ul>\n<h2 id=\"浏览器插件利器-SwitchyOmega\"><a href=\"#浏览器插件利器-SwitchyOmega\" class=\"headerlink\" title=\"浏览器插件利器-SwitchyOmega\"></a>浏览器插件利器-SwitchyOmega</h2><p>已经成功翻墙你，如果想对某些网站动态设置翻墙服务，可以使用SwitchyOmega来解决，详细教程请查看这里。</p>\n<p><a href=\"https://blog.csdn.net/shouldnotappearcalm/article/details/77900399\" target=\"_blank\" rel=\"noopener\">shadowsocks配合chrome插件SwitchyOmega</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/Shadowsock\" target=\"_blank\" rel=\"noopener\">Wikipedia-shadowsocks</a></li>\n<li><a href=\"https://vc2tea.com/whats-shadowsocks/\" target=\"_blank\" rel=\"noopener\">写给非专业人士看的 Shadowsocks 简介</a></li>\n<li><a href=\"https://bandwagonhost.com/clientarea.php?action=products\" target=\"_blank\" rel=\"noopener\">搬瓦工-产品链接</a></li>\n<li><a href=\"http://banwagong.cn/ovz-kvm.html\" target=\"_blank\" rel=\"noopener\">Linux VPS基本常识 - KVM与OpenVZ架构的区别</a></li>\n<li><a href=\"http://www.huizhanzhang.com/2017/05/bandwagon-one-key-shadowsocks.html\" target=\"_blank\" rel=\"noopener\">搬瓦工Bandwagon一键搭建ShadowSocks翻墙教程</a></li>\n<li><a href=\"https://blog.csdn.net/shouldnotappearcalm/article/details/77900399\" target=\"_blank\" rel=\"noopener\">shadowsocks配合chrome插件SwitchyOmega</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>不管是作为学生党还是程序员，一个畅通的搜索工具一直是我们身边必不可少的，比如时不时需要去Google、Stack Overflow、GitHub上去浏览和搜索一些有用的知识。但是一些xx的原因，我们无法正常访问国外服务。本文将讲解使用科学上网利器Shadowsocks + banwagong(搬瓦工)来搭建实现翻墙，操作步骤很简单，搭建完成之后，效率几乎秒杀其他免费和收费工具。</p>\n<p><img src=\"http://wanghaoxun.com/shadowsocks-logo.png\" alt=\"shadowsocks-logo\"><br><img src=\"http://wanghaoxun.com/banwagong-logo.png\" alt=\"banwagong-logo\"></p>","more":"<h2 id=\"配置过程\"><a href=\"#配置过程\" class=\"headerlink\" title=\"配置过程\"></a>配置过程</h2><h3 id=\"shadowsocks\"><a href=\"#shadowsocks\" class=\"headerlink\" title=\"shadowsocks\"></a>shadowsocks</h3><p>一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种传输包。目前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。</p>\n<p>上面这段话是来自维基百科的简介，关于shadowsocks的详细介绍可以去Wikipedia <a href=\"https://zh.wikipedia.org/wiki/Shadowsocks\" target=\"_blank\" rel=\"noopener\">^Shadowsocks</a>查看，总而言之就是一种基于Socks5代理方式的加密传输协议，我们可以使用开源shadowsocks工具来和远端socks服务器通信，突破国内防火墙的限制，来达到翻墙上网的目的。</p>\n<h4 id=\"shadowsocks客户端\"><a href=\"#shadowsocks客户端\" class=\"headerlink\" title=\"shadowsocks客户端\"></a>shadowsocks客户端</h4><p>关于shadowsocks各个平台客户端的应用，可以去<a href=\"https://shadowsocks.org/en/download/clients.html\" target=\"_blank\" rel=\"noopener\">这里</a>查看。</p>\n<ul>\n<li>Android-安卓客户端<br>由于shadowsocks开源组织把应用上传到<a href=\"https://play.google.com/store/apps/details?id=com.github.shadowsocks\" target=\"_blank\" rel=\"noopener\">Google Play</a>，国内可能无法下载，所以，我提供一个GitHub的<a href=\"https://github.com/shadowsocks/shadowsocks-android/releases\" target=\"_blank\" rel=\"noopener\">下载地址</a>，一般手机都下载armeabi-v7a架构的apk，例如：<a href=\"https://github.com/shadowsocks/shadowsocks-android/releases/download/v4.6.1/shadowsocks-armeabi-v7a-4.6.1.apk\" target=\"_blank\" rel=\"noopener\">shadowsocks-armeabi-v7a-4.6.1.apk</a></li>\n<li>ios-苹果，本人手机使用了一款名为OpenWingy的应用，很方便，你可以去app store搜索下载即可</li>\n<li>Windows- <a href=\"https://github.com/shadowsocks/shadowsocks-windows/releases\" target=\"_blank\" rel=\"noopener\">下载地址</a></li>\n<li>Mac- <a href=\"https://github.com/shadowsocks/ShadowsocksX-NG/releases\" target=\"_blank\" rel=\"noopener\">下载地址</a></li>\n</ul>\n<h3 id=\"banwagong\"><a href=\"#banwagong\" class=\"headerlink\" title=\"banwagong\"></a>banwagong</h3><h4 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h4><p>网站：<a href=\"https://bandwagonhost.com/index.php\" target=\"_blank\" rel=\"noopener\">banwagong</a></p>\n<p><img src=\"http://wanghaoxun.com/banwagong-site.jpg\" alt=\"banwagong\"></p>\n<h4 id=\"套餐\"><a href=\"#套餐\" class=\"headerlink\" title=\"套餐\"></a>套餐</h4><p><img src=\"http://wanghaoxun.com/banwagong-package.jpg\" alt=\"banwagong-package\"></p>\n<p>一般我们选择10G VPS（服务器：10GB磁盘存储 + 512MB内存+每月500GB流量，无设备数量限制）这个套餐就够了，支持支付宝付款！博主选择的就是这个套餐，日常Google搜索和视频的使用绰绰有余，网络很稳定。</p>\n<h4 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h4><p>购买完成后，点击services-&gt;My Services-&gt;KiwiVM Control Panel进入服务器管理界面，接下来要去设置socks协议的服务。注意：刚才是购买了一台服务器，具体服务器干啥，需要我们自己去设置，因为我们要使用socks协议服务来翻墙，所以要在购买的远端服务器上安装socks的服务。</p>\n<p>接下来要去安装操作系统和shadowsocks服务，都是傻瓜式的安装，点击按钮即可。</p>\n<p><img src=\"http://wanghaoxun.com/banwagong-service.jpg\" alt=\"banwagong-service\"></p>\n<ul>\n<li><p>服务器安装操作系统<br><img src=\"http://wanghaoxun.com/banwagong-os.jpg\" alt=\"banwagong-os\"></p>\n</li>\n<li><p>服务器安装shadowsocks服务<br><img src=\"http://wanghaoxun.com/banwagong-shadowsocksServer.jpg\" alt=\"banwagong-shadowsocksServer\"></p>\n</li>\n</ul>\n<p>等到几分钟安装完成后，重新点击左侧的shadowsocks server菜单，页面已经变成了下图。这三项是你链接你的vpn的必要内容</p>\n<p><img src=\"http://wanghaoxun.com/banwagong-server-user.jpeg\" alt=\"image\"></p>\n<p>拿到ip地址、端口号和密码就可以用shadowsocks客户端来连接服务了。</p>\n<p>注意：ip地址可以去下图查找<br><img src=\"http://wanghaoxun.com/banwagong-server-ip.jpg\" alt=\"banwagong-server-ip\"></p>\n<p>最后，shadowsocks客户端连接配置页面如下：</p>\n<p><img src=\"http://wanghaoxun.com/shadowsocks-connected.jpg\" alt=\"shadowsocks-connected\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>首先去<a href=\"https://bandwagonhost.com/index.php\" target=\"_blank\" rel=\"noopener\">banwagong</a>网站购买服务器</li>\n<li>下载shadowsocks客户端<a href=\"https://shadowsocks.org/en/download/clients.html\" target=\"_blank\" rel=\"noopener\">shadowsocks</a></li>\n<li>设置服务器，安装操作系统和shadowsocks服务</li>\n<li>配置客户端连接远端服务</li>\n</ul>\n<h2 id=\"浏览器插件利器-SwitchyOmega\"><a href=\"#浏览器插件利器-SwitchyOmega\" class=\"headerlink\" title=\"浏览器插件利器-SwitchyOmega\"></a>浏览器插件利器-SwitchyOmega</h2><p>已经成功翻墙你，如果想对某些网站动态设置翻墙服务，可以使用SwitchyOmega来解决，详细教程请查看这里。</p>\n<p><a href=\"https://blog.csdn.net/shouldnotappearcalm/article/details/77900399\" target=\"_blank\" rel=\"noopener\">shadowsocks配合chrome插件SwitchyOmega</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/Shadowsock\" target=\"_blank\" rel=\"noopener\">Wikipedia-shadowsocks</a></li>\n<li><a href=\"https://vc2tea.com/whats-shadowsocks/\" target=\"_blank\" rel=\"noopener\">写给非专业人士看的 Shadowsocks 简介</a></li>\n<li><a href=\"https://bandwagonhost.com/clientarea.php?action=products\" target=\"_blank\" rel=\"noopener\">搬瓦工-产品链接</a></li>\n<li><a href=\"http://banwagong.cn/ovz-kvm.html\" target=\"_blank\" rel=\"noopener\">Linux VPS基本常识 - KVM与OpenVZ架构的区别</a></li>\n<li><a href=\"http://www.huizhanzhang.com/2017/05/bandwagon-one-key-shadowsocks.html\" target=\"_blank\" rel=\"noopener\">搬瓦工Bandwagon一键搭建ShadowSocks翻墙教程</a></li>\n<li><a href=\"https://blog.csdn.net/shouldnotappearcalm/article/details/77900399\" target=\"_blank\" rel=\"noopener\">shadowsocks配合chrome插件SwitchyOmega</a></li>\n</ul>"}],"PostAsset":[{"_id":"source/_posts/性能优化之卡顿优化/android_graphic_system_arch.png","slug":"android_graphic_system_arch.png","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/litho_thread_model.png","slug":"litho_thread_model.png","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/screen_adaptation_table.png","slug":"screen_adaptation_table.png","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/ui_display_flow.png","slug":"ui_display_flow.png","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/Mac-Terminal-终端代理配置/terminal_ping.jpg","slug":"terminal_ping.jpg","post":"ck5gf4vf3000wn2cbkknezig6","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之Matrix/matrix_compile_flow.jpg","slug":"matrix_compile_flow.jpg","post":"ck5gf4vfh001tn2cbxf18d4k7","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/async_create_view.png","slug":"async_create_view.png","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/android_thread_model.png","slug":"android_thread_model.png","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/systrace_demo_code.jpg","slug":"systrace_demo_code.jpg","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/xrk_process_cpu.jpg","slug":"xrk_process_cpu.jpg","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/xrk_homepage.png","slug":"xrk_homepage.png","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/Mac-Terminal-终端代理配置/shadowsocks_preferences.jpg","post":"ck5gf4vf3000wn2cbkknezig6","slug":"shadowsocks_preferences.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Mac-外接硬盘安装操作系统的那些事/installation_process.jpg","post":"ck5gf4vf40011n2cbqetkp2pm","slug":"installation_process.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Mac-外接硬盘安装操作系统的那些事/wtg_setup.jpg","post":"ck5gf4vf40011n2cbqetkp2pm","slug":"wtg_setup.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读/replugin_host_demo.jpg","post":"ck5gf4vf60014n2cb6ik1shyg","slug":"replugin_host_demo.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读/replugin_plugin_demo.jpg","post":"ck5gf4vf60014n2cb6ik1shyg","slug":"replugin_plugin_demo.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读/replugin_source_dir.jpg","post":"ck5gf4vf60014n2cb6ik1shyg","slug":"replugin_source_dir.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Replugin-源码分析1-源码导入阅读/replugin_source_reading.jpg","post":"ck5gf4vf60014n2cb6ik1shyg","slug":"replugin_source_reading.jpg","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之Matrix/matrix_methodmapping.jpg","slug":"matrix_methodmapping.jpg","post":"ck5gf4vfh001tn2cbxf18d4k7","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之Matrix/matrix_tracecanary_arch.jpg","post":"ck5gf4vfh001tn2cbxf18d4k7","slug":"matrix_tracecanary_arch.jpg","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之Matrix/xrk_matrix_analyse_result.png","slug":"xrk_matrix_analyse_result.png","post":"ck5gf4vfh001tn2cbxf18d4k7","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之Matrix/xrk_matrix_fps_result.png","slug":"xrk_matrix_fps_result.png","post":"ck5gf4vfh001tn2cbxf18d4k7","modified":1,"renderable":0},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/as_settings_remote.jpg","post":"ck5gf4vfr0022n2cbvslubute","slug":"as_settings_remote.jpg","modified":1,"renderable":1},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/connected_to_target_vm.jpg","post":"ck5gf4vfr0022n2cbvslubute","slug":"connected_to_target_vm.jpg","modified":1,"renderable":1},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/debug_coding_sense.jpg","slug":"debug_coding_sense.jpg","post":"ck5gf4vfr0022n2cbvslubute","modified":1,"renderable":0},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/gradle_execute_remote_code.jpg","post":"ck5gf4vfr0022n2cbvslubute","slug":"gradle_execute_remote_code.jpg","modified":1,"renderable":1},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/gradle_task_daemon.jpg","post":"ck5gf4vfr0022n2cbvslubute","slug":"gradle_task_daemon.jpg","modified":1,"renderable":1},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/toolbar_debug_attach.jpg","post":"ck5gf4vfr0022n2cbvslubute","slug":"toolbar_debug_attach.jpg","modified":1,"renderable":1},{"_id":"source/_posts/断点调试-APT-和-Gradle-Plugin/toolbar_edit_configurations.jpg","post":"ck5gf4vfr0022n2cbvslubute","slug":"toolbar_edit_configurations.jpg","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/layout_flat.png","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"layout_flat.png","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/as_profiler.jpg","slug":"as_profiler.jpg","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/cpu_and_gpu.png","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"cpu_and_gpu.png","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/ddms_traceview_result.jpg","slug":"ddms_traceview_result.jpg","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/ddms_traceview_setting.jpg","slug":"ddms_traceview_setting.jpg","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/display_jank.png","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"display_jank.png","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/display_renderthread.png","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"display_renderthread.png","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/flutter_render_engine.png","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"flutter_render_engine.png","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/optimize_recyclerview.png","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"optimize_recyclerview.png","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/overdraw_tools.png","slug":"overdraw_tools.png","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/pc_cpu_info.jpg","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"pc_cpu_info.jpg","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/pc_cpu_usage.jpg","slug":"pc_cpu_usage.jpg","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/soft_draw_android3.0.png","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"soft_draw_android3.0.png","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/soft_draw_android4.0.png","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"soft_draw_android4.0.png","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/systrace_result.jpg","slug":"systrace_result.jpg","post":"ck5gf4vfk001vn2cbkz0oamcp","modified":1,"renderable":0},{"_id":"source/_posts/性能优化之卡顿优化/triple_buffering.png","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"triple_buffering.png","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/view_displaylist.png","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"view_displaylist.png","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/view_reuse.png","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"view_reuse.png","modified":1,"renderable":1},{"_id":"source/_posts/性能优化之卡顿优化/vsync_signal.png","post":"ck5gf4vfk001vn2cbkz0oamcp","slug":"vsync_signal.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck5gf4ve40000n2cbojuhj192","category_id":"ck5gf4veg0004n2cbrecfbsj6","_id":"ck5gf4vev000gn2cbxw7pxvn7"},{"post_id":"ck5gf4veb0002n2cbhten54qh","category_id":"ck5gf4veg0004n2cbrecfbsj6","_id":"ck5gf4vey000ln2cbsx29ob5y"},{"post_id":"ck5gf4vei0006n2cb47vyscj0","category_id":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vf1000sn2cb237o2hc1"},{"post_id":"ck5gf4vel0008n2cbyyr0ci4n","category_id":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vf4000zn2cb8ran00dr"},{"post_id":"ck5gf4vf0000qn2cbz1wb8c19","category_id":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vf50013n2cbs645f2l8"},{"post_id":"ck5gf4vep0009n2cbtewsn9fy","category_id":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vf70016n2cbq1ylsuow"},{"post_id":"ck5gf4ves000dn2cbzg4j8tk2","category_id":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vfa001cn2cb4ferbyk7"},{"post_id":"ck5gf4vf60014n2cb6ik1shyg","category_id":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vfb001gn2cb7vh9fqh9"},{"post_id":"ck5gf4vf70018n2cb51tdh6ys","category_id":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vfc001jn2cb8kav952c"},{"post_id":"ck5gf4veu000en2cb8viocqq7","category_id":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vfe001nn2cbz2qmpn30"},{"post_id":"ck5gf4vew000jn2cb6bmnnde3","category_id":"ck5gf4vfa001bn2cbqicq4t4l","_id":"ck5gf4vfg001rn2cbdoiozj6i"},{"post_id":"ck5gf4vex000kn2cbw6i0it90","category_id":"ck5gf4vfa001bn2cbqicq4t4l","_id":"ck5gf4vfo001xn2cbnflkuis8"},{"post_id":"ck5gf4vez000on2cba0m7bbhb","category_id":"ck5gf4vfa001bn2cbqicq4t4l","_id":"ck5gf4vft0023n2cbzhbt6yuw"},{"post_id":"ck5gf4vf2000un2cbxb3t9hr1","category_id":"ck5gf4vfn001wn2cb4rpkebjj","_id":"ck5gf4vfx0029n2cbi7hc76gx"},{"post_id":"ck5gf4vf3000wn2cbkknezig6","category_id":"ck5gf4vfu0025n2cbuhctysgo","_id":"ck5gf4vfz002en2cbiv72zx59"},{"post_id":"ck5gf4vf40011n2cbqetkp2pm","category_id":"ck5gf4vfu0025n2cbuhctysgo","_id":"ck5gf4vg0002hn2cb445uqh84"},{"post_id":"ck5gf4vf8001an2cbar9cuafv","category_id":"ck5gf4vfz002dn2cbibqjqhof","_id":"ck5gf4vg1002mn2cbq8woiixi"},{"post_id":"ck5gf4vfa001fn2cbeaegarbk","category_id":"ck5gf4vg0002in2cb4sutv3o6","_id":"ck5gf4vg3002qn2cb0apk8csj"},{"post_id":"ck5gf4vfb001in2cbrmoo0swu","category_id":"ck5gf4vg2002nn2cbkic7ef8d","_id":"ck5gf4vg4002un2cbgzkjy7ua"},{"post_id":"ck5gf4vfd001mn2cbzvjefftd","category_id":"ck5gf4vg3002rn2cbk5d7x4h4","_id":"ck5gf4vg5002yn2cb4c5i799r"},{"post_id":"ck5gf4vfe001pn2cb01k5wf8m","category_id":"ck5gf4vg4002vn2cbpny7r9ry","_id":"ck5gf4vg70032n2cbonepdji1"},{"post_id":"ck5gf4vfh001tn2cbxf18d4k7","category_id":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vg90037n2cb2wov4qnz"},{"post_id":"ck5gf4vfh001tn2cbxf18d4k7","category_id":"ck5gf4vg6002zn2cbtuloqe53","_id":"ck5gf4vga003an2cbwiv7ftim"},{"post_id":"ck5gf4vfk001vn2cbkz0oamcp","category_id":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vga003cn2cbpwub9o3h"},{"post_id":"ck5gf4vfk001vn2cbkz0oamcp","category_id":"ck5gf4vg6002zn2cbtuloqe53","_id":"ck5gf4vgb003en2cbqxpu9er9"},{"post_id":"ck5gf4vfp0020n2cb953uojt4","category_id":"ck5gf4vg4002vn2cbpny7r9ry","_id":"ck5gf4vgc003gn2cbythjwz8c"},{"post_id":"ck5gf4vfr0022n2cbvslubute","category_id":"ck5gf4vev000fn2cbqaru8h1i","_id":"ck5gf4vgc003jn2cb1e1ym2ej"},{"post_id":"ck5gf4vfr0022n2cbvslubute","category_id":"ck5gf4vga003bn2cbvan07c8e","_id":"ck5gf4vgd003kn2cbw8rvw733"},{"post_id":"ck5gf4vfv0027n2cbntdt2oju","category_id":"ck5gf4vgc003hn2cbetu9snkr","_id":"ck5gf4vgd003ln2cbublkxmir"}],"PostTag":[{"post_id":"ck5gf4ve40000n2cbojuhj192","tag_id":"ck5gf4veh0005n2cbheofi28o","_id":"ck5gf4ves000cn2cbwfeyxxwn"},{"post_id":"ck5gf4veb0002n2cbhten54qh","tag_id":"ck5gf4veh0005n2cbheofi28o","_id":"ck5gf4vew000in2cbohnk6ztc"},{"post_id":"ck5gf4vei0006n2cb47vyscj0","tag_id":"ck5gf4vev000hn2cbiohy8x6f","_id":"ck5gf4vf0000pn2cb1h68hqqb"},{"post_id":"ck5gf4vel0008n2cbyyr0ci4n","tag_id":"ck5gf4vev000hn2cbiohy8x6f","_id":"ck5gf4vf2000vn2cbgfhmlsbo"},{"post_id":"ck5gf4vf0000qn2cbz1wb8c19","tag_id":"ck5gf4vev000hn2cbiohy8x6f","_id":"ck5gf4vf3000xn2cblei834er"},{"post_id":"ck5gf4vep0009n2cbtewsn9fy","tag_id":"ck5gf4vev000hn2cbiohy8x6f","_id":"ck5gf4vf50012n2cb149y7afl"},{"post_id":"ck5gf4ves000dn2cbzg4j8tk2","tag_id":"ck5gf4vev000hn2cbiohy8x6f","_id":"ck5gf4vf80019n2cbct5qvo19"},{"post_id":"ck5gf4vf70018n2cb51tdh6ys","tag_id":"ck5gf4vev000hn2cbiohy8x6f","_id":"ck5gf4vfa001en2cb1chvbhel"},{"post_id":"ck5gf4veu000en2cb8viocqq7","tag_id":"ck5gf4vev000hn2cbiohy8x6f","_id":"ck5gf4vfb001hn2cbkkybyzx4"},{"post_id":"ck5gf4vew000jn2cb6bmnnde3","tag_id":"ck5gf4vfa001dn2cbjopkj199","_id":"ck5gf4vfe001on2cbt6m3jec2"},{"post_id":"ck5gf4vex000kn2cbw6i0it90","tag_id":"ck5gf4vfa001dn2cbjopkj199","_id":"ck5gf4vfi001un2cb40jjcbok"},{"post_id":"ck5gf4vfh001tn2cbxf18d4k7","tag_id":"ck5gf4vev000hn2cbiohy8x6f","_id":"ck5gf4vfp001zn2cbondbkrgn"},{"post_id":"ck5gf4vez000on2cba0m7bbhb","tag_id":"ck5gf4vfa001dn2cbjopkj199","_id":"ck5gf4vfr0021n2cbntu4c19z"},{"post_id":"ck5gf4vfk001vn2cbkz0oamcp","tag_id":"ck5gf4vev000hn2cbiohy8x6f","_id":"ck5gf4vfu0024n2cbh3san6l3"},{"post_id":"ck5gf4vf2000un2cbxb3t9hr1","tag_id":"ck5gf4vfo001yn2cbx0obfnhw","_id":"ck5gf4vfw0028n2cb2efidsls"},{"post_id":"ck5gf4vf3000wn2cbkknezig6","tag_id":"ck5gf4vfv0026n2cbf9f2tx7s","_id":"ck5gf4vfy002cn2cbmhz8tz18"},{"post_id":"ck5gf4vf40011n2cbqetkp2pm","tag_id":"ck5gf4vfv0026n2cbf9f2tx7s","_id":"ck5gf4vg0002gn2cbc9rgmlxo"},{"post_id":"ck5gf4vf60014n2cb6ik1shyg","tag_id":"ck5gf4vev000hn2cbiohy8x6f","_id":"ck5gf4vg1002kn2cbtrzgnqsc"},{"post_id":"ck5gf4vf60014n2cb6ik1shyg","tag_id":"ck5gf4vfz002fn2cbp4xmrpxe","_id":"ck5gf4vg1002ln2cbuzdd8s4f"},{"post_id":"ck5gf4vf8001an2cbar9cuafv","tag_id":"ck5gf4vg0002jn2cbi3ut9guj","_id":"ck5gf4vg2002pn2cbeh83415g"},{"post_id":"ck5gf4vfa001fn2cbeaegarbk","tag_id":"ck5gf4vg2002on2cbfre5v2db","_id":"ck5gf4vg4002tn2cbtxr97o61"},{"post_id":"ck5gf4vfb001in2cbrmoo0swu","tag_id":"ck5gf4vg3002sn2cb4bwy7be9","_id":"ck5gf4vg5002xn2cbdfg9sk04"},{"post_id":"ck5gf4vfd001mn2cbzvjefftd","tag_id":"ck5gf4vg4002wn2cb3jux79lb","_id":"ck5gf4vg60031n2cb099m7z0v"},{"post_id":"ck5gf4vfe001pn2cb01k5wf8m","tag_id":"ck5gf4vg60030n2cbol2n7pr4","_id":"ck5gf4vg80035n2cbguek66rq"},{"post_id":"ck5gf4vfp0020n2cb953uojt4","tag_id":"ck5gf4vg60030n2cbol2n7pr4","_id":"ck5gf4vga0039n2cbhcpr5fb4"},{"post_id":"ck5gf4vfr0022n2cbvslubute","tag_id":"ck5gf4vg90038n2cbkc9zb6vr","_id":"ck5gf4vgb003fn2cbgm2zydjh"},{"post_id":"ck5gf4vfv0027n2cbntdt2oju","tag_id":"ck5gf4vgb003dn2cbbcodph7h","_id":"ck5gf4vgc003in2cb4qoqzzdt"}],"Tag":[{"name":"Android Studio","_id":"ck5gf4veh0005n2cbheofi28o"},{"name":"Android","_id":"ck5gf4vev000hn2cbiohy8x6f"},{"name":"Github","_id":"ck5gf4vfa001dn2cbjopkj199"},{"name":"Java","_id":"ck5gf4vfo001yn2cbx0obfnhw"},{"name":"Mac","_id":"ck5gf4vfv0026n2cbf9f2tx7s"},{"name":"插件化","_id":"ck5gf4vfz002fn2cbp4xmrpxe"},{"name":"工具","_id":"ck5gf4vg0002jn2cbi3ut9guj"},{"name":"Vim","_id":"ck5gf4vg2002on2cbfre5v2db"},{"name":"技术规范","_id":"ck5gf4vg3002sn2cb4bwy7be9"},{"name":"Hexo","_id":"ck5gf4vg4002wn2cb3jux79lb"},{"name":"Life","_id":"ck5gf4vg60030n2cbol2n7pr4"},{"name":"调试","_id":"ck5gf4vg90038n2cbkc9zb6vr"},{"name":"翻墙","_id":"ck5gf4vgb003dn2cbbcodph7h"}]}}